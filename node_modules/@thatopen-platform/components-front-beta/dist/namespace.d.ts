declare namespace OBC {
import * as THREE from "three";
import * as OBC from "@thatopen-platform/components-beta";
import { Postproduction } from "./src/postproduction";
import { RendererWith2D } from "../Marker";
/**
 * A class that extends RendererWith2D and adds post-processing capabilities. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/PostproductionRenderer). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/PostproductionRenderer).
 */
export declare class PostproductionRenderer extends RendererWith2D {
    private _postproduction?;
    /**
     * Getter for the postproduction instance.
     * Throws an error if the postproduction instance is not yet initialized.
     *
     * @returns The initialized Postproduction instance.
     */
    get postproduction(): Postproduction;
    constructor(components: OBC.Components, container: HTMLElement, parameters?: Partial<THREE.WebGLRendererParameters>);
    /** {@link Updateable.update} */
    update(): void;
    /** {@link OBC.Disposable.dispose}. */
    dispose(): void;
    private resizePostproduction;
    private setPostproductionSize;
}
import * as OBC from "@thatopen-platform/components-beta";
export declare class PlatformComponents extends OBC.Component {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "74c0c370-1af8-4ca9-900a-4a4196c0f2f5";
    enabled: boolean;
    inputs: string[];
    private readonly _requestEventID;
    private readonly _createEventID;
    constructor(components: OBC.Components);
    import(componentSource: string): Promise<OBC.ComponentWithUI>;
}
import * as OBC from "@thatopen-platform/components-beta";
import * as THREE from "three";
/**
 * This component allows adding a colored outline with thickness to fragments in a 3D scene. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/Highlighter). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/Outliner).
 */
export declare class Outliner extends OBC.Component {
    private _world?;
    /**
     * The world where the outliner operates.
     */
    set world(value: OBC.World | undefined);
    get world(): OBC.World | undefined;
    outlinePositions: boolean;
    points: THREE.Points<THREE.BufferGeometry<THREE.NormalBufferAttributes>, THREE.PointsMaterial, THREE.Object3DEventMap>;
    /** {@link OBC.Component.enabled} */
    get enabled(): boolean;
    /** {@link OBC.Component.enabled} */
    set enabled(value: boolean);
    get color(): THREE.Color;
    set color(value: THREE.Color);
    get thickness(): number;
    set thickness(value: number);
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "2fd3bcc5-b3b6-4ded-9f64-f47a02854a10";
    add(styleName: string): void;
    delete(styleName: string): void;
    private updatePoints;
    private getRenderer;
}
import * as THREE from "three";
import * as OBC from "@thatopen-platform/components-beta";
import { Mark } from "./src";
/**
 * Interface representing a marker object.
 */
export interface IMarker {
    /**
     * Unique identifier for the marker.
     */
    key: string;
    /**
     * Label of the marker.
     */
    label: Mark;
    /**
     * Optional type of the marker.
     */
    type?: string;
    /**
     * Indicates whether the marker is merged with other markers.
     */
    merged: boolean;
    /**
     * Indicates whether the marker is static and should not be clustered.
     */
    static: boolean;
}
/**
 * Interface representing a group of markers.
 */
export interface IGroupedMarkers {
    /**
     * Unique identifier for the group of markers.
     */
    key: string;
    /**
     * Array of keys of markers that belong to this group.
     */
    markerKeys: string[];
    /**
     * Label of the group of markers.
     */
    label: Mark;
}
/**
 * Component for Managing Markers along with creating different types of markers. Every marker is a Simple2DMarker. For every marker that needs to be added, you can use the Manager to add the marker and change its look and feel. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/Marker). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen-platform/components-beta-front/classes/Marker).
 */
export declare class Marker extends OBC.Component implements OBC.Disposable {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "4079eb91-79b0-4ede-bcf2-15b837129236";
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    /** {@link OBC.Component.enabled} */
    enabled: boolean;
    /**
     * The distance threshold for clustering markers.
     * Markers within this distance will be considered for clustering.
     * Default value is 50.
     */
    threshold: number;
    /**
     * Indicates whether markers should be automatically clustered.
     * If true, markers will be clustered based on the threshold value.
     * Default value is true.
     */
    autoCluster: boolean;
    /**
     * A Map containing the markers grouped by world UUID.
     * Each world can have its own set of markers.
     */
    list: Map<string, Map<string, IMarker>>;
    protected clusterLabels: Set<IGroupedMarkers>;
    protected currentKeys: Set<string>;
    protected _color: string;
    protected _markerKey: number;
    protected _clusterKey: number;
    private _worldEvents;
    private _setupWorlds;
    /**
     * Getter for the color property.
     * Returns the current color of the markers.
     *
     * @returns {string} The current color of the markers.
     */
    get color(): string;
    /**
     * Setter for the color property.
     * Updates the color of all the markers to the new value.
     *
     * @param {string} value - The new color value for the markers.
     */
    set color(value: string);
    constructor(components: OBC.Components);
    /**
     * Creates a new marker at the specified point in the world.
     *
     * @param world - The world where the marker will be created.
     * @param text - The text content of the marker.
     * @param point - The 3D position where the marker will be placed.
     * @param isStatic - Indicates whether the marker should be static and not clustered.
     * @returns The unique key of the created marker.
     */
    create(world: OBC.World, text: string, point: THREE.Vector3, isStatic?: boolean): string | undefined;
    /**
     * Deletes a marker with the specified ID from all worlds.
     *
     * @param id - The unique identifier of the marker to be deleted.
     *
     * @remarks
     * This method iterates through all the worlds and their respective markers.
     * If a marker with the specified ID is found, it disposes of the marker's label
     * and removes the marker from the world's marker list.
     *
     */
    delete(id: string): void;
    /**
     * Retrieves the list of markers associated with a specific world.
     * If the list does not exist for the given world, it creates a new one.
     *
     * @param world - The world for which the marker list is to be retrieved.
     * @returns A Map containing the markers associated with the given world.
     *
     * @remarks
     * This method is used to manage markers per world. It ensures that each world has its own set of markers.
     * If a marker list for the given world does not exist, it creates a new one and associates it with the world.
     */
    getWorldMarkerList(world: OBC.World): Map<string, IMarker>;
    /** {@link OBC.Disposable.dispose} */
    dispose(type?: string): void;
    /**
     * Sets up event listeners for clustering markers in the given world.
     *
     * @param world - The world where the event listeners will be set up.
     * @param enabled - Indicates whether the event listeners should be enabled or disabled.
     *
     * @remarks
     * This method checks if the event listeners are already set up for the given world.
     * If the event listeners are already set up and the 'enabled' parameter is true, the method returns without doing anything.
     * If the world does not have camera controls, the method returns without doing anything.
     *
     * The method then retrieves the event listener for the given world using the 'getWorldEvent' method.
     * It removes the existing event listeners for the "sleep" and "rest" events from the world's camera controls.
     *
     * If the 'enabled' parameter is true, the method adds the event listener for the "sleep" and "rest" events to the world's camera controls.
     */
    setupEvents(world: OBC.World, enabled: boolean): void;
    /**
     * Performs clustering of markers in the given world.
     *
     * @param world - The world where clustering will be performed.
     *
     */
    cluster(world: OBC.World): void;
    private getWorldEvent;
    private resetMarkers;
    private removeMergeMarkers;
    private getAveragePositionFromLabels;
    private createClusterElement;
    private getScreenPosition;
    private distance;
    private navigateToCluster;
}
import * as THREE from "three";
import * as OBC from "@thatopen-platform/components-beta";
export interface HighlighterStyle {
    name: string;
    color: THREE.Color;
    opacity: number;
    transparent: boolean;
    side: number;
}
/**
 * Interface defining the events that the Highlighter class can trigger. Each highlighter has its own set of events, identified by the highlighter name.
 */
export interface HighlightEvents {
    [highlighterName: string]: {
        /** Event triggered before a fragment is highlighted, giving the last selection. */
        onBeforeHighlight: OBC.Event<{
            [key: string]: Set<number>;
        }>;
        /** Event triggered when a fragment is highlighted. */
        onHighlight: OBC.Event<{
            [key: string]: Set<number>;
        }>;
        /** Event triggered when a fragment is cleared. */
        onClear: OBC.Event<null>;
    };
}
/**
 * Interface defining the configuration options for the Highlighter class.
 */
export interface HighlighterConfig {
    /** Name of the selection event. */
    selectName: string;
    /** Toggles the select functionality. */
    selectEnabled: boolean;
    /** Name of the hover event. */
    hoverName: string;
    /** Toggles the hover functionality. */
    hoverEnabled: boolean;
    /** Color used for selection. */
    selectionColor: THREE.Color | null;
    /** Color used for hover. */
    hoverColor: THREE.Color | null;
    /** Whether to automatically highlight fragments on click. */
    autoHighlightOnClick: boolean;
    /** The world in which the highlighter operates. */
    world: OBC.World | null;
}
/**
 * This component allows highlighting and selecting fragments in a 3D scene. ðŸ“• [Tutorial](https://docs.thatopen.com/Tutorials/Components/Front/Highlighter). ðŸ“˜ [API](https://docs.thatopen.com/api/@thatopen/components-front/classes/Highlighter).
 */
export declare class Highlighter extends OBC.Component implements OBC.Disposable, OBC.Eventable {
    /**
     * A unique identifier for the component.
     * This UUID is used to register the component within the Components system.
     */
    static readonly uuid: "cb8a76f2-654a-4b50-80c6-66fd83cafd77";
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    /** {@link OBC.Updateable.onBeforeUpdate} */
    readonly onBeforeUpdate: OBC.Event<Highlighter>;
    /** {@link OBC.Updateable.onAfterUpdate} */
    readonly onAfterUpdate: OBC.Event<Highlighter>;
    /** Event triggered when the Highlighter is setup. */
    readonly onSetup: OBC.Event<Highlighter>;
    /** Indicates whether the Highlighter is setup. */
    isSetup: boolean;
    /** {@link OBC.Component.enabled} */
    enabled: boolean;
    /** Stores the events triggered by the Highlighter. */
    events: HighlightEvents;
    /** Determines the multiple selection behavior. */
    multiple: "none" | "shiftKey" | "ctrlKey";
    /** Zoom factor applied when zooming to selection. */
    zoomFactor: number;
    /** Indicates whether to zoom to the selection when highlighting. */
    zoomToSelection: boolean;
    /** Stores the backup color before selection. */
    backupColor: THREE.Color | null;
    /** Stores the current selection. */
    selection: {
        [selectionID: string]: {
            [key: string]: Set<number>;
        };
    };
    /** Stores the configuration options for the Highlighter. */
    config: Required<HighlighterConfig>;
    /** Stores the styles used for highlighting selections. If null, the highlighter won't color geometries (useful for selection without coloring). */
    styles: Map<string, HighlighterStyle>;
    /** Styles with auto toggle will be unselected when selected twice. */
    autoToggle: Set<string>;
    /** Position of the mouse on mouseDown. */
    private mouseDownPosition;
    /** Threshhold on how much the mouse have to move until its considered movement */
    mouseMoveThreshold: number;
    /** If defined, only the specified elements will be selected by the specified style. */
    selectable: {
        [name: string]: {
            [key: string]: number[];
        };
    } | null;
    /** Manager to easily toggle and reset all events. */
    eventManager: OBC.EventManager;
    private _mouseState;
    private _stylesBeforeSelect;
    constructor(components: OBC.Components);
    /** {@link Disposable.dispose} */
    dispose(): Promise<void>;
    /**
     * Adds a new selection with the given name and color.
     * Throws an error if a selection with the same name already exists.
     *
     * @param name - The name of the new selection.
     * @param color - The color to be used for highlighting the selection.
     *
     * @throws Will throw an error if a selection with the same name already exists.
     */
    add(style: HighlighterStyle): void;
    /**
     * Removes the specified selection.
     *
     * @param name - The name of the new selection.
     */
    remove(name: string): Promise<void>;
    /**
     * Highlights a fragment based on a raycast from the mouse position.
     *
     * @param name - The name of the selection.
     * @param removePrevious - Whether to remove previous highlights.
     * @param zoomToSelection - Whether to zoom to the highlighted selection.
     * @param exclude - Fragments to exclude from the highlight.
     *
     * @returns The highlighted fragment and its ID, or null if no fragment was highlighted.
     *
     * @throws Will throw an error if the world or a required component is not found.
     * @throws Will throw an error if the selection does not exist.
     * @throws Will throw an error if the fragment or its geometry is not found.
     * @throws Will throw an error if the item ID is not found.
     * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
     */
    highlight(name: string, removePrevious?: boolean, zoomToSelection?: boolean, exclude?: {
        [key: string]: number[];
    } | null): Promise<{
        [key: string]: number[];
    } | null>;
    /**
     * Highlights a fragment based on a given fragment ID map.
     *
     * @param name - The name of the selection.
     * @param modelIdMap - The fragment ID map to highlight.
     * @param removePrevious - Whether to remove previous highlights.
     * @param zoomToSelection - Whether to zoom to the highlighted selection.
     * @param exclude - Fragments to exclude from the highlight.
     * @param fillMesh - The fill mesh to also highlight, if any.
     * @param isPicking - Whether this function is called when picking with the mouse.
     *
     * @returns Promise that resolves when the highlighting is complete.
     *
     * @throws Will throw an error if the selection does not exist.
     * @throws Will throw an error if the fragment or its geometry is not found.
     * @throws Will throw an error if the item ID is not found.
     * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
     */
    highlightByID(name: string, modelIdMap: {
        [modelId: string]: number[];
    }, removePrevious?: boolean, zoomToSelection?: boolean, exclude?: {
        [key: string]: number[];
    } | null, isPicking?: boolean): Promise<void>;
    private updateItems;
    private clearItems;
    /**
     * Clears the selection for the given name or all selections if no name is provided.
     *
     * @param name - The name of the selection to clear. If not provided, clears all selections.
     * @param filter - The only items to unselect. If not provided, all items will be unselected.
     *
     */
    clear(name?: string, filter?: {
        [modelId: string]: number[];
    }): Promise<void>;
    /**
     * Sets up the Highlighter with the provided configuration.
     *
     * @param config - Optional configuration for the Highlighter.
     * If not provided, the Highlighter will use the default configuration.
     *
     * @throws Will throw an error if the world or a required component is not found.
     * @throws Will throw an error if the selection already exists.
     * @throws Will throw an error if the fragment or its geometry is not found.
     * @throws Will throw an error if the item ID is not found.
     * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
     */
    setup(config?: Partial<HighlighterConfig>): void;
    private zoomSelection;
    private saveHighlightersBeforeSelect;
    private restoreHighlightersAfterDeselect;
    private setupEvents;
    private onMouseDown;
    private onMouseUp;
    private onMouseMove;
}
import * as THREE from "three";
import * as OBC from "@thatopen-platform/components-beta";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
import { CustomEffectsPass } from "./custom-effects-pass";
/**
 * Interface defining the settings for the post-processing effects.
 */
export interface PostproductionSettings {
    /**
     * Flag indicating whether to apply gamma correction.
     * Default: true
     */
    gamma?: boolean;
    /**
     * Flag indicating whether to apply custom effects.
     * Default: true
     */
    custom?: boolean;
    /**
     * Flag indicating whether to apply Ambient Occlusion (AO) effect.
     * Default: false
     */
    ao?: boolean;
}
/**
 * Class representing a post-processing effect manager for a 3D scene. It uses the EffectComposer from three.js to apply various post-processing effects. Thanks to [this](https://discourse.threejs.org/t/how-to-render-full-outlines-as-a-post-process-tutorial/22674).
 */
export declare class Postproduction {
    /**
     * The EffectComposer instance used for managing the post-processing effects.
     */
    readonly composer: EffectComposer;
    /**
     * Flag indicating whether to override the clipping planes of the renderer.
     * Default: false
     */
    overrideClippingPlanes: boolean;
    private readonly _components;
    private readonly _world;
    private readonly _renderTarget;
    private _enabled;
    private _initialized;
    private _n8ao?;
    private _customEffects?;
    private _basePass?;
    private _gammaPass?;
    private _depthTexture?;
    private _renderer;
    private _settings;
    /**
     * Getter for the base pass. Throws an error if the custom effects are not initialized.
     */
    get basePass(): RenderPass;
    /**
     * Getter for the gamma pass. Throws an error if the custom effects are not initialized.
     */
    get gammaPass(): ShaderPass;
    /**
     * Getter for the custom effects pass. Throws an error if the custom effects are not initialized.
     */
    get customEffects(): CustomEffectsPass;
    /**
     * Getter for the N8AO pass. Throws an error if the custom effects are not initialized.
     */
    get n8ao(): any;
    /**
     * Getter for the enabled state of the post-processing effects.
     */
    get enabled(): boolean;
    /**
     * Setter for the enabled state of the post-processing effects.
     * If the custom effects are not initialized, it calls the initialize method.
     * @param {boolean} active - The new enabled state.
     */
    set enabled(active: boolean);
    /**
     * Getter for the current post-processing settings.
     */
    get settings(): {
        /**
         * Flag indicating whether to apply gamma correction.
         * Default: true
         */
        gamma?: boolean | undefined;
        /**
         * Flag indicating whether to apply custom effects.
         * Default: true
         */
        custom?: boolean | undefined;
        /**
         * Flag indicating whether to apply Ambient Occlusion (AO) effect.
         * Default: false
         */
        ao?: boolean | undefined;
    };
    constructor(components: OBC.Components, renderer: THREE.WebGLRenderer, world: OBC.World);
    /**
     * Disposes of the resources held by the post-processing manager.
     * This method should be called when the post-processing manager is no longer needed.
     * It releases the memory occupied by the render target, depth texture, custom effects pass, gamma pass, and N8AO pass.
     */
    dispose(): void;
    /**
     * Sets the post-processing settings and updates the passes accordingly.
     * This method checks if the settings have changed before updating the passes.
     *
     * @param settings - The new post-processing settings.
     * @returns {void}
     */
    setPasses(settings: PostproductionSettings): void;
    /**
     * Sets the size of the render target and all related passes.
     * This method should be called when the window size changes to ensure that the post-processing effects are rendered correctly.
     *
     * @param width - The new width of the render target.
     * @param height - The new height of the render target.
     * @returns {void}
     */
    setSize(width: number, height: number): void;
    /**
     * Updates the post-processing effects.
     * This method checks if the post-processing effects are enabled before rendering.
     * If the effects are enabled, it calls the 'composer.render()' method to apply the effects.
     */
    update(): void;
    /**
     * Updates the camera settings for the post-processing effects.
     * This method is called whenever the camera settings change.
     * It updates the camera settings for the N8AO pass, custom effects pass, and base pass.
     */
    updateCamera(): void;
    /**
     * Updates the projection of the camera for the post-processing effects.
     * This method iterates over all passes in the EffectComposer and updates the camera property of each pass.
     * After updating the camera, it calls the update method to apply the changes.
     *
     * @param camera - The new camera to use for the post-processing effects.
     * @returns {void}
     */
    updateProjection(camera: THREE.Camera): void;
    private initialize;
    private updatePasses;
    private newCustomPass;
    private newGammaPass;
    private newSaoPass;
    private newBasePass;
}
import * as THREE from "three";
import * as OBC from "@thatopen-platform/components-beta";
import { Pass, FullScreenQuad } from "three/examples/jsm/postprocessing/Pass.js";
export declare class CustomEffectsPass extends Pass {
    components: OBC.Components;
    resolution: THREE.Vector2;
    renderScene: THREE.Scene;
    renderCamera: THREE.Camera;
    fsQuad: FullScreenQuad;
    normalOverrideMaterial: THREE.ShaderMaterial;
    glossOverrideMaterial: THREE.ShaderMaterial;
    outlineMaterial: THREE.MeshBasicMaterial;
    planeBuffer: THREE.WebGLRenderTarget;
    glossBuffer: THREE.WebGLRenderTarget;
    outlineBuffer: THREE.WebGLRenderTarget;
    excludedMeshes: THREE.Object3D[];
    outlinedStyles: Set<string>;
    outlineScene: THREE.Scene;
    private _outlineEnabled;
    private _lineColor;
    private _opacity;
    private _tolerance;
    private _glossEnabled;
    private _glossExponent;
    private _minGloss;
    private _maxGloss;
    get lineColor(): number;
    set lineColor(lineColor: number);
    get tolerance(): number;
    set tolerance(value: number);
    get opacity(): number;
    set opacity(value: number);
    get glossEnabled(): boolean;
    set glossEnabled(active: boolean);
    get glossExponent(): number;
    set glossExponent(value: number);
    get minGloss(): number;
    set minGloss(value: number);
    get maxGloss(): number;
    set maxGloss(value: number);
    get outlineEnabled(): boolean;
    set outlineEnabled(active: boolean);
    private _fragments;
    constructor(resolution: THREE.Vector2, components: OBC.Components, world: OBC.World, scene: THREE.Scene, camera: THREE.Camera);
    dispose(): Promise<void>;
    setSize(width: number, height: number): void;
    render(renderer: THREE.WebGLRenderer, writeBuffer: any, readBuffer: any): void;
    get vertexShader(): string;
    get fragmentShader(): string;
    createOutlinePostProcessMaterial(): THREE.ShaderMaterial;
    private newRenderTarget;
}
import * as THREE from "three";
import { CSS2DObject } from "three/examples/jsm/renderers/CSS2DRenderer.js";
import * as OBC from "@thatopen-platform/components-beta";
/**
 * Represents a marker in the 3D world.
 */
export declare class Mark implements OBC.Hideable, OBC.Disposable {
    /**
     * The CSS object representing the marker.
     */
    three: CSS2DObject;
    /**
     * The world in which the marker exists.
     */
    world: OBC.World;
    /** {@link OBC.Disposable.onDisposed} */
    readonly onDisposed: OBC.Event<unknown>;
    /** {@link OBC.Hideable.visible} */
    set visible(value: boolean);
    /** {@link OBC.Hideable.visible} */
    get visible(): boolean;
    constructor(world: OBC.World, element?: HTMLElement, parent?: THREE.Object3D);
    /**
     * Toggles the visibility of the marker.
     *
     * This method changes the 'visible' property of the marker to its opposite value.
     * If the marker is currently visible, it will be hidden, and vice versa.
     *
     * @returns {void}
     */
    toggleVisibility(): void;
    /** {@link OBC.Disposable.dispose} */
    dispose(): void;
}
import * as THREE from "three";
import { CSS2DRenderer } from "three/examples/jsm/renderers/CSS2DRenderer.js";
import { Components, SimpleRenderer } from "@thatopen-platform/components-beta";
/**
 * A basic renderer capable of rendering 3D and 2D objects ([Objec3Ds](https://threejs.org/docs/#api/en/core/Object3D) and [CSS2DObjects](https://threejs.org/docs/#examples/en/renderers/CSS2DRenderer) respectively).
 */
export declare class RendererWith2D extends SimpleRenderer {
    /**
     * This renderer is used to render 2D objects (CSS2DObjects) in a 3D scene.
     */
    three2D: CSS2DRenderer;
    constructor(components: Components, container: HTMLElement, parameters?: Partial<THREE.WebGLRendererParameters>);
    private setupHtmlRenderer;
}
import * as THREE from "three";
export declare function getProjectedNormalMaterial(): THREE.ShaderMaterial;
declare module "n8ao";
export {};
import * as THREE from "three";
export declare function getPlaneDistanceMaterial(): THREE.ShaderMaterial;

}