import {
  ss
} from "./chunk-7EUC2VHR.js";
import {
  BackSide,
  Box3,
  BufferAttribute,
  BufferGeometry,
  Clock,
  Color,
  DataTexture,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DoubleSide,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  HalfFloatType,
  Line3,
  LinearFilter,
  MOUSE,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  NearestFilter,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  Object3D,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Points,
  PointsMaterial,
  Quaternion,
  REVISION,
  RGBAFormat,
  Ray,
  Raycaster,
  RedFormat,
  RepeatWrapping,
  Scene,
  ShaderMaterial,
  Sphere,
  Spherical,
  Triangle,
  UniformsUtils,
  UnsignedInt248Type,
  UnsignedIntType,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  WebGLRenderer
} from "./chunk-BQJMB3HC.js";
import "./chunk-BUSYA2B4.js";

// node_modules/@thatopen-platform/components-front-beta/dist/index.js
var un = Object.defineProperty;
var fn = (a, t, e) => t in a ? un(a, t, { enumerable: true, configurable: true, writable: true, value: e }) : a[t] = e;
var G = (a, t, e) => (fn(a, typeof t != "symbol" ? t + "" : t, e), e);
var An = Object.defineProperty;
var On = (a, t, e) => t in a ? An(a, t, { enumerable: true, configurable: true, writable: true, value: e }) : a[t] = e;
var P = (a, t, e) => (On(a, typeof t != "symbol" ? t + "" : t, e), e);
var it = class {
  constructor() {
    P(this, "enabled", true), P(this, "trigger", (t) => {
      if (!this.enabled)
        return;
      const e = this.handlers.slice(0);
      for (const i of e)
        i(t);
    }), P(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(t) {
    this.handlers.push(t);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(t) {
    this.handlers = this.handlers.filter((e) => e !== t);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var Ts = class {
  constructor(t) {
    P(this, "isDisposeable", () => "dispose" in this && "onDisposed" in this), P(this, "isResizeable", () => "resize" in this && "getSize" in this), P(this, "isUpdateable", () => "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this), P(this, "isHideable", () => "visible" in this), P(this, "isConfigurable", () => "setup" in this && "config" in this && "onSetup" in this), this.components = t;
  }
};
var Zt = class extends Ts {
};
var Dr = class extends Ts {
  constructor(t) {
    super(t), P(this, "worlds", /* @__PURE__ */ new Map()), P(this, "onWorldChanged", new it()), P(this, "currentWorld", null), this.onWorldChanged.add(({ world: e, action: i }) => {
      i === "removed" && this.worlds.delete(e.uuid);
    });
  }
};
var Dn = class extends Dr {
  constructor() {
    super(...arguments), P(this, "hasCameraControls", () => "controls" in this);
  }
};
var Pn = class extends Dr {
  constructor() {
    super(...arguments), P(this, "onAfterUpdate", new it()), P(this, "onBeforeUpdate", new it()), P(this, "onDisposed", new it()), P(this, "onResize", new it()), P(this, "onClippingPlanesUpdated", new it()), P(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(t, e, i) {
    e.isLocal = i;
    const s = this.clippingPlanes.indexOf(e);
    t && s === -1 ? this.clippingPlanes.push(e) : !t && s > -1 && this.clippingPlanes.splice(s, 1), this.three.clippingPlanes = this.clippingPlanes.filter(
      (r) => !r.isLocal
    );
  }
};
var Pr = class hs extends Zt {
  constructor(t) {
    super(t), P(this, "_disposedComponents", /* @__PURE__ */ new Set()), P(this, "enabled", true), t.add(hs.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(t, e = true, i = true) {
    t.removeFromParent();
    const s = t;
    s.dispose && s.dispose(), this.disposeGeometryAndMaterials(t, e), i && s.children && s.children.length && this.disposeChildren(s), t.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(t) {
    t.boundsTree && t.disposeBoundsTree && t.disposeBoundsTree(), t.dispose();
  }
  disposeGeometryAndMaterials(t, e) {
    const i = t;
    i.geometry && this.disposeGeometry(i.geometry), e && i.material && hs.disposeMaterial(i), i.material = [], i.geometry = null;
  }
  disposeChildren(t) {
    for (const e of t.children)
      this.destroy(e);
  }
  static disposeMaterial(t) {
    if (t.material)
      if (Array.isArray(t.material))
        for (const e of t.material)
          e.dispose();
      else
        t.material.dispose();
  }
};
P(Pr, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
var zr = Pr;
var Bi = class extends Set {
  /**
   * Constructs a new instance of the DataSet class.
   *
   * @param iterable - An optional iterable object to initialize the set with.
   */
  constructor(t) {
    super(t), P(this, "onItemAdded", new it()), P(this, "onItemDeleted", new it()), P(this, "onCleared", new it()), P(this, "guard", () => true);
  }
  /**
   * Clears the set and triggers the onCleared event.
   */
  clear() {
    super.clear(), this.onCleared.trigger();
  }
  /**
   * Adds one or multiple values to the set and triggers the onItemAdded event per each.
   *
   * @param value - The value to add to the set.
   * @returns - The set instance.
   */
  add(...t) {
    for (const e of t)
      this.has(e) || !this.guard(e) || (super.add(e), this.onItemAdded || (this.onItemAdded = new it()), this.onItemAdded.trigger(e));
    return this;
  }
  /**
   * Deletes a value from the set and triggers the onItemDeleted event.
   *
   * @param value - The value to delete from the set.
   * @returns - True if the value was successfully deleted, false otherwise.
   */
  delete(t) {
    const e = super.delete(t);
    return e && this.onItemDeleted.trigger(), e;
  }
  /**
   * Clears the set and resets the onItemAdded, onItemDeleted, and onCleared events.
   */
  dispose() {
    this.clear(), this.onItemAdded.reset(), this.onItemDeleted.reset(), this.onCleared.reset();
  }
};
var Re = class extends Map {
  /**
   * Constructs a new DataMap instance.
   *
   * @param iterable - An iterable object containing key-value pairs to populate the map.
   */
  constructor(t) {
    super(t), P(this, "onItemSet", new it()), P(this, "onItemUpdated", new it()), P(this, "onItemDeleted", new it()), P(this, "onCleared", new it()), P(this, "guard", () => true);
  }
  /**
   * Clears the map and triggers the onCleared event.
   */
  clear() {
    super.clear(), this.onCleared.trigger();
  }
  /**
   * Sets the value for the specified key in the map.
   * If the item is new, then onItemSet is triggered.
   * If the item is already in the map, then onItemUpdated is triggered.
   *
   * @param key - The key of the item to set.
   * @param value - The value of the item to set.
   * @returns The DataMap instance.
   */
  set(t, e) {
    const i = this.has(t);
    if (!(this.guard ?? (() => true))(t, e))
      return this;
    const o = super.set(t, e);
    return i ? (this.onItemUpdated || (this.onItemUpdated = new it()), this.onItemUpdated.trigger({ key: t, value: e })) : (this.onItemSet || (this.onItemSet = new it()), this.onItemSet.trigger({ key: t, value: e })), o;
  }
  /**
   * Deletes the specified key from the map and triggers the onItemDeleted event if the key was found.
   *
   * @param key - The key of the item to delete.
   * @returns True if the key was found and deleted; otherwise, false.
   */
  delete(t) {
    const e = super.delete(t);
    return e && this.onItemDeleted.trigger(t), e;
  }
  /**
   * Clears the map and resets the events.
   */
  dispose() {
    this.clear(), this.onItemSet.reset(), this.onItemDeleted.reset(), this.onCleared.reset();
  }
};
var Yi = class {
  static isEntry(t) {
    return (/* @__PURE__ */ new Set([
      "Boolean",
      "Color",
      "Text",
      "Number",
      "Select",
      "Vector3",
      "TextSet",
      "None"
    ])).has(t.type);
  }
  static copySchema(t, e = {}) {
    for (const i in t) {
      const s = t[i];
      this.isEntry(s) ? e[i] = this.copyEntry(s) : (e[i] = {}, this.copySchema(s, e[i]));
    }
    return e;
  }
  static copyEntry(t) {
    if (t.type === "Boolean") {
      const e = t;
      return {
        type: e.type,
        value: e.value
      };
    }
    if (t.type === "Color") {
      const e = t;
      return {
        type: e.type,
        value: e.value.clone()
      };
    }
    if (t.type === "Text") {
      const e = t;
      return {
        type: e.type,
        value: e.value
      };
    }
    if (t.type === "Number") {
      const e = t;
      return {
        type: e.type,
        value: e.value,
        min: e.min,
        max: e.max,
        interpolable: e.interpolable
      };
    }
    if (t.type === "Select") {
      const e = t;
      return {
        type: e.type,
        value: e.value,
        multiple: e.multiple,
        options: new Set(e.options)
      };
    }
    if (t.type === "Vector3") {
      const e = t;
      return {
        type: e.type,
        value: e.value.clone()
      };
    }
    if (t.type === "TextSet") {
      const e = t;
      return {
        type: e.type,
        value: new Set(e.value)
      };
    }
    if (t.type === "None") {
      const e = t;
      return {
        type: e.type,
        value: e.value
      };
    }
    throw new Error("Invalid entry!");
  }
};
var zn = class {
  constructor() {
    P(this, "list", /* @__PURE__ */ new Set());
  }
  /**
   * Adds events to this manager.
   * @param events the events to add.
   */
  add(t) {
    for (const e of t)
      this.list.add(e);
  }
  /**
   * Removes events from this manager.
   * @param events the events to remove.
   */
  remove(t) {
    for (const e of t)
      this.list.delete(e);
  }
  /**
   * Sets all the events managed by this instance as enabled or disabled.
   * @param active whether to turn on or off the events.
   */
  set(t) {
    for (const e of this.list)
      e.enabled = t;
  }
  /**
   * Resets all the events managed by this instance.
   */
  reset() {
    for (const t of this.list)
      t.reset();
  }
};
var Cs = class Et {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0, s = Math.random() * 4294967295 | 0;
    return `${Et._lut[t & 255] + Et._lut[t >> 8 & 255] + Et._lut[t >> 16 & 255] + Et._lut[t >> 24 & 255]}-${Et._lut[e & 255]}${Et._lut[e >> 8 & 255]}-${Et._lut[e >> 16 & 15 | 64]}${Et._lut[e >> 24 & 255]}-${Et._lut[i & 63 | 128]}${Et._lut[i >> 8 & 255]}-${Et._lut[i >> 16 & 255]}${Et._lut[i >> 24 & 255]}${Et._lut[s & 255]}${Et._lut[s >> 8 & 255]}${Et._lut[s >> 16 & 255]}${Et._lut[s >> 24 & 255]}`.toLowerCase();
  }
  static validate(t) {
    if (!Et._pattern.test(t))
      throw new Error(
        `${t} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
P(Cs, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/);
P(Cs, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
var Le = Cs;
var Ss = class {
  constructor(t, e, i, s) {
    P(this, "_component"), P(this, "name"), P(this, "uuid"), this._component = t, this.name = i, this.uuid = s ?? Le.create(), e.get(Ir).list.set(this.uuid, this);
  }
  get controls() {
    return Yi.copySchema(this._config);
  }
  set(t) {
    for (const e in t)
      if (e in this) {
        const i = e;
        this[i] = t[e].value;
      }
  }
  export(t = this._config, e = {}) {
    for (const i in t) {
      const s = t[i];
      if (Yi.isEntry(s))
        if (s.type === "Color") {
          const { r: o, g: n, b: l } = s.value;
          e[i] = { ...s, value: { r: o, g: n, b: l } };
        } else if (s.type === "Vector3") {
          const { x: o, y: n, z: l } = s.value;
          e[i] = { ...s, value: { x: o, y: n, z: l } };
        } else if (s.type === "TextSet") {
          const o = Array.from(s.value);
          e[i] = { ...s, value: o };
        } else if (s.type === "Select") {
          const o = Array.from(s.options);
          e[i] = { ...s, options: o };
        } else
          e[i] = { ...s };
      else
        e[i] = {}, this.export(s, e[i]);
    }
    return e;
  }
  import(t, e = {}, i = true) {
    for (const s in t) {
      const r = t[s];
      if (Yi.isEntry(r))
        if (r.type === "Color") {
          const { r: n, g: l, b: c } = r.value;
          e[s] = { ...r, value: new Color(n, l, c) };
        } else if (r.type === "Vector3") {
          const { x: n, y: l, z: c } = r.value;
          e[s] = { ...r, value: new Vector3(n, l, c) };
        } else
          r.type === "TextSet" ? e[s] = { ...r, value: new Set(r.value) } : r.type === "Select" ? e[s] = { ...r, options: new Set(r.options) } : e[s] = { ...r };
      else
        e[s] = {}, this.import(r, e[s], false);
    }
    i && this.set(e);
  }
};
var kr = class Br extends Zt {
  constructor(t) {
    super(t), P(this, "list", new Re()), P(this, "enabled", true), t.add(Br.uuid, this);
  }
};
P(kr, "uuid", "b8c764e0-6b24-4e77-9a32-35fa728ee5b4");
var Ir = kr;
var kn = class extends Ts {
  constructor() {
    super(...arguments), P(this, "meshes", /* @__PURE__ */ new Set()), P(this, "onAfterUpdate", new it()), P(this, "onBeforeUpdate", new it()), P(this, "onDisposed", new it()), P(this, "isDisposing", false), P(this, "enabled", true), P(this, "uuid", Le.create()), P(this, "name"), P(this, "_scene"), P(this, "_camera"), P(this, "_renderer", null);
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene)
      throw new Error("No scene initialized!");
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(t) {
    this._scene = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera)
      throw new Error("No camera initialized!");
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(t) {
    this._camera = t, t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(t) {
    this._renderer = t, t && (t.worlds.set(this.uuid, this), t.currentWorld = this, t.onWorldChanged.trigger({ world: this, action: "added" }));
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (!this._scene || !this._camera || (this.scene.currentWorld = this, this.camera.currentWorld = this, this.renderer && (this.renderer.currentWorld = this), this.onBeforeUpdate.trigger(), this.scene.isUpdateable() && this.scene.update(t), this.camera.isUpdateable() && this.camera.update(t), this.renderer && this.renderer.update(t), this.onAfterUpdate.trigger()));
  }
  /** {@link Disposable.dispose} */
  dispose(t = true) {
    if (this.enabled = false, this.isDisposing = true, this.scene.onWorldChanged.trigger({ world: this, action: "removed" }), this.camera.onWorldChanged.trigger({ world: this, action: "removed" }), this.renderer && this.renderer.onWorldChanged.trigger({ world: this, action: "removed" }), t) {
      const i = this.components.get(zr);
      this.scene.dispose(), this.camera.isDisposeable() && this.camera.dispose(), this.renderer && this.renderer.dispose();
      for (const s of this.meshes)
        i.destroy(s);
      this.meshes.clear();
    }
    this._scene = null, this._camera = null, this._renderer = null, this.components.get(Ln).list.delete(this.uuid), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var Bn = class extends Pn {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(t, e, i) {
    super(t), P(this, "enabled", true), P(this, "container"), P(this, "three"), P(this, "_canvas"), P(this, "_parameters"), P(this, "_resizeObserver", null), P(this, "onContainerUpdated", new it()), P(this, "_resizing", false), P(this, "resize", (o) => {
      if (this._resizing)
        return;
      this._resizing = true, this.onContainerUpdated.trigger();
      const n = o ? o.x : this.container.clientWidth, l = o ? o.y : this.container.clientHeight;
      this.three.setSize(n, l), this.onResize.trigger(new Vector2(n, l)), this._resizing = false;
    }), P(this, "resizeEvent", () => {
      this.resize();
    }), P(this, "onContextLost", (o) => {
      o.preventDefault(), this.enabled = false;
    }), P(this, "onContextBack", () => {
      this.three.setRenderTarget(null), this.three.dispose(), this.three = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      }), this.enabled = true;
    }), this.container = e, this._parameters = i, this.three = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...i
    }), this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2)), this.setupRenderer(), this.setupEvents(true), this.resize(), this._canvas = this.three.domElement;
    const s = this.three.getContext(), { canvas: r } = s;
    r.addEventListener("webglcontextlost", this.onContextLost, false), r.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const t = this.currentWorld.scene.three, e = this.currentWorld.camera.three;
    this.three.render(t, e), this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false, this.setupEvents(false), this.three.domElement.remove(), this.three.forceContextLoss(), this.three.dispose(), this.onResize.reset(), this.onAfterUpdate.reset(), this.onBeforeUpdate.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(t) {
    const e = this.three.domElement.parentElement;
    if (!e)
      throw new Error("This renderer needs to have an HTML container!");
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null), window.removeEventListener("resize", this.resizeEvent), t && (this._resizeObserver = new ResizeObserver(this.resizeEvent), this._resizeObserver.observe(e), window.addEventListener("resize", this.resizeEvent));
  }
  setupRenderer() {
    this.three.localClippingEnabled = true, this.container && this.container.appendChild(this.three.domElement), this.onContainerUpdated.trigger();
  }
};
var yt = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var L = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  SCREEN_PAN: 4,
  OFFSET: 8,
  DOLLY: 16,
  ZOOM: 32,
  TOUCH_ROTATE: 64,
  TOUCH_TRUCK: 128,
  TOUCH_SCREEN_PAN: 256,
  TOUCH_OFFSET: 512,
  TOUCH_DOLLY: 1024,
  TOUCH_ZOOM: 2048,
  TOUCH_DOLLY_TRUCK: 4096,
  TOUCH_DOLLY_SCREEN_PAN: 8192,
  TOUCH_DOLLY_OFFSET: 16384,
  TOUCH_DOLLY_ROTATE: 32768,
  TOUCH_ZOOM_TRUCK: 65536,
  TOUCH_ZOOM_OFFSET: 131072,
  TOUCH_ZOOM_SCREEN_PAN: 262144,
  TOUCH_ZOOM_ROTATE: 524288
});
var we = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function me(a) {
  return a.isPerspectiveCamera;
}
function ce(a) {
  return a.isOrthographicCamera;
}
var be = Math.PI * 2;
var Fs = Math.PI / 2;
var Mr = 1e-5;
var Ze = Math.PI / 180;
function Yt(a, t, e) {
  return Math.max(t, Math.min(e, a));
}
function gt(a, t = Mr) {
  return Math.abs(a) < t;
}
function dt(a, t, e = Mr) {
  return gt(a - t, e);
}
function Us(a, t) {
  return Math.round(a / t) * t;
}
function We(a) {
  return isFinite(a) ? a : a < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function Ye(a) {
  return Math.abs(a) < Number.MAX_VALUE ? a : a * (1 / 0);
}
function ui(a, t, e, i, s = 1 / 0, r) {
  i = Math.max(1e-4, i);
  const o = 2 / i, n = o * r, l = 1 / (1 + n + 0.48 * n * n + 0.235 * n * n * n);
  let c = a - t;
  const d = t, f = s * i;
  c = Yt(c, -f, f), t = a - c;
  const p = (e.value + o * c) * r;
  e.value = (e.value - o * p) * l;
  let u = t + (c + p) * l;
  return d - a > 0 == u > d && (u = d, e.value = (u - d) / r), u;
}
function Ns(a, t, e, i, s = 1 / 0, r, o) {
  i = Math.max(1e-4, i);
  const n = 2 / i, l = n * r, c = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);
  let d = t.x, f = t.y, p = t.z, u = a.x - d, g = a.y - f, m = a.z - p;
  const b = d, h = f, v = p, x = s * i, _ = x * x, T = u * u + g * g + m * m;
  if (T > _) {
    const M = Math.sqrt(T);
    u = u / M * x, g = g / M * x, m = m / M * x;
  }
  d = a.x - u, f = a.y - g, p = a.z - m;
  const E = (e.x + n * u) * r, A = (e.y + n * g) * r, z = (e.z + n * m) * r;
  e.x = (e.x - n * E) * c, e.y = (e.y - n * A) * c, e.z = (e.z - n * z) * c, o.x = d + (u + E) * c, o.y = f + (g + A) * c, o.z = p + (m + z) * c;
  const D = b - a.x, I = h - a.y, U = v - a.z, C = o.x - b, k = o.y - h, w = o.z - v;
  return D * C + I * k + U * w > 0 && (o.x = b, o.y = h, o.z = v, e.x = (o.x - b) / r, e.y = (o.y - h) / r, e.z = (o.z - v) / r), o;
}
function ji(a, t) {
  t.set(0, 0), a.forEach((e) => {
    t.x += e.clientX, t.y += e.clientY;
  }), t.x /= a.length, t.y /= a.length;
}
function Qi(a, t) {
  return ce(a) ? (console.warn(`${t} is not supported in OrthographicCamera`), true) : false;
}
var In = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    const i = this._listeners;
    i[t] === void 0 && (i[t] = []), i[t].indexOf(e) === -1 && i[t].push(e);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(t, e) {
    const i = this._listeners;
    return i[t] !== void 0 && i[t].indexOf(e) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    const s = this._listeners[t];
    if (s !== void 0) {
      const r = s.indexOf(e);
      r !== -1 && s.splice(r, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(t) {
    if (!t) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[t]) && (this._listeners[t].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(t) {
    const i = this._listeners[t.type];
    if (i !== void 0) {
      t.target = this;
      const s = i.slice(0);
      for (let r = 0, o = s.length; r < o; r++)
        s[r].call(this, t);
    }
  }
};
var Gi;
var Mn = "2.10.0";
var fi = 1 / 8;
var Rn = /Mac/.test((Gi = globalThis == null ? void 0 : globalThis.navigator) === null || Gi === void 0 ? void 0 : Gi.platform);
var ot;
var Vs;
var di;
var Ki;
var Bt;
var lt;
var ut;
var xe;
var je;
var te;
var ee;
var ge;
var Hs;
var Zs;
var Ft;
var Qe;
var _e;
var Ws;
var Xi;
var Ys;
var qi;
var Ji;
var pi;
var Dt = class _Dt extends In {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(t) {
    ot = t.THREE, Vs = Object.freeze(new ot.Vector3(0, 0, 0)), di = Object.freeze(new ot.Vector3(0, 1, 0)), Ki = Object.freeze(new ot.Vector3(0, 0, 1)), Bt = new ot.Vector2(), lt = new ot.Vector3(), ut = new ot.Vector3(), xe = new ot.Vector3(), je = new ot.Vector3(), te = new ot.Vector3(), ee = new ot.Vector3(), ge = new ot.Vector3(), Hs = new ot.Vector3(), Zs = new ot.Vector3(), Ft = new ot.Spherical(), Qe = new ot.Spherical(), _e = new ot.Box3(), Ws = new ot.Box3(), Xi = new ot.Sphere(), Ys = new ot.Quaternion(), qi = new ot.Quaternion(), Ji = new ot.Matrix4(), pi = new ot.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return L;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(t, e) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = false, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = false, this.truckSpeed = 2, this.dollyToCursor = false, this.dragToOffset = false, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = true, this._state = L.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = true, this._boundaryEnclosesCamera = false, this._needsUpdate = true, this._updatedLastTime = false, this._elementRect = new DOMRect(), this._isDragging = false, this._dragNeedsUpdate = true, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._isUserControllingOffset = false, this._isUserControllingZoom = false, this._lastDollyDirection = we.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new ot.Vector3(), this._focalOffsetVelocity = new ot.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (h, v, x, _) => {
      let T, E;
      if (me(this._camera)) {
        const A = lt.copy(this._camera.position).sub(this._target), z = this._camera.getEffectiveFOV() * Ze, D = A.length() * Math.tan(z * 0.5);
        T = this.truckSpeed * h * D / this._elementRect.height, E = this.truckSpeed * v * D / this._elementRect.height;
      } else if (ce(this._camera)) {
        const A = this._camera;
        T = this.truckSpeed * h * (A.right - A.left) / A.zoom / this._elementRect.width, E = this.truckSpeed * v * (A.top - A.bottom) / A.zoom / this._elementRect.height;
      } else
        return;
      _ ? (x ? this.setFocalOffset(this._focalOffsetEnd.x + T, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(T, 0, true), this.forward(-E, true)) : x ? this.setFocalOffset(this._focalOffsetEnd.x + T, this._focalOffsetEnd.y + E, this._focalOffsetEnd.z, true) : this.truck(T, E, true);
    }, this._rotateInternal = (h, v) => {
      const x = be * this.azimuthRotateSpeed * h / this._elementRect.height, _ = be * this.polarRotateSpeed * v / this._elementRect.height;
      this.rotate(x, _, true);
    }, this._dollyInternal = (h, v, x) => {
      const _ = Math.pow(0.95, -h * this.dollySpeed), T = this._sphericalEnd.radius, E = this._sphericalEnd.radius * _, A = Yt(E, this.minDistance, this.maxDistance), z = A - E;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(E, true) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(z, true), this._dollyToNoClamp(A, true)) : this._dollyToNoClamp(A, true), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? E : A) - T, this._dollyControlCoord.set(v, x)), this._lastDollyDirection = Math.sign(-h);
    }, this._zoomInternal = (h, v, x) => {
      const _ = Math.pow(0.95, h * this.dollySpeed), T = this._zoom, E = this._zoom * _;
      this.zoomTo(E, true), this.dollyToCursor && (this._changedZoom += E - T, this._dollyControlCoord.set(v, x));
    }, typeof ot > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = t, this._yAxisUpSpace = new ot.Quaternion().setFromUnitVectors(this._camera.up, di), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = L.NONE, this._target = new ot.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new ot.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new ot.Spherical().setFromVector3(lt.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new ot.Vector3(),
      new ot.Vector3(),
      new ot.Vector3(),
      new ot.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new ot.Box3(new ot.Vector3(-1 / 0, -1 / 0, -1 / 0), new ot.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new ot.Vector2(), this.mouseButtons = {
      left: L.ROTATE,
      middle: L.DOLLY,
      right: L.TRUCK,
      wheel: me(this._camera) ? L.DOLLY : ce(this._camera) ? L.ZOOM : L.NONE
    }, this.touches = {
      one: L.TOUCH_ROTATE,
      two: me(this._camera) ? L.TOUCH_DOLLY_TRUCK : ce(this._camera) ? L.TOUCH_ZOOM_TRUCK : L.NONE,
      three: L.TOUCH_TRUCK
    };
    const i = new ot.Vector2(), s = new ot.Vector2(), r = new ot.Vector2(), o = (h) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const _ = this._domElement.getBoundingClientRect(), T = h.clientX / _.width, E = h.clientY / _.height;
        if (T < this._interactiveArea.left || T > this._interactiveArea.right || E < this._interactiveArea.top || E > this._interactiveArea.bottom)
          return;
      }
      const v = h.pointerType !== "mouse" ? null : (h.buttons & yt.LEFT) === yt.LEFT ? yt.LEFT : (h.buttons & yt.MIDDLE) === yt.MIDDLE ? yt.MIDDLE : (h.buttons & yt.RIGHT) === yt.RIGHT ? yt.RIGHT : null;
      if (v !== null) {
        const _ = this._findPointerByMouseButton(v);
        _ && this._disposePointer(_);
      }
      if ((h.buttons & yt.LEFT) === yt.LEFT && this._lockedPointer)
        return;
      const x = {
        pointerId: h.pointerId,
        clientX: h.clientX,
        clientY: h.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: v
      };
      this._activePointers.push(x), this._domElement.ownerDocument.removeEventListener("pointermove", n, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.addEventListener("pointermove", n, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", l), this._isDragging = true, p(h);
    }, n = (h) => {
      h.cancelable && h.preventDefault();
      const v = h.pointerId, x = this._lockedPointer || this._findPointerById(v);
      if (x) {
        if (x.clientX = h.clientX, x.clientY = h.clientY, x.deltaX = h.movementX, x.deltaY = h.movementY, this._state = 0, h.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (h.buttons & yt.LEFT) === yt.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (h.buttons & yt.MIDDLE) === yt.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (h.buttons & yt.RIGHT) === yt.RIGHT && (this._state = this._state | this.mouseButtons.right);
        u();
      }
    }, l = (h) => {
      const v = this._findPointerById(h.pointerId);
      if (!(v && v === this._lockedPointer)) {
        if (v && this._disposePointer(v), h.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = L.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = L.NONE;
        g();
      }
    };
    let c = -1;
    const d = (h) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === L.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const E = this._domElement.getBoundingClientRect(), A = h.clientX / E.width, z = h.clientY / E.height;
        if (A < this._interactiveArea.left || A > this._interactiveArea.right || z < this._interactiveArea.top || z > this._interactiveArea.bottom)
          return;
      }
      if (h.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === L.ROTATE || this.mouseButtons.wheel === L.TRUCK) {
        const E = performance.now();
        c - E < 1e3 && this._getClientRect(this._elementRect), c = E;
      }
      const v = Rn ? -1 : -3, x = h.deltaMode === 1 ? h.deltaY / v : h.deltaY / (v * 10), _ = this.dollyToCursor ? (h.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, T = this.dollyToCursor ? (h.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case L.ROTATE: {
          this._rotateInternal(h.deltaX, h.deltaY), this._isUserControllingRotate = true;
          break;
        }
        case L.TRUCK: {
          this._truckInternal(h.deltaX, h.deltaY, false, false), this._isUserControllingTruck = true;
          break;
        }
        case L.SCREEN_PAN: {
          this._truckInternal(h.deltaX, h.deltaY, false, true), this._isUserControllingTruck = true;
          break;
        }
        case L.OFFSET: {
          this._truckInternal(h.deltaX, h.deltaY, true, false), this._isUserControllingOffset = true;
          break;
        }
        case L.DOLLY: {
          this._dollyInternal(-x, _, T), this._isUserControllingDolly = true;
          break;
        }
        case L.ZOOM: {
          this._zoomInternal(-x, _, T), this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, f = (h) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === _Dt.ACTION.NONE) {
          const v = h instanceof PointerEvent ? h.pointerId : 0, x = this._findPointerById(v);
          x && this._disposePointer(x), this._domElement.ownerDocument.removeEventListener("pointermove", n, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l);
          return;
        }
        h.preventDefault();
      }
    }, p = (h) => {
      if (!this._enabled)
        return;
      if (ji(this._activePointers, Bt), this._getClientRect(this._elementRect), i.copy(Bt), s.copy(Bt), this._activePointers.length >= 2) {
        const x = Bt.x - this._activePointers[1].clientX, _ = Bt.y - this._activePointers[1].clientY, T = Math.sqrt(x * x + _ * _);
        r.set(0, T);
        const E = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, A = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        s.set(E, A);
      }
      if (this._state = 0, !h)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in h && h.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (h.buttons & yt.LEFT) === yt.LEFT && (this._state = this._state | this.mouseButtons.left), (h.buttons & yt.MIDDLE) === yt.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (h.buttons & yt.RIGHT) === yt.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & L.ROTATE) === L.ROTATE || (this._state & L.TOUCH_ROTATE) === L.TOUCH_ROTATE || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE || (this._state & L.TOUCH_ZOOM_ROTATE) === L.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & L.TRUCK) === L.TRUCK || (this._state & L.SCREEN_PAN) === L.SCREEN_PAN || (this._state & L.TOUCH_TRUCK) === L.TOUCH_TRUCK || (this._state & L.TOUCH_SCREEN_PAN) === L.TOUCH_SCREEN_PAN || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_DOLLY_SCREEN_PAN) === L.TOUCH_DOLLY_SCREEN_PAN || (this._state & L.TOUCH_ZOOM_TRUCK) === L.TOUCH_ZOOM_TRUCK || (this._state & L.TOUCH_ZOOM_SCREEN_PAN) === L.TOUCH_DOLLY_SCREEN_PAN) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & L.DOLLY) === L.DOLLY || (this._state & L.TOUCH_DOLLY) === L.TOUCH_DOLLY || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_DOLLY_SCREEN_PAN) === L.TOUCH_DOLLY_SCREEN_PAN || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & L.ZOOM) === L.ZOOM || (this._state & L.TOUCH_ZOOM) === L.TOUCH_ZOOM || (this._state & L.TOUCH_ZOOM_TRUCK) === L.TOUCH_ZOOM_TRUCK || (this._state & L.TOUCH_ZOOM_SCREEN_PAN) === L.TOUCH_ZOOM_SCREEN_PAN || (this._state & L.TOUCH_ZOOM_OFFSET) === L.TOUCH_ZOOM_OFFSET || (this._state & L.TOUCH_ZOOM_ROTATE) === L.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & L.OFFSET) === L.OFFSET || (this._state & L.TOUCH_OFFSET) === L.TOUCH_OFFSET || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET || (this._state & L.TOUCH_ZOOM_OFFSET) === L.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, u = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false, ji(this._activePointers, Bt);
      const v = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, x = v ? -v.deltaX : s.x - Bt.x, _ = v ? -v.deltaY : s.y - Bt.y;
      if (s.copy(Bt), ((this._state & L.ROTATE) === L.ROTATE || (this._state & L.TOUCH_ROTATE) === L.TOUCH_ROTATE || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE || (this._state & L.TOUCH_ZOOM_ROTATE) === L.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(x, _), this._isUserControllingRotate = true), (this._state & L.DOLLY) === L.DOLLY || (this._state & L.ZOOM) === L.ZOOM) {
        const T = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, E = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, A = this.dollyDragInverted ? -1 : 1;
        (this._state & L.DOLLY) === L.DOLLY ? (this._dollyInternal(A * _ * fi, T, E), this._isUserControllingDolly = true) : (this._zoomInternal(A * _ * fi, T, E), this._isUserControllingZoom = true);
      }
      if ((this._state & L.TOUCH_DOLLY) === L.TOUCH_DOLLY || (this._state & L.TOUCH_ZOOM) === L.TOUCH_ZOOM || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_ZOOM_TRUCK) === L.TOUCH_ZOOM_TRUCK || (this._state & L.TOUCH_DOLLY_SCREEN_PAN) === L.TOUCH_DOLLY_SCREEN_PAN || (this._state & L.TOUCH_ZOOM_SCREEN_PAN) === L.TOUCH_ZOOM_SCREEN_PAN || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET || (this._state & L.TOUCH_ZOOM_OFFSET) === L.TOUCH_ZOOM_OFFSET || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE || (this._state & L.TOUCH_ZOOM_ROTATE) === L.TOUCH_ZOOM_ROTATE) {
        const T = Bt.x - this._activePointers[1].clientX, E = Bt.y - this._activePointers[1].clientY, A = Math.sqrt(T * T + E * E), z = r.y - A;
        r.set(0, A);
        const D = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, I = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & L.TOUCH_DOLLY) === L.TOUCH_DOLLY || (this._state & L.TOUCH_DOLLY_ROTATE) === L.TOUCH_DOLLY_ROTATE || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_DOLLY_SCREEN_PAN) === L.TOUCH_DOLLY_SCREEN_PAN || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(z * fi, D, I), this._isUserControllingDolly = true) : (this._zoomInternal(z * fi, D, I), this._isUserControllingZoom = true);
      }
      ((this._state & L.TRUCK) === L.TRUCK || (this._state & L.TOUCH_TRUCK) === L.TOUCH_TRUCK || (this._state & L.TOUCH_DOLLY_TRUCK) === L.TOUCH_DOLLY_TRUCK || (this._state & L.TOUCH_ZOOM_TRUCK) === L.TOUCH_ZOOM_TRUCK) && (this._truckInternal(x, _, false, false), this._isUserControllingTruck = true), ((this._state & L.SCREEN_PAN) === L.SCREEN_PAN || (this._state & L.TOUCH_SCREEN_PAN) === L.TOUCH_SCREEN_PAN || (this._state & L.TOUCH_DOLLY_SCREEN_PAN) === L.TOUCH_DOLLY_SCREEN_PAN || (this._state & L.TOUCH_ZOOM_SCREEN_PAN) === L.TOUCH_ZOOM_SCREEN_PAN) && (this._truckInternal(x, _, false, true), this._isUserControllingTruck = true), ((this._state & L.OFFSET) === L.OFFSET || (this._state & L.TOUCH_OFFSET) === L.TOUCH_OFFSET || (this._state & L.TOUCH_DOLLY_OFFSET) === L.TOUCH_DOLLY_OFFSET || (this._state & L.TOUCH_ZOOM_OFFSET) === L.TOUCH_ZOOM_OFFSET) && (this._truckInternal(x, _, true, false), this._isUserControllingOffset = true), this.dispatchEvent({ type: "control" });
    }, g = () => {
      ji(this._activePointers, Bt), s.copy(Bt), this._dragNeedsUpdate = false, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = false), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", n, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", n, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", m), this._domElement.ownerDocument.addEventListener("pointerlockerror", b), this._domElement.ownerDocument.addEventListener("pointermove", n, { passive: false }), this._domElement.ownerDocument.addEventListener("pointerup", l), p());
    }, this.unlockPointer = () => {
      var h, v, x;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (h = this._domElement) === null || h === void 0 || h.ownerDocument.exitPointerLock(), (v = this._domElement) === null || v === void 0 || v.ownerDocument.removeEventListener("pointerlockchange", m), (x = this._domElement) === null || x === void 0 || x.ownerDocument.removeEventListener("pointerlockerror", b), this.cancel();
    };
    const m = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, b = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (h) => {
      this._domElement = h, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", o), this._domElement.addEventListener("pointercancel", l), this._domElement.addEventListener("wheel", d, { passive: false }), this._domElement.addEventListener("contextmenu", f);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", o), this._domElement.removeEventListener("pointercancel", l), this._domElement.removeEventListener("wheel", d, { passive: false }), this._domElement.removeEventListener("contextmenu", f), this._domElement.ownerDocument.removeEventListener("pointermove", n, { passive: false }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.removeEventListener("pointerlockchange", m), this._domElement.ownerDocument.removeEventListener("pointerlockerror", b));
    }, this.cancel = () => {
      this._state !== L.NONE && (this._state = L.NONE, this._activePointers.length = 0, g());
    }, e && this.connect(e), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(t) {
    this._camera = t, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = t, this._domElement && (t ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(t) {
    this._spherical.radius === t && this._sphericalEnd.radius === t || (this._spherical.radius = t, this._sphericalEnd.radius = t, this._needsUpdate = true);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(t) {
    this._spherical.theta === t && this._sphericalEnd.theta === t || (this._spherical.theta = t, this._sphericalEnd.theta = t, this._needsUpdate = true);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(t) {
    this._spherical.phi === t && this._sphericalEnd.phi === t || (this._spherical.phi = t, this._sphericalEnd.phi = t, this._needsUpdate = true);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(t) {
    this._boundaryEnclosesCamera = t, this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(t) {
    this._interactiveArea.width = Yt(t.width, 0, 1), this._interactiveArea.height = Yt(t.height, 0, 1), this._interactiveArea.x = Yt(t.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Yt(t.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(t, e) {
    super.addEventListener(t, e);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(t, e) {
    super.removeEventListener(t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(t, e, i = false) {
    return this.rotateTo(this._sphericalEnd.theta + t, this._sphericalEnd.phi + e, i);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(t, e = false) {
    return this.rotateTo(t, this._sphericalEnd.phi, e);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(t, e = false) {
    return this.rotateTo(this._sphericalEnd.theta, t, e);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(t, e, i = false) {
    this._isUserControllingRotate = false;
    const s = Yt(t, this.minAzimuthAngle, this.maxAzimuthAngle), r = Yt(e, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = s, this._sphericalEnd.phi = r, this._sphericalEnd.makeSafe(), this._needsUpdate = true, i || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const o = !i || dt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && dt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(t, e = false) {
    return this.dollyTo(this._sphericalEnd.radius - t, e);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(t, e = false) {
    return this._isUserControllingDolly = false, this._lastDollyDirection = we.NONE, this._changedDolly = 0, this._dollyToNoClamp(Yt(t, this.minDistance, this.maxDistance), e);
  }
  _dollyToNoClamp(t, e = false) {
    const i = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const o = this._collisionTest(), n = dt(o, this._spherical.radius);
      if (!(i > t) && n)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(t, o);
    } else
      this._sphericalEnd.radius = t;
    this._needsUpdate = true, e || (this._spherical.radius = this._sphericalEnd.radius);
    const r = !e || dt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(t, e = false) {
    this._targetEnd.add(this._getCameraDirection(je).multiplyScalar(t)), e || this._target.copy(this._targetEnd);
    const i = !e || dt(this._target.x, this._targetEnd.x, this.restThreshold) && dt(this._target.y, this._targetEnd.y, this.restThreshold) && dt(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(t, e = false) {
    return this.zoomTo(this._zoomEnd + t, e);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(t, e = false) {
    this._isUserControllingZoom = false, this._zoomEnd = Yt(t, this.minZoom, this.maxZoom), this._needsUpdate = true, e || (this._zoom = this._zoomEnd);
    const i = !e || dt(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(i);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(t, e, i = false) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(t, e, i);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(t, e, i = false) {
    this._camera.updateMatrix(), te.setFromMatrixColumn(this._camera.matrix, 0), ee.setFromMatrixColumn(this._camera.matrix, 1), te.multiplyScalar(t), ee.multiplyScalar(-e);
    const s = lt.copy(te).add(ee), r = ut.copy(this._targetEnd).add(s);
    return this.moveTo(r.x, r.y, r.z, i);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(t, e = false) {
    lt.setFromMatrixColumn(this._camera.matrix, 0), lt.crossVectors(this._camera.up, lt), lt.multiplyScalar(t);
    const i = ut.copy(this._targetEnd).add(lt);
    return this.moveTo(i.x, i.y, i.z, e);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(t, e = false) {
    return lt.copy(this._camera.up).multiplyScalar(t), this.moveTo(this._targetEnd.x + lt.x, this._targetEnd.y + lt.y, this._targetEnd.z + lt.z, e);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(t, e, i, s = false) {
    this._isUserControllingTruck = false;
    const r = lt.set(t, e, i).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, r, this.boundaryFriction), this._needsUpdate = true, s || this._target.copy(this._targetEnd);
    const o = !s || dt(this._target.x, this._targetEnd.x, this.restThreshold) && dt(this._target.y, this._targetEnd.y, this.restThreshold) && dt(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(t, e, i, s = false) {
    const n = lt.set(t, e, i).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(n.x, n.y, n.z, s);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(t, e, { cover: i = false, paddingLeft: s = 0, paddingRight: r = 0, paddingBottom: o = 0, paddingTop: n = 0 } = {}) {
    const l = [], c = t.isBox3 ? _e.copy(t) : _e.setFromObject(t);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const d = Us(this._sphericalEnd.theta, Fs), f = Us(this._sphericalEnd.phi, Fs);
    l.push(this.rotateTo(d, f, e));
    const p = lt.setFromSpherical(this._sphericalEnd).normalize(), u = Ys.setFromUnitVectors(p, Ki), g = dt(Math.abs(p.y), 1);
    g && u.multiply(qi.setFromAxisAngle(di, d)), u.multiply(this._yAxisUpSpaceInverse);
    const m = Ws.makeEmpty();
    ut.copy(c.min).applyQuaternion(u), m.expandByPoint(ut), ut.copy(c.min).setX(c.max.x).applyQuaternion(u), m.expandByPoint(ut), ut.copy(c.min).setY(c.max.y).applyQuaternion(u), m.expandByPoint(ut), ut.copy(c.max).setZ(c.min.z).applyQuaternion(u), m.expandByPoint(ut), ut.copy(c.min).setZ(c.max.z).applyQuaternion(u), m.expandByPoint(ut), ut.copy(c.max).setY(c.min.y).applyQuaternion(u), m.expandByPoint(ut), ut.copy(c.max).setX(c.min.x).applyQuaternion(u), m.expandByPoint(ut), ut.copy(c.max).applyQuaternion(u), m.expandByPoint(ut), m.min.x -= s, m.min.y -= o, m.max.x += r, m.max.y += n, u.setFromUnitVectors(Ki, p), g && u.premultiply(qi.invert()), u.premultiply(this._yAxisUpSpace);
    const b = m.getSize(lt), h = m.getCenter(ut).applyQuaternion(u);
    if (me(this._camera)) {
      const v = this.getDistanceToFitBox(b.x, b.y, b.z, i);
      l.push(this.moveTo(h.x, h.y, h.z, e)), l.push(this.dollyTo(v, e)), l.push(this.setFocalOffset(0, 0, 0, e));
    } else if (ce(this._camera)) {
      const v = this._camera, x = v.right - v.left, _ = v.top - v.bottom, T = i ? Math.max(x / b.x, _ / b.y) : Math.min(x / b.x, _ / b.y);
      l.push(this.moveTo(h.x, h.y, h.z, e)), l.push(this.zoomTo(T, e)), l.push(this.setFocalOffset(0, 0, 0, e));
    }
    return Promise.all(l);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(t, e) {
    const i = [], r = "isObject3D" in t ? _Dt.createBoundingSphere(t, Xi) : Xi.copy(t);
    if (i.push(this.moveTo(r.center.x, r.center.y, r.center.z, e)), me(this._camera)) {
      const o = this.getDistanceToFitSphere(r.radius);
      i.push(this.dollyTo(o, e));
    } else if (ce(this._camera)) {
      const o = this._camera.right - this._camera.left, n = this._camera.top - this._camera.bottom, l = 2 * r.radius, c = Math.min(o / l, n / l);
      i.push(this.zoomTo(c, e));
    }
    return i.push(this.setFocalOffset(0, 0, 0, e)), Promise.all(i);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(t, e, i, s, r, o, n = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = we.NONE, this._changedDolly = 0;
    const l = ut.set(s, r, o), c = lt.set(t, e, i);
    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = true, n || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const d = !n || dt(this._target.x, this._targetEnd.x, this.restThreshold) && dt(this._target.y, this._targetEnd.y, this.restThreshold) && dt(this._target.z, this._targetEnd.z, this.restThreshold) && dt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && dt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && dt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(d);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(t, e, i, s, r, o, n, l, c, d, f, p, u, g = false) {
    this._isUserControllingRotate = false, this._isUserControllingDolly = false, this._isUserControllingTruck = false, this._lastDollyDirection = we.NONE, this._changedDolly = 0;
    const m = lt.set(s, r, o), b = ut.set(t, e, i);
    Ft.setFromVector3(b.sub(m).applyQuaternion(this._yAxisUpSpace));
    const h = xe.set(d, f, p), v = ut.set(n, l, c);
    Qe.setFromVector3(v.sub(h).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(m.lerp(h, u));
    const x = Qe.theta - Ft.theta, _ = Qe.phi - Ft.phi, T = Qe.radius - Ft.radius;
    this._sphericalEnd.set(Ft.radius + T * u, Ft.phi + _ * u, Ft.theta + x * u), this.normalizeRotations(), this._needsUpdate = true, g || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const E = !g || dt(this._target.x, this._targetEnd.x, this.restThreshold) && dt(this._target.y, this._targetEnd.y, this.restThreshold) && dt(this._target.z, this._targetEnd.z, this.restThreshold) && dt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && dt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && dt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(E);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(t, e, i, s = false) {
    return this.setLookAt(t, e, i, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(t, e, i, s = false) {
    const r = this.getPosition(lt), o = this.setLookAt(r.x, r.y, r.z, t, e, i, s);
    return this._sphericalEnd.phi = Yt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), o;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(t, e, i, s = false) {
    this._isUserControllingOffset = false, this._focalOffsetEnd.set(t, e, i), this._needsUpdate = true, s || this._focalOffset.copy(this._focalOffsetEnd);
    const r = !s || dt(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && dt(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && dt(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(t, e, i) {
    this._camera.updateMatrixWorld(), te.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), ee.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), ge.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const s = lt.set(t, e, i), r = s.distanceTo(this._camera.position), o = s.sub(this._camera.position);
    te.multiplyScalar(o.x), ee.multiplyScalar(o.y), ge.multiplyScalar(o.z), lt.copy(te).add(ee).add(ge), lt.z = lt.z + r, this.dollyTo(r, false), this.setFocalOffset(-lt.x, lt.y, -lt.z, false), this.moveTo(t, e, i, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(t) {
    if (!t) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = true;
      return;
    }
    this._boundary.copy(t), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(t, e, i, s) {
    if (t === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new ot.Vector4(), typeof t == "number" ? this._viewport.set(t, e, i, s) : this._viewport.copy(t);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(t, e, i, s = false) {
    if (Qi(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const r = t / e, o = this._camera.getEffectiveFOV() * Ze, n = this._camera.aspect;
    return ((s ? r > n : r < n) ? e : t / n) * 0.5 / Math.tan(o * 0.5) + i * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(t) {
    if (Qi(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const e = this._camera.getEffectiveFOV() * Ze, i = Math.atan(Math.tan(e * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? e : i;
    return t / Math.sin(s * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(t, e = true) {
    return (t && t.isVector3 ? t : new ot.Vector3()).copy(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(t, e = true) {
    return (t && t.isVector3 ? t : new ot.Vector3()).setFromSpherical(e ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(e ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(t, e = true) {
    return (t || new ot.Spherical()).copy(e ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(t, e = true) {
    return (t && t.isVector3 ? t : new ot.Vector3()).copy(e ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % be, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += be), this._spherical.theta += be * Math.round((this._sphericalEnd.theta - this._spherical.theta) / be);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(t = false) {
    if (!dt(this._camera.up.x, this._cameraUp0.x) || !dt(this._camera.up.y, this._cameraUp0.y) || !dt(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const i = this.getPosition(lt);
      this.updateCameraUp(), this.setPosition(i.x, i.y, i.z);
    }
    const e = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, t),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, t),
      this.zoomTo(this._zoom0, t)
    ];
    return Promise.all(e);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, di), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const t = lt.subVectors(this._target, this._camera.position).normalize(), e = ut.crossVectors(t, this._camera.up);
    this._camera.up.crossVectors(e, t).normalize(), this._camera.updateMatrixWorld();
    const i = this.getPosition(lt);
    this.updateCameraUp(), this.setPosition(i.x, i.y, i.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(t) {
    const e = this._sphericalEnd.theta - this._spherical.theta, i = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, r = Hs.subVectors(this._targetEnd, this._target), o = Zs.subVectors(this._focalOffsetEnd, this._focalOffset), n = this._zoomEnd - this._zoom;
    if (gt(e))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const f = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = ui(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, f, 1 / 0, t), this._needsUpdate = true;
    }
    if (gt(i))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const f = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = ui(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, f, 1 / 0, t), this._needsUpdate = true;
    }
    if (gt(s))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const f = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = ui(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, f, this.maxSpeed, t), this._needsUpdate = true;
    }
    if (gt(r.x) && gt(r.y) && gt(r.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const f = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      Ns(this._target, this._targetEnd, this._targetVelocity, f, this.maxSpeed, t, this._target), this._needsUpdate = true;
    }
    if (gt(o.x) && gt(o.y) && gt(o.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const f = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      Ns(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, f, this.maxSpeed, t, this._focalOffset), this._needsUpdate = true;
    }
    if (gt(n))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const f = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = ui(this._zoom, this._zoomEnd, this._zoomVelocity, f, 1 / 0, t);
    }
    if (this.dollyToCursor) {
      if (me(this._camera) && this._changedDolly !== 0) {
        const f = this._spherical.radius - this._lastDistance, p = this._camera, u = this._getCameraDirection(je), g = lt.copy(u).cross(p.up).normalize();
        g.lengthSq() === 0 && (g.x = 1);
        const m = ut.crossVectors(g, u), b = this._sphericalEnd.radius * Math.tan(p.getEffectiveFOV() * Ze * 0.5), v = (this._sphericalEnd.radius - f - this._sphericalEnd.radius) / this._sphericalEnd.radius, x = xe.copy(this._targetEnd).add(g.multiplyScalar(this._dollyControlCoord.x * b * p.aspect)).add(m.multiplyScalar(this._dollyControlCoord.y * b)), _ = lt.copy(this._targetEnd).lerp(x, v), T = this._lastDollyDirection === we.IN && this._spherical.radius <= this.minDistance, E = this._lastDollyDirection === we.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (T || E)) {
          this._sphericalEnd.radius -= f, this._spherical.radius -= f;
          const z = ut.copy(u).multiplyScalar(-f);
          _.add(z);
        }
        this._boundary.clampPoint(_, _);
        const A = ut.subVectors(_, this._targetEnd);
        this._targetEnd.copy(_), this._target.add(A), this._changedDolly -= f, gt(this._changedDolly) && (this._changedDolly = 0);
      } else if (ce(this._camera) && this._changedZoom !== 0) {
        const f = this._zoom - this._lastZoom, p = this._camera, u = lt.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (p.near + p.far) / (p.near - p.far)).unproject(p), g = ut.set(0, 0, -1).applyQuaternion(p.quaternion), m = xe.copy(u).add(g.multiplyScalar(-u.dot(p.up))), h = -(this._zoom - f - this._zoom) / this._zoom, v = this._getCameraDirection(je), x = this._targetEnd.dot(v), _ = lt.copy(this._targetEnd).lerp(m, h), T = _.dot(v), E = v.multiplyScalar(T - x);
        _.sub(E), this._boundary.clampPoint(_, _);
        const A = ut.subVectors(_, this._targetEnd);
        this._targetEnd.copy(_), this._target.add(A), this._changedZoom -= f, gt(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = true), this._dragNeedsUpdate = true;
    const l = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!gt(this._focalOffset.x) || !gt(this._focalOffset.y) || !gt(this._focalOffset.z)) && (te.setFromMatrixColumn(this._camera.matrix, 0), ee.setFromMatrixColumn(this._camera.matrix, 1), ge.setFromMatrixColumn(this._camera.matrix, 2), te.multiplyScalar(this._focalOffset.x), ee.multiplyScalar(-this._focalOffset.y), ge.multiplyScalar(this._focalOffset.z), lt.copy(te).add(ee).add(ge), this._camera.position.add(lt), this._camera.updateMatrixWorld()), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), lt.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const d = this._needsUpdate;
    return d && !this._updatedLastTime ? (this._hasRested = false, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : d ? (this.dispatchEvent({ type: "update" }), gt(e, this.restThreshold) && gt(i, this.restThreshold) && gt(s, this.restThreshold) && gt(r.x, this.restThreshold) && gt(r.y, this.restThreshold) && gt(r.z, this.restThreshold) && gt(o.x, this.restThreshold) && gt(o.y, this.restThreshold) && gt(o.z, this.restThreshold) && gt(n, this.restThreshold) && !this._hasRested && (this._hasRested = true, this.dispatchEvent({ type: "rest" }))) : !d && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = d, this._needsUpdate = false, d;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: We(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: We(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: We(this.maxPolarAngle),
      minAzimuthAngle: We(this.minAzimuthAngle),
      maxAzimuthAngle: We(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      target: this._targetEnd.toArray(),
      position: lt.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(t, e = false) {
    const i = JSON.parse(t);
    this.enabled = i.enabled, this.minDistance = i.minDistance, this.maxDistance = Ye(i.maxDistance), this.minZoom = i.minZoom, this.maxZoom = Ye(i.maxZoom), this.minPolarAngle = i.minPolarAngle, this.maxPolarAngle = Ye(i.maxPolarAngle), this.minAzimuthAngle = Ye(i.minAzimuthAngle), this.maxAzimuthAngle = Ye(i.maxAzimuthAngle), this.smoothTime = i.smoothTime, this.draggingSmoothTime = i.draggingSmoothTime, this.dollySpeed = i.dollySpeed, this.truckSpeed = i.truckSpeed, this.dollyToCursor = i.dollyToCursor, this._target0.fromArray(i.target0), this._position0.fromArray(i.position0), this._zoom0 = i.zoom0, this._focalOffset0.fromArray(i.focalOffset0), this.moveTo(i.target[0], i.target[1], i.target[2], e), Ft.setFromVector3(lt.fromArray(i.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(Ft.theta, Ft.phi, e), this.dollyTo(Ft.radius, e), this.zoomTo(i.zoom, e), this.setFocalOffset(i.focalOffset[0], i.focalOffset[1], i.focalOffset[2], e), this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(t) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    t.setAttribute("data-camera-controls-version", Mn), this._addAllEventListeners(t), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(t) {
    return t.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(t) {
    return this._getTargetDirection(t).negate();
  }
  _findPointerById(t) {
    return this._activePointers.find((e) => e.pointerId === t);
  }
  _findPointerByMouseButton(t) {
    return this._activePointers.find((e) => e.mouseButton === t);
  }
  _disposePointer(t) {
    this._activePointers.splice(this._activePointers.indexOf(t), 1);
  }
  _encloseToBoundary(t, e, i) {
    const s = e.lengthSq();
    if (s === 0)
      return t;
    const r = ut.copy(e).add(t), n = this._boundary.clampPoint(r, xe).sub(r), l = n.lengthSq();
    if (l === 0)
      return t.add(e);
    if (l === s)
      return t;
    if (i === 0)
      return t.add(e).add(n);
    {
      const c = 1 + i * l / e.dot(n);
      return t.add(ut.copy(e).multiplyScalar(c)).add(n.multiplyScalar(1 - i));
    }
  }
  _updateNearPlaneCorners() {
    if (me(this._camera)) {
      const t = this._camera, e = t.near, i = t.getEffectiveFOV() * Ze, s = Math.tan(i * 0.5) * e, r = s * t.aspect;
      this._nearPlaneCorners[0].set(-r, -s, 0), this._nearPlaneCorners[1].set(r, -s, 0), this._nearPlaneCorners[2].set(r, s, 0), this._nearPlaneCorners[3].set(-r, s, 0);
    } else if (ce(this._camera)) {
      const t = this._camera, e = 1 / t.zoom, i = t.left * e, s = t.right * e, r = t.top * e, o = t.bottom * e;
      this._nearPlaneCorners[0].set(i, r, 0), this._nearPlaneCorners[1].set(s, r, 0), this._nearPlaneCorners[2].set(s, o, 0), this._nearPlaneCorners[3].set(i, o, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let t = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Qi(this._camera, "_collisionTest"))
      return t;
    const i = this._getTargetDirection(je);
    Ji.lookAt(Vs, i, this._camera.up);
    for (let s = 0; s < 4; s++) {
      const r = ut.copy(this._nearPlaneCorners[s]);
      r.applyMatrix4(Ji);
      const o = xe.addVectors(this._target, r);
      pi.set(o, i), pi.far = this._spherical.radius + 1;
      const n = pi.intersectObjects(this.colliderMeshes);
      n.length !== 0 && n[0].distance < t && (t = n[0].distance);
    }
    return t;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(t) {
    if (!this._domElement)
      return;
    const e = this._domElement.getBoundingClientRect();
    return t.x = e.left, t.y = e.top, this._viewport ? (t.x += this._viewport.x, t.y += e.height - this._viewport.w - this._viewport.y, t.width = this._viewport.z, t.height = this._viewport.w) : (t.width = e.width, t.height = e.height), t;
  }
  _createOnRestPromise(t) {
    return t ? Promise.resolve() : (this._hasRested = false, this.dispatchEvent({ type: "transitionstart" }), new Promise((e) => {
      const i = () => {
        this.removeEventListener("rest", i), e();
      };
      this.addEventListener("rest", i);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(t) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(t) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(t) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(t, e = new ot.Sphere()) {
    const i = e, s = i.center;
    _e.makeEmpty(), t.traverseVisible((o) => {
      o.isMesh && _e.expandByObject(o);
    }), _e.getCenter(s);
    let r = 0;
    return t.traverseVisible((o) => {
      if (!o.isMesh)
        return;
      const n = o;
      if (!n.geometry)
        return;
      const l = n.geometry.clone();
      l.applyMatrix4(n.matrixWorld);
      const d = l.attributes.position;
      for (let f = 0, p = d.count; f < p; f++)
        lt.fromBufferAttribute(d, f), r = Math.max(r, s.distanceToSquared(lt));
    }), i.radius = Math.sqrt(r), i;
  }
};
var ai = class _ai extends Dn {
  constructor(t) {
    super(t), P(this, "onBeforeUpdate", new it()), P(this, "onAfterUpdate", new it()), P(this, "onAspectUpdated", new it()), P(this, "onDisposed", new it()), P(this, "three"), P(this, "_allControls", /* @__PURE__ */ new Map()), P(this, "updateAspect", () => {
      var e;
      if (!(!this.currentWorld || !this.currentWorld.renderer)) {
        if (this.three instanceof OrthographicCamera) {
          this.onAspectUpdated.trigger();
          return;
        }
        if ((e = this.currentWorld.renderer) != null && e.isResizeable()) {
          const i = this.currentWorld.renderer.getSize();
          this.three.aspect = i.width / i.height, this.three.updateProjectionMatrix(), this.onAspectUpdated.trigger();
        }
      }
    }), this.three = this.setupCamera(), this.setupEvents(true), this.onWorldChanged.add(({ action: e, world: i }) => {
      if (e === "added") {
        const s = this.newCameraControls();
        this._allControls.set(i.uuid, s);
      }
      if (e === "removed") {
        const s = this._allControls.get(i.uuid);
        s && (s.dispose(), this._allControls.delete(i.uuid));
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    const t = this._allControls.get(this.currentWorld.uuid);
    if (!t)
      throw new Error("Controls not found!");
    return t;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    return this.currentWorld === null ? false : this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(t) {
    this.currentWorld !== null && (this.controls.enabled = t);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onAspectUpdated.reset(), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.three.removeFromParent(), this.onDisposed.trigger(), this.onDisposed.reset();
    for (const [t, e] of this._allControls)
      e.dispose();
  }
  /** {@link Updateable.update} */
  update(t) {
    this.enabled && (this.onBeforeUpdate.trigger(this), this.controls.update(t), this.onAfterUpdate.trigger(this));
  }
  setupCamera() {
    const t = window.innerWidth / window.innerHeight, e = new PerspectiveCamera(60, t, 1, 1e3);
    return e.position.set(50, 50, 50), e.lookAt(new Vector3(0, 0, 0)), e;
  }
  newCameraControls() {
    if (!this.currentWorld)
      throw new Error("This camera needs a world to work!");
    if (!this.currentWorld.renderer)
      throw new Error("This camera needs a renderer to work!");
    Dt.install({ THREE: _ai.getSubsetOfThree() });
    const { domElement: t } = this.currentWorld.renderer.three, e = new Dt(this.three, t);
    return e.smoothTime = 0.2, e.dollyToCursor = true, e.infinityDolly = true, e.minDistance = 6, e;
  }
  setupEvents(t) {
    t ? window.addEventListener("resize", this.updateAspect) : window.removeEventListener("resize", this.updateAspect);
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};
var Rr = class Lr extends Zt {
  constructor(t) {
    super(t), P(this, "onAfterUpdate", new it()), P(this, "onBeforeUpdate", new it()), P(this, "onDisposed", new it()), P(this, "list", new Re()), P(this, "enabled", true), t.add(Lr.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const t = new kn(this.components), e = t.uuid;
    if (this.list.has(e))
      throw new Error("There is already a world with this name!");
    return this.list.set(e, t), t;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   */
  delete(t) {
    if (!this.list.has(t.uuid))
      throw new Error("The provided world is not found in the list!");
    this.list.delete(t.uuid), t.dispose();
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   */
  dispose() {
    this.enabled = false;
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(t) {
    if (this.enabled)
      for (const [e, i] of this.list)
        i.update(t);
  }
};
P(Rr, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
var Ln = Rr;
var Fn = class extends Ss {
  constructor() {
    super(...arguments), P(this, "_config", {
      visible: {
        value: true,
        type: "Boolean"
      },
      color: {
        value: new Color(),
        type: "Color"
      },
      primarySize: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1e3
      },
      secondarySize: {
        type: "Number",
        interpolable: true,
        value: 10,
        min: 0,
        max: 1e3
      },
      distance: {
        type: "Number",
        interpolable: true,
        value: 500,
        min: 0,
        max: 500
      }
    });
  }
  /**
   * Whether the grid is visible or not.
   */
  get visible() {
    return this._config.visible.value;
  }
  /**
   * Whether the grid is visible or not.
   */
  set visible(t) {
    this._config.visible.value = t, this._component.visible = t;
  }
  /**
   * The color of the grid lines.
   */
  get color() {
    return this._config.color.value;
  }
  /**
   * The color of the grid lines.
   */
  set color(t) {
    this._config.color.value = t, this._component.material.uniforms.uColor.value = t, this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the primary grid lines.
   */
  get primarySize() {
    return this._config.primarySize.value;
  }
  /**
   * The size of the primary grid lines.
   */
  set primarySize(t) {
    this._config.primarySize.value = t, this._component.material.uniforms.uSize1.value = t, this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the secondary grid lines.
   */
  get secondarySize() {
    return this._config.secondarySize.value;
  }
  /**
   * The size of the secondary grid lines.
   */
  set secondarySize(t) {
    this._config.secondarySize.value = t, this._component.material.uniforms.uSize2.value = t, this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  get distance() {
    return this._config.distance.value;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  set distance(t) {
    this._config.distance.value = t, this._component.material.uniforms.uDistance.value = t, this._component.material.uniformsNeedUpdate = true;
  }
};
var Un = class {
  constructor(t, e) {
    P(this, "onDisposed", new it()), P(this, "onSetup", new it()), P(this, "isSetup", false), P(this, "world"), P(this, "components"), P(this, "config"), P(this, "_defaultConfig", {
      visible: true,
      color: new Color(12303291),
      primarySize: 1,
      secondarySize: 10,
      distance: 500
    }), P(this, "three"), P(this, "_fade", 3), P(this, "updateZoom", () => {
      this.world.camera instanceof ai && (this.material.uniforms.uZoom.value = this.world.camera.three.zoom);
    }), this.world = e;
    const { color: i, primarySize: s, secondarySize: r, distance: o } = this._defaultConfig;
    this.components = t, this.config = new Fn(this, this.components, "Grid");
    const n = new PlaneGeometry(2, 2, 1, 1), l = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: s
        },
        uSize2: {
          value: r
        },
        uColor: {
          value: i
        },
        uDistance: {
          value: o
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this.three = new Mesh(n, l), this.three.frustumCulled = false, e.scene.three.add(this.three), this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(t) {
    t ? this.world.scene.three.add(this.three) : this.three.removeFromParent();
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(t) {
    this._fade = t ? 3 : 0, this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Configurable.setup} */
  setup(t) {
    const e = { ...this._defaultConfig, ...t };
    this.config.visible = true, this.config.color = e.color, this.config.primarySize = e.primarySize, this.config.secondarySize = e.secondarySize, this.config.distance = e.distance, this.isSetup = true, this.onSetup.trigger();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.components.get(Ir).list.delete(this.config.uuid), this.components.get(zr).destroy(this.three), this.onDisposed.trigger(), this.onDisposed.reset(), this.world = null, this.components = null;
  }
  setupEvents(t) {
    if (this.world.isDisposing || !(this.world.camera instanceof ai))
      return;
    const e = this.world.camera.controls;
    t ? e.addEventListener("update", this.updateZoom) : e.removeEventListener("update", this.updateZoom);
  }
};
var Nn = class Fr extends Zt {
  constructor(t) {
    super(t), P(this, "list", /* @__PURE__ */ new Map()), P(this, "onDisposed", new it()), P(this, "enabled", true), t.add(Fr.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(t) {
    if (this.list.has(t.uuid))
      throw new Error("This world already has a grid!");
    const e = new Un(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
P(Nn, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
var Ur = 0;
var Vn = 1;
var Hn = 2;
var js = 2;
var $i = 1.25;
var Qs = 1;
var ki = 6 * 4 + 4 + 4;
var Ui = 65535;
var Zn = Math.pow(2, -24);
var ts = Symbol("SKIP_GENERATION");
function Wn(a) {
  return a.index ? a.index.count : a.attributes.position.count;
}
function Fe(a) {
  return Wn(a) / 3;
}
function Yn(a, t = ArrayBuffer) {
  return a > 65535 ? new Uint32Array(new t(4 * a)) : new Uint16Array(new t(2 * a));
}
function jn(a, t) {
  if (!a.index) {
    const e = a.attributes.position.count, i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, s = Yn(e, i);
    a.setIndex(new BufferAttribute(s, 1));
    for (let r = 0; r < e; r++)
      s[r] = r;
  }
}
function Nr(a) {
  const t = Fe(a), e = a.drawRange, i = e.start / 3, s = (e.start + e.count) / 3, r = Math.max(0, i), o = Math.min(t, s) - r;
  return [{
    offset: Math.floor(r),
    count: Math.floor(o)
  }];
}
function Vr(a) {
  if (!a.groups || !a.groups.length)
    return Nr(a);
  const t = [], e = /* @__PURE__ */ new Set(), i = a.drawRange, s = i.start / 3, r = (i.start + i.count) / 3;
  for (const n of a.groups) {
    const l = n.start / 3, c = (n.start + n.count) / 3;
    e.add(Math.max(s, l)), e.add(Math.min(r, c));
  }
  const o = Array.from(e.values()).sort((n, l) => n - l);
  for (let n = 0; n < o.length - 1; n++) {
    const l = o[n], c = o[n + 1];
    t.push({
      offset: Math.floor(l),
      count: Math.floor(c - l)
    });
  }
  return t;
}
function Qn(a) {
  if (a.groups.length === 0)
    return false;
  const t = Fe(a), e = Vr(a).sort((r, o) => r.offset - o.offset), i = e[e.length - 1];
  i.count = Math.min(t - i.offset, i.count);
  let s = 0;
  return e.forEach(({ count: r }) => s += r), t !== s;
}
function wt(a, t, e) {
  return e.min.x = t[a], e.min.y = t[a + 1], e.min.z = t[a + 2], e.max.x = t[a + 3], e.max.y = t[a + 4], e.max.z = t[a + 5], e;
}
function Gn(a) {
  a[0] = a[1] = a[2] = 1 / 0, a[3] = a[4] = a[5] = -1 / 0;
}
function Gs(a) {
  let t = -1, e = -1 / 0;
  for (let i = 0; i < 3; i++) {
    const s = a[i + 3] - a[i];
    s > e && (e = s, t = i);
  }
  return t;
}
function Ks(a, t) {
  t.set(a);
}
function Xs(a, t, e) {
  let i, s;
  for (let r = 0; r < 3; r++) {
    const o = r + 3;
    i = a[r], s = t[r], e[r] = i < s ? i : s, i = a[o], s = t[o], e[o] = i > s ? i : s;
  }
}
function mi(a, t, e) {
  for (let i = 0; i < 3; i++) {
    const s = t[a + 2 * i], r = t[a + 2 * i + 1], o = s - r, n = s + r;
    o < e[i] && (e[i] = o), n > e[i + 3] && (e[i + 3] = n);
  }
}
function Ge(a) {
  const t = a[3] - a[0], e = a[4] - a[1], i = a[5] - a[2];
  return 2 * (t * e + e * i + i * t);
}
function es(a, t, e, i, s = null) {
  let r = 1 / 0, o = 1 / 0, n = 1 / 0, l = -1 / 0, c = -1 / 0, d = -1 / 0, f = 1 / 0, p = 1 / 0, u = 1 / 0, g = -1 / 0, m = -1 / 0, b = -1 / 0;
  const h = s !== null;
  for (let v = t * 6, x = (t + e) * 6; v < x; v += 6) {
    const _ = a[v + 0], T = a[v + 1], E = _ - T, A = _ + T;
    E < r && (r = E), A > l && (l = A), h && _ < f && (f = _), h && _ > g && (g = _);
    const z = a[v + 2], D = a[v + 3], I = z - D, U = z + D;
    I < o && (o = I), U > c && (c = U), h && z < p && (p = z), h && z > m && (m = z);
    const C = a[v + 4], k = a[v + 5], w = C - k, M = C + k;
    w < n && (n = w), M > d && (d = M), h && C < u && (u = C), h && C > b && (b = C);
  }
  i[0] = r, i[1] = o, i[2] = n, i[3] = l, i[4] = c, i[5] = d, h && (s[0] = f, s[1] = p, s[2] = u, s[3] = g, s[4] = m, s[5] = b);
}
function Kn(a, t, e, i) {
  let s = 1 / 0, r = 1 / 0, o = 1 / 0, n = -1 / 0, l = -1 / 0, c = -1 / 0;
  for (let d = t * 6, f = (t + e) * 6; d < f; d += 6) {
    const p = a[d + 0];
    p < s && (s = p), p > n && (n = p);
    const u = a[d + 2];
    u < r && (r = u), u > l && (l = u);
    const g = a[d + 4];
    g < o && (o = g), g > c && (c = g);
  }
  i[0] = s, i[1] = r, i[2] = o, i[3] = n, i[4] = l, i[5] = c;
}
function Xn(a, t) {
  Gn(t);
  const e = a.attributes.position, i = a.index ? a.index.array : null, s = Fe(a), r = new Float32Array(s * 6), o = e.normalized, n = e.array, l = e.offset || 0;
  let c = 3;
  e.isInterleavedBufferAttribute && (c = e.data.stride);
  const d = ["getX", "getY", "getZ"];
  for (let f = 0; f < s; f++) {
    const p = f * 3, u = f * 6;
    let g = p + 0, m = p + 1, b = p + 2;
    i && (g = i[g], m = i[m], b = i[b]), o || (g = g * c + l, m = m * c + l, b = b * c + l);
    for (let h = 0; h < 3; h++) {
      let v, x, _;
      o ? (v = e[d[h]](g), x = e[d[h]](m), _ = e[d[h]](b)) : (v = n[g + h], x = n[m + h], _ = n[b + h]);
      let T = v;
      x < T && (T = x), _ < T && (T = _);
      let E = v;
      x > E && (E = x), _ > E && (E = _);
      const A = (E - T) / 2, z = h * 2;
      r[u + z + 0] = T + A, r[u + z + 1] = A + (Math.abs(T) + A) * Zn, T < t[h] && (t[h] = T), E > t[h + 3] && (t[h + 3] = E);
    }
  }
  return r;
}
var re = 32;
var qn = (a, t) => a.candidate - t.candidate;
var le = new Array(re).fill().map(() => ({
  count: 0,
  bounds: new Float32Array(6),
  rightCacheBounds: new Float32Array(6),
  leftCacheBounds: new Float32Array(6),
  candidate: 0
}));
var gi = new Float32Array(6);
function Jn(a, t, e, i, s, r) {
  let o = -1, n = 0;
  if (r === Ur)
    o = Gs(t), o !== -1 && (n = (t[o] + t[o + 3]) / 2);
  else if (r === Vn)
    o = Gs(a), o !== -1 && (n = $n(e, i, s, o));
  else if (r === Hn) {
    const l = Ge(a);
    let c = $i * s;
    const d = i * 6, f = (i + s) * 6;
    for (let p = 0; p < 3; p++) {
      const u = t[p], b = (t[p + 3] - u) / re;
      if (s < re / 4) {
        const h = [...le];
        h.length = s;
        let v = 0;
        for (let _ = d; _ < f; _ += 6, v++) {
          const T = h[v];
          T.candidate = e[_ + 2 * p], T.count = 0;
          const {
            bounds: E,
            leftCacheBounds: A,
            rightCacheBounds: z
          } = T;
          for (let D = 0; D < 3; D++)
            z[D] = 1 / 0, z[D + 3] = -1 / 0, A[D] = 1 / 0, A[D + 3] = -1 / 0, E[D] = 1 / 0, E[D + 3] = -1 / 0;
          mi(_, e, E);
        }
        h.sort(qn);
        let x = s;
        for (let _ = 0; _ < x; _++) {
          const T = h[_];
          for (; _ + 1 < x && h[_ + 1].candidate === T.candidate; )
            h.splice(_ + 1, 1), x--;
        }
        for (let _ = d; _ < f; _ += 6) {
          const T = e[_ + 2 * p];
          for (let E = 0; E < x; E++) {
            const A = h[E];
            T >= A.candidate ? mi(_, e, A.rightCacheBounds) : (mi(_, e, A.leftCacheBounds), A.count++);
          }
        }
        for (let _ = 0; _ < x; _++) {
          const T = h[_], E = T.count, A = s - T.count, z = T.leftCacheBounds, D = T.rightCacheBounds;
          let I = 0;
          E !== 0 && (I = Ge(z) / l);
          let U = 0;
          A !== 0 && (U = Ge(D) / l);
          const C = Qs + $i * (I * E + U * A);
          C < c && (o = p, c = C, n = T.candidate);
        }
      } else {
        for (let x = 0; x < re; x++) {
          const _ = le[x];
          _.count = 0, _.candidate = u + b + x * b;
          const T = _.bounds;
          for (let E = 0; E < 3; E++)
            T[E] = 1 / 0, T[E + 3] = -1 / 0;
        }
        for (let x = d; x < f; x += 6) {
          let E = ~~((e[x + 2 * p] - u) / b);
          E >= re && (E = re - 1);
          const A = le[E];
          A.count++, mi(x, e, A.bounds);
        }
        const h = le[re - 1];
        Ks(h.bounds, h.rightCacheBounds);
        for (let x = re - 2; x >= 0; x--) {
          const _ = le[x], T = le[x + 1];
          Xs(_.bounds, T.rightCacheBounds, _.rightCacheBounds);
        }
        let v = 0;
        for (let x = 0; x < re - 1; x++) {
          const _ = le[x], T = _.count, E = _.bounds, z = le[x + 1].rightCacheBounds;
          T !== 0 && (v === 0 ? Ks(E, gi) : Xs(E, gi, gi)), v += T;
          let D = 0, I = 0;
          v !== 0 && (D = Ge(gi) / l);
          const U = s - v;
          U !== 0 && (I = Ge(z) / l);
          const C = Qs + $i * (D * v + I * U);
          C < c && (o = p, c = C, n = _.candidate);
        }
      }
    }
  } else
    console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);
  return { axis: o, pos: n };
}
function $n(a, t, e, i) {
  let s = 0;
  for (let r = t, o = t + e; r < o; r++)
    s += a[r * 6 + i * 2];
  return s / e;
}
var vi = class {
  constructor() {
  }
};
function to(a, t, e, i, s, r) {
  let o = i, n = i + s - 1;
  const l = r.pos, c = r.axis * 2;
  for (; ; ) {
    for (; o <= n && e[o * 6 + c] < l; )
      o++;
    for (; o <= n && e[n * 6 + c] >= l; )
      n--;
    if (o < n) {
      for (let d = 0; d < 3; d++) {
        let f = t[o * 3 + d];
        t[o * 3 + d] = t[n * 3 + d], t[n * 3 + d] = f;
      }
      for (let d = 0; d < 6; d++) {
        let f = e[o * 6 + d];
        e[o * 6 + d] = e[n * 6 + d], e[n * 6 + d] = f;
      }
      o++, n--;
    } else
      return o;
  }
}
function eo(a, t, e, i, s, r) {
  let o = i, n = i + s - 1;
  const l = r.pos, c = r.axis * 2;
  for (; ; ) {
    for (; o <= n && e[o * 6 + c] < l; )
      o++;
    for (; o <= n && e[n * 6 + c] >= l; )
      n--;
    if (o < n) {
      let d = a[o];
      a[o] = a[n], a[n] = d;
      for (let f = 0; f < 6; f++) {
        let p = e[o * 6 + f];
        e[o * 6 + f] = e[n * 6 + f], e[n * 6 + f] = p;
      }
      o++, n--;
    } else
      return o;
  }
}
function io(a, t) {
  const e = (a.index ? a.index.count : a.attributes.position.count) / 3, i = e > 2 ** 16, s = i ? 4 : 2, r = t ? new SharedArrayBuffer(e * s) : new ArrayBuffer(e * s), o = i ? new Uint32Array(r) : new Uint16Array(r);
  for (let n = 0, l = o.length; n < l; n++)
    o[n] = n;
  return o;
}
function so(a, t) {
  const e = a.geometry, i = e.index ? e.index.array : null, s = t.maxDepth, r = t.verbose, o = t.maxLeafTris, n = t.strategy, l = t.onProgress, c = Fe(e), d = a._indirectBuffer;
  let f = false;
  const p = new Float32Array(6), u = new Float32Array(6), g = Xn(e, p), m = t.indirect ? eo : to, b = [], h = t.indirect ? Nr(e) : Vr(e);
  if (h.length === 1) {
    const _ = h[0], T = new vi();
    T.boundingData = p, Kn(g, _.offset, _.count, u), x(T, _.offset, _.count, u), b.push(T);
  } else
    for (let _ of h) {
      const T = new vi();
      T.boundingData = new Float32Array(6), es(g, _.offset, _.count, T.boundingData, u), x(T, _.offset, _.count, u), b.push(T);
    }
  return b;
  function v(_) {
    l && l(_ / c);
  }
  function x(_, T, E, A = null, z = 0) {
    if (!f && z >= s && (f = true, r && (console.warn(`MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`), console.warn(e))), E <= o || z >= s)
      return v(T + E), _.offset = T, _.count = E, _;
    const D = Jn(_.boundingData, A, g, T, E, n);
    if (D.axis === -1)
      return v(T + E), _.offset = T, _.count = E, _;
    const I = m(d, i, g, T, E, D);
    if (I === T || I === T + E)
      v(T + E), _.offset = T, _.count = E;
    else {
      _.splitAxis = D.axis;
      const U = new vi(), C = T, k = I - T;
      _.left = U, U.boundingData = new Float32Array(6), es(g, C, k, U.boundingData, u), x(U, C, k, u, z + 1);
      const w = new vi(), M = I, J = E - k;
      _.right = w, w.boundingData = new Float32Array(6), es(g, M, J, w.boundingData, u), x(w, M, J, u, z + 1);
    }
    return _;
  }
}
function ro(a, t) {
  const e = a.geometry;
  t.indirect && (a._indirectBuffer = io(e, t.useSharedArrayBuffer), Qn(e) && !t.verbose && console.warn(
    'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
  )), a._indirectBuffer || jn(e, t);
  const i = so(a, t);
  let s, r, o;
  const n = [], l = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let f = 0; f < i.length; f++) {
    const p = i[f];
    let u = c(p);
    const g = new l(ki * u);
    s = new Float32Array(g), r = new Uint32Array(g), o = new Uint16Array(g), d(0, p), n.push(g);
  }
  a._roots = n;
  return;
  function c(f) {
    return f.count ? 1 : 1 + c(f.left) + c(f.right);
  }
  function d(f, p) {
    const u = f / 4, g = f / 2, m = !!p.count, b = p.boundingData;
    for (let h = 0; h < 6; h++)
      s[u + h] = b[h];
    if (m) {
      const h = p.offset, v = p.count;
      return r[u + 6] = h, o[g + 14] = v, o[g + 15] = Ui, f + ki;
    } else {
      const h = p.left, v = p.right, x = p.splitAxis;
      let _;
      if (_ = d(f + ki, h), _ / 4 > Math.pow(2, 32))
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      return r[u + 6] = _ / 4, _ = d(_, v), r[u + 7] = x, _;
    }
  }
}
var oe = class {
  constructor() {
    this.min = 1 / 0, this.max = -1 / 0;
  }
  setFromPointsField(t, e) {
    let i = 1 / 0, s = -1 / 0;
    for (let r = 0, o = t.length; r < o; r++) {
      const l = t[r][e];
      i = l < i ? l : i, s = l > s ? l : s;
    }
    this.min = i, this.max = s;
  }
  setFromPoints(t, e) {
    let i = 1 / 0, s = -1 / 0;
    for (let r = 0, o = e.length; r < o; r++) {
      const n = e[r], l = t.dot(n);
      i = l < i ? l : i, s = l > s ? l : s;
    }
    this.min = i, this.max = s;
  }
  isSeparated(t) {
    return this.min > t.max || t.min > this.max;
  }
};
oe.prototype.setFromBox = function() {
  const a = new Vector3();
  return function(e, i) {
    const s = i.min, r = i.max;
    let o = 1 / 0, n = -1 / 0;
    for (let l = 0; l <= 1; l++)
      for (let c = 0; c <= 1; c++)
        for (let d = 0; d <= 1; d++) {
          a.x = s.x * l + r.x * (1 - l), a.y = s.y * c + r.y * (1 - c), a.z = s.z * d + r.z * (1 - d);
          const f = e.dot(a);
          o = Math.min(f, o), n = Math.max(f, n);
        }
    this.min = o, this.max = n;
  };
}();
var no = function() {
  const a = new Vector3(), t = new Vector3(), e = new Vector3();
  return function(s, r, o) {
    const n = s.start, l = a, c = r.start, d = t;
    e.subVectors(n, c), a.subVectors(s.end, s.start), t.subVectors(r.end, r.start);
    const f = e.dot(d), p = d.dot(l), u = d.dot(d), g = e.dot(l), b = l.dot(l) * u - p * p;
    let h, v;
    b !== 0 ? h = (f * p - g * u) / b : h = 0, v = (f + h * p) / u, o.x = h, o.y = v;
  };
}();
var Es = function() {
  const a = new Vector2(), t = new Vector3(), e = new Vector3();
  return function(s, r, o, n) {
    no(s, r, a);
    let l = a.x, c = a.y;
    if (l >= 0 && l <= 1 && c >= 0 && c <= 1) {
      s.at(l, o), r.at(c, n);
      return;
    } else if (l >= 0 && l <= 1) {
      c < 0 ? r.at(0, n) : r.at(1, n), s.closestPointToPoint(n, true, o);
      return;
    } else if (c >= 0 && c <= 1) {
      l < 0 ? s.at(0, o) : s.at(1, o), r.closestPointToPoint(o, true, n);
      return;
    } else {
      let d;
      l < 0 ? d = s.start : d = s.end;
      let f;
      c < 0 ? f = r.start : f = r.end;
      const p = t, u = e;
      if (s.closestPointToPoint(f, true, t), r.closestPointToPoint(d, true, e), p.distanceToSquared(f) <= u.distanceToSquared(d)) {
        o.copy(p), n.copy(f);
        return;
      } else {
        o.copy(d), n.copy(u);
        return;
      }
    }
  };
}();
var oo = function() {
  const a = new Vector3(), t = new Vector3(), e = new Plane(), i = new Line3();
  return function(r, o) {
    const { radius: n, center: l } = r, { a: c, b: d, c: f } = o;
    if (i.start = c, i.end = d, i.closestPointToPoint(l, true, a).distanceTo(l) <= n || (i.start = c, i.end = f, i.closestPointToPoint(l, true, a).distanceTo(l) <= n) || (i.start = d, i.end = f, i.closestPointToPoint(l, true, a).distanceTo(l) <= n))
      return true;
    const m = o.getPlane(e);
    if (Math.abs(m.distanceToPoint(l)) <= n) {
      const h = m.projectPoint(l, t);
      if (o.containsPoint(h))
        return true;
    }
    return false;
  };
}();
var ao = 1e-15;
function is(a) {
  return Math.abs(a) < ao;
}
var Gt = class extends Triangle {
  constructor(...t) {
    super(...t), this.isExtendedTriangle = true, this.satAxes = new Array(4).fill().map(() => new Vector3()), this.satBounds = new Array(4).fill().map(() => new oe()), this.points = [this.a, this.b, this.c], this.sphere = new Sphere(), this.plane = new Plane(), this.needsUpdate = true;
  }
  intersectsSphere(t) {
    return oo(t, this);
  }
  update() {
    const t = this.a, e = this.b, i = this.c, s = this.points, r = this.satAxes, o = this.satBounds, n = r[0], l = o[0];
    this.getNormal(n), l.setFromPoints(n, s);
    const c = r[1], d = o[1];
    c.subVectors(t, e), d.setFromPoints(c, s);
    const f = r[2], p = o[2];
    f.subVectors(e, i), p.setFromPoints(f, s);
    const u = r[3], g = o[3];
    u.subVectors(i, t), g.setFromPoints(u, s), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(n, t), this.needsUpdate = false;
  }
};
Gt.prototype.closestPointToSegment = function() {
  const a = new Vector3(), t = new Vector3(), e = new Line3();
  return function(s, r = null, o = null) {
    const { start: n, end: l } = s, c = this.points;
    let d, f = 1 / 0;
    for (let p = 0; p < 3; p++) {
      const u = (p + 1) % 3;
      e.start.copy(c[p]), e.end.copy(c[u]), Es(e, s, a, t), d = a.distanceToSquared(t), d < f && (f = d, r && r.copy(a), o && o.copy(t));
    }
    return this.closestPointToPoint(n, a), d = n.distanceToSquared(a), d < f && (f = d, r && r.copy(a), o && o.copy(n)), this.closestPointToPoint(l, a), d = l.distanceToSquared(a), d < f && (f = d, r && r.copy(a), o && o.copy(l)), Math.sqrt(f);
  };
}();
Gt.prototype.intersectsTriangle = function() {
  const a = new Gt(), t = new Array(3), e = new Array(3), i = new oe(), s = new oe(), r = new Vector3(), o = new Vector3(), n = new Vector3(), l = new Vector3(), c = new Vector3(), d = new Line3(), f = new Line3(), p = new Line3(), u = new Vector3();
  function g(m, b, h) {
    const v = m.points;
    let x = 0, _ = -1;
    for (let T = 0; T < 3; T++) {
      const { start: E, end: A } = d;
      E.copy(v[T]), A.copy(v[(T + 1) % 3]), d.delta(o);
      const z = is(b.distanceToPoint(E));
      if (is(b.normal.dot(o)) && z) {
        h.copy(d), x = 2;
        break;
      }
      const D = b.intersectLine(d, u);
      if (!D && z && u.copy(E), (D || z) && !is(u.distanceTo(A))) {
        if (x <= 1)
          (x === 1 ? h.start : h.end).copy(u), z && (_ = x);
        else if (x >= 2) {
          (_ === 1 ? h.start : h.end).copy(u), x = 2;
          break;
        }
        if (x++, x === 2 && _ === -1)
          break;
      }
    }
    return x;
  }
  return function(b, h = null, v = false) {
    this.needsUpdate && this.update(), b.isExtendedTriangle ? b.needsUpdate && b.update() : (a.copy(b), a.update(), b = a);
    const x = this.plane, _ = b.plane;
    if (Math.abs(x.normal.dot(_.normal)) > 1 - 1e-10) {
      const T = this.satBounds, E = this.satAxes;
      e[0] = b.a, e[1] = b.b, e[2] = b.c;
      for (let D = 0; D < 4; D++) {
        const I = T[D], U = E[D];
        if (i.setFromPoints(U, e), I.isSeparated(i))
          return false;
      }
      const A = b.satBounds, z = b.satAxes;
      t[0] = this.a, t[1] = this.b, t[2] = this.c;
      for (let D = 0; D < 4; D++) {
        const I = A[D], U = z[D];
        if (i.setFromPoints(U, t), I.isSeparated(i))
          return false;
      }
      for (let D = 0; D < 4; D++) {
        const I = E[D];
        for (let U = 0; U < 4; U++) {
          const C = z[U];
          if (r.crossVectors(I, C), i.setFromPoints(r, t), s.setFromPoints(r, e), i.isSeparated(s))
            return false;
        }
      }
      return h && (v || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), h.start.set(0, 0, 0), h.end.set(0, 0, 0)), true;
    } else {
      const T = g(this, _, f);
      if (T === 1 && b.containsPoint(f.end))
        return h && (h.start.copy(f.end), h.end.copy(f.end)), true;
      if (T !== 2)
        return false;
      const E = g(b, x, p);
      if (E === 1 && this.containsPoint(p.end))
        return h && (h.start.copy(p.end), h.end.copy(p.end)), true;
      if (E !== 2)
        return false;
      if (f.delta(n), p.delta(l), n.dot(l) < 0) {
        let k = p.start;
        p.start = p.end, p.end = k;
      }
      const A = f.start.dot(n), z = f.end.dot(n), D = p.start.dot(n), I = p.end.dot(n), U = z < D, C = A < I;
      return A !== I && D !== z && U === C ? false : (h && (c.subVectors(f.start, p.start), c.dot(n) > 0 ? h.start.copy(f.start) : h.start.copy(p.start), c.subVectors(f.end, p.end), c.dot(n) < 0 ? h.end.copy(f.end) : h.end.copy(p.end)), true);
    }
  };
}();
Gt.prototype.distanceToPoint = function() {
  const a = new Vector3();
  return function(e) {
    return this.closestPointToPoint(e, a), e.distanceTo(a);
  };
}();
Gt.prototype.distanceToTriangle = function() {
  const a = new Vector3(), t = new Vector3(), e = ["a", "b", "c"], i = new Line3(), s = new Line3();
  return function(o, n = null, l = null) {
    const c = n || l ? i : null;
    if (this.intersectsTriangle(o, c))
      return (n || l) && (n && c.getCenter(n), l && c.getCenter(l)), 0;
    let d = 1 / 0;
    for (let f = 0; f < 3; f++) {
      let p;
      const u = e[f], g = o[u];
      this.closestPointToPoint(g, a), p = g.distanceToSquared(a), p < d && (d = p, n && n.copy(a), l && l.copy(g));
      const m = this[u];
      o.closestPointToPoint(m, a), p = m.distanceToSquared(a), p < d && (d = p, n && n.copy(m), l && l.copy(a));
    }
    for (let f = 0; f < 3; f++) {
      const p = e[f], u = e[(f + 1) % 3];
      i.set(this[p], this[u]);
      for (let g = 0; g < 3; g++) {
        const m = e[g], b = e[(g + 1) % 3];
        s.set(o[m], o[b]), Es(i, s, a, t);
        const h = a.distanceToSquared(t);
        h < d && (d = h, n && n.copy(a), l && l.copy(t));
      }
    }
    return Math.sqrt(d);
  };
}();
var kt = class {
  constructor(t, e, i) {
    this.isOrientedBox = true, this.min = new Vector3(), this.max = new Vector3(), this.matrix = new Matrix4(), this.invMatrix = new Matrix4(), this.points = new Array(8).fill().map(() => new Vector3()), this.satAxes = new Array(3).fill().map(() => new Vector3()), this.satBounds = new Array(3).fill().map(() => new oe()), this.alignedSatBounds = new Array(3).fill().map(() => new oe()), this.needsUpdate = false, t && this.min.copy(t), e && this.max.copy(e), i && this.matrix.copy(i);
  }
  set(t, e, i) {
    this.min.copy(t), this.max.copy(e), this.matrix.copy(i), this.needsUpdate = true;
  }
  copy(t) {
    this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = true;
  }
};
kt.prototype.update = /* @__PURE__ */ function() {
  return function() {
    const t = this.matrix, e = this.min, i = this.max, s = this.points;
    for (let c = 0; c <= 1; c++)
      for (let d = 0; d <= 1; d++)
        for (let f = 0; f <= 1; f++) {
          const p = 1 * c | 2 * d | 4 * f, u = s[p];
          u.x = c ? i.x : e.x, u.y = d ? i.y : e.y, u.z = f ? i.z : e.z, u.applyMatrix4(t);
        }
    const r = this.satBounds, o = this.satAxes, n = s[0];
    for (let c = 0; c < 3; c++) {
      const d = o[c], f = r[c], p = 1 << c, u = s[p];
      d.subVectors(n, u), f.setFromPoints(d, s);
    }
    const l = this.alignedSatBounds;
    l[0].setFromPointsField(s, "x"), l[1].setFromPointsField(s, "y"), l[2].setFromPointsField(s, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = false;
  };
}();
kt.prototype.intersectsBox = function() {
  const a = new oe();
  return function(e) {
    this.needsUpdate && this.update();
    const i = e.min, s = e.max, r = this.satBounds, o = this.satAxes, n = this.alignedSatBounds;
    if (a.min = i.x, a.max = s.x, n[0].isSeparated(a) || (a.min = i.y, a.max = s.y, n[1].isSeparated(a)) || (a.min = i.z, a.max = s.z, n[2].isSeparated(a)))
      return false;
    for (let l = 0; l < 3; l++) {
      const c = o[l], d = r[l];
      if (a.setFromBox(c, e), d.isSeparated(a))
        return false;
    }
    return true;
  };
}();
kt.prototype.intersectsTriangle = function() {
  const a = new Gt(), t = new Array(3), e = new oe(), i = new oe(), s = new Vector3();
  return function(o) {
    this.needsUpdate && this.update(), o.isExtendedTriangle ? o.needsUpdate && o.update() : (a.copy(o), a.update(), o = a);
    const n = this.satBounds, l = this.satAxes;
    t[0] = o.a, t[1] = o.b, t[2] = o.c;
    for (let p = 0; p < 3; p++) {
      const u = n[p], g = l[p];
      if (e.setFromPoints(g, t), u.isSeparated(e))
        return false;
    }
    const c = o.satBounds, d = o.satAxes, f = this.points;
    for (let p = 0; p < 3; p++) {
      const u = c[p], g = d[p];
      if (e.setFromPoints(g, f), u.isSeparated(e))
        return false;
    }
    for (let p = 0; p < 3; p++) {
      const u = l[p];
      for (let g = 0; g < 4; g++) {
        const m = d[g];
        if (s.crossVectors(u, m), e.setFromPoints(s, t), i.setFromPoints(s, f), e.isSeparated(i))
          return false;
      }
    }
    return true;
  };
}();
kt.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function(t, e) {
    return this.needsUpdate && this.update(), e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), e;
  };
}();
kt.prototype.distanceToPoint = function() {
  const a = new Vector3();
  return function(e) {
    return this.closestPointToPoint(e, a), e.distanceTo(a);
  };
}();
kt.prototype.distanceToBox = function() {
  const a = ["x", "y", "z"], t = new Array(12).fill().map(() => new Line3()), e = new Array(12).fill().map(() => new Line3()), i = new Vector3(), s = new Vector3();
  return function(o, n = 0, l = null, c = null) {
    if (this.needsUpdate && this.update(), this.intersectsBox(o))
      return (l || c) && (o.getCenter(s), this.closestPointToPoint(s, i), o.closestPointToPoint(i, s), l && l.copy(i), c && c.copy(s)), 0;
    const d = n * n, f = o.min, p = o.max, u = this.points;
    let g = 1 / 0;
    for (let b = 0; b < 8; b++) {
      const h = u[b];
      s.copy(h).clamp(f, p);
      const v = h.distanceToSquared(s);
      if (v < g && (g = v, l && l.copy(h), c && c.copy(s), v < d))
        return Math.sqrt(v);
    }
    let m = 0;
    for (let b = 0; b < 3; b++)
      for (let h = 0; h <= 1; h++)
        for (let v = 0; v <= 1; v++) {
          const x = (b + 1) % 3, _ = (b + 2) % 3, T = h << x | v << _, E = 1 << b | h << x | v << _, A = u[T], z = u[E];
          t[m].set(A, z);
          const I = a[b], U = a[x], C = a[_], k = e[m], w = k.start, M = k.end;
          w[I] = f[I], w[U] = h ? f[U] : p[U], w[C] = v ? f[C] : p[U], M[I] = p[I], M[U] = h ? f[U] : p[U], M[C] = v ? f[C] : p[U], m++;
        }
    for (let b = 0; b <= 1; b++)
      for (let h = 0; h <= 1; h++)
        for (let v = 0; v <= 1; v++) {
          s.x = b ? p.x : f.x, s.y = h ? p.y : f.y, s.z = v ? p.z : f.z, this.closestPointToPoint(s, i);
          const x = s.distanceToSquared(i);
          if (x < g && (g = x, l && l.copy(i), c && c.copy(s), x < d))
            return Math.sqrt(x);
        }
    for (let b = 0; b < 12; b++) {
      const h = t[b];
      for (let v = 0; v < 12; v++) {
        const x = e[v];
        Es(h, x, i, s);
        const _ = i.distanceToSquared(s);
        if (_ < g && (g = _, l && l.copy(i), c && c.copy(s), _ < d))
          return Math.sqrt(_);
      }
    }
    return Math.sqrt(g);
  };
}();
var As = class {
  constructor(t) {
    this._getNewPrimitive = t, this._primitives = [];
  }
  getPrimitive() {
    const t = this._primitives;
    return t.length === 0 ? this._getNewPrimitive() : t.pop();
  }
  releasePrimitive(t) {
    this._primitives.push(t);
  }
};
var lo = class extends As {
  constructor() {
    super(() => new Gt());
  }
};
var Ut = new lo();
function Mt(a, t) {
  return t[a + 15] === 65535;
}
function Rt(a, t) {
  return t[a + 6];
}
function Nt(a, t) {
  return t[a + 14];
}
function Vt(a) {
  return a + 8;
}
function Ht(a, t) {
  return t[a + 6];
}
function Hr(a, t) {
  return t[a + 7];
}
var co = class {
  constructor() {
    this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
    const t = [];
    let e = null;
    this.setBuffer = (i) => {
      e && t.push(e), e = i, this.float32Array = new Float32Array(i), this.uint16Array = new Uint16Array(i), this.uint32Array = new Uint32Array(i);
    }, this.clearBuffer = () => {
      e = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, t.length !== 0 && this.setBuffer(t.pop());
    };
  }
};
var vt = new co();
var fe;
var Me;
var Te = [];
var yi = new As(() => new Box3());
function ho(a, t, e, i, s, r) {
  fe = yi.getPrimitive(), Me = yi.getPrimitive(), Te.push(fe, Me), vt.setBuffer(a._roots[t]);
  const o = us(0, a.geometry, e, i, s, r);
  vt.clearBuffer(), yi.releasePrimitive(fe), yi.releasePrimitive(Me), Te.pop(), Te.pop();
  const n = Te.length;
  return n > 0 && (Me = Te[n - 1], fe = Te[n - 2]), o;
}
function us(a, t, e, i, s = null, r = 0, o = 0) {
  const { float32Array: n, uint16Array: l, uint32Array: c } = vt;
  let d = a * 2;
  if (Mt(d, l)) {
    const p = Rt(a, c), u = Nt(d, l);
    return wt(a, n, fe), i(p, u, false, o, r + a, fe);
  } else {
    let p = function(C) {
      const { uint16Array: k, uint32Array: w } = vt;
      let M = C * 2;
      for (; !Mt(M, k); )
        C = Vt(C), M = C * 2;
      return Rt(C, w);
    }, u = function(C) {
      const { uint16Array: k, uint32Array: w } = vt;
      let M = C * 2;
      for (; !Mt(M, k); )
        C = Ht(C, w), M = C * 2;
      return Rt(C, w) + Nt(M, k);
    };
    const g = Vt(a), m = Ht(a, c);
    let b = g, h = m, v, x, _, T;
    if (s && (_ = fe, T = Me, wt(b, n, _), wt(h, n, T), v = s(_), x = s(T), x < v)) {
      b = m, h = g;
      const C = v;
      v = x, x = C, _ = T;
    }
    _ || (_ = fe, wt(b, n, _));
    const E = Mt(b * 2, l), A = e(_, E, v, o + 1, r + b);
    let z;
    if (A === js) {
      const C = p(b), w = u(b) - C;
      z = i(C, w, true, o + 1, r + b, _);
    } else
      z = A && us(
        b,
        t,
        e,
        i,
        s,
        r,
        o + 1
      );
    if (z)
      return true;
    T = Me, wt(h, n, T);
    const D = Mt(h * 2, l), I = e(T, D, x, o + 1, r + h);
    let U;
    if (I === js) {
      const C = p(h), w = u(h) - C;
      U = i(C, w, true, o + 1, r + h, T);
    } else
      U = I && us(
        h,
        t,
        e,
        i,
        s,
        r,
        o + 1
      );
    return !!U;
  }
}
var Ke = new Vector3();
var ss2 = new Vector3();
function uo(a, t, e = {}, i = 0, s = 1 / 0) {
  const r = i * i, o = s * s;
  let n = 1 / 0, l = null;
  if (a.shapecast(
    {
      boundsTraverseOrder: (d) => (Ke.copy(t).clamp(d.min, d.max), Ke.distanceToSquared(t)),
      intersectsBounds: (d, f, p) => p < n && p < o,
      intersectsTriangle: (d, f) => {
        d.closestPointToPoint(t, Ke);
        const p = t.distanceToSquared(Ke);
        return p < n && (ss2.copy(Ke), n = p, l = f), p < r;
      }
    }
  ), n === 1 / 0)
    return null;
  const c = Math.sqrt(n);
  return e.point ? e.point.copy(ss2) : e.point = ss2.clone(), e.distance = c, e.faceIndex = l, e;
}
var Ce = new Vector3();
var Se = new Vector3();
var Ee = new Vector3();
var wi = new Vector2();
var bi = new Vector2();
var xi = new Vector2();
var qs = new Vector3();
var Js = new Vector3();
var $s = new Vector3();
var _i = new Vector3();
function fo(a, t, e, i, s, r) {
  let o;
  return r === BackSide ? o = a.intersectTriangle(i, e, t, true, s) : o = a.intersectTriangle(t, e, i, r !== DoubleSide, s), o === null ? null : {
    distance: a.origin.distanceTo(s),
    point: s.clone()
  };
}
function po(a, t, e, i, s, r, o, n, l) {
  Ce.fromBufferAttribute(t, r), Se.fromBufferAttribute(t, o), Ee.fromBufferAttribute(t, n);
  const c = fo(a, Ce, Se, Ee, _i, l);
  if (c) {
    i && (wi.fromBufferAttribute(i, r), bi.fromBufferAttribute(i, o), xi.fromBufferAttribute(i, n), c.uv = Triangle.getInterpolation(_i, Ce, Se, Ee, wi, bi, xi, new Vector2())), s && (wi.fromBufferAttribute(s, r), bi.fromBufferAttribute(s, o), xi.fromBufferAttribute(s, n), c.uv1 = Triangle.getInterpolation(_i, Ce, Se, Ee, wi, bi, xi, new Vector2())), e && (qs.fromBufferAttribute(e, r), Js.fromBufferAttribute(e, o), $s.fromBufferAttribute(e, n), c.normal = Triangle.getInterpolation(_i, Ce, Se, Ee, qs, Js, $s, new Vector3()), c.normal.dot(a.direction) > 0 && c.normal.multiplyScalar(-1));
    const d = {
      a: r,
      b: o,
      c: n,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(Ce, Se, Ee, d.normal), c.face = d, c.faceIndex = r;
  }
  return c;
}
function Ni(a, t, e, i, s) {
  const r = i * 3;
  let o = r + 0, n = r + 1, l = r + 2;
  const c = a.index;
  a.index && (o = c.getX(o), n = c.getX(n), l = c.getX(l));
  const { position: d, normal: f, uv: p, uv1: u } = a.attributes, g = po(e, d, f, p, u, o, n, l, t);
  return g ? (g.faceIndex = i, s && s.push(g), g) : null;
}
function Ct(a, t, e, i) {
  const s = a.a, r = a.b, o = a.c;
  let n = t, l = t + 1, c = t + 2;
  e && (n = e.getX(n), l = e.getX(l), c = e.getX(c)), s.x = i.getX(n), s.y = i.getY(n), s.z = i.getZ(n), r.x = i.getX(l), r.y = i.getY(l), r.z = i.getZ(l), o.x = i.getX(c), o.y = i.getY(c), o.z = i.getZ(c);
}
function mo(a, t, e, i, s, r) {
  const { geometry: o, _indirectBuffer: n } = a;
  for (let l = i, c = i + s; l < c; l++)
    Ni(o, t, e, l, r);
}
function go(a, t, e, i, s) {
  const { geometry: r, _indirectBuffer: o } = a;
  let n = 1 / 0, l = null;
  for (let c = i, d = i + s; c < d; c++) {
    let f;
    f = Ni(r, t, e, c), f && f.distance < n && (l = f, n = f.distance);
  }
  return l;
}
function vo(a, t, e, i, s, r, o) {
  const { geometry: n } = e, { index: l } = n, c = n.attributes.position;
  for (let d = a, f = t + a; d < f; d++) {
    let p;
    if (p = d, Ct(o, p * 3, l, c), o.needsUpdate = true, i(o, p, s, r))
      return true;
  }
  return false;
}
function yo(a, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = a.geometry, i = e.index ? e.index.array : null, s = e.attributes.position;
  let r, o, n, l, c = 0;
  const d = a._roots;
  for (let p = 0, u = d.length; p < u; p++)
    r = d[p], o = new Uint32Array(r), n = new Uint16Array(r), l = new Float32Array(r), f(0, c), c += r.byteLength;
  function f(p, u, g = false) {
    const m = p * 2;
    if (n[m + 15] === Ui) {
      const h = o[p + 6], v = n[m + 14];
      let x = 1 / 0, _ = 1 / 0, T = 1 / 0, E = -1 / 0, A = -1 / 0, z = -1 / 0;
      for (let D = 3 * h, I = 3 * (h + v); D < I; D++) {
        let U = i[D];
        const C = s.getX(U), k = s.getY(U), w = s.getZ(U);
        C < x && (x = C), C > E && (E = C), k < _ && (_ = k), k > A && (A = k), w < T && (T = w), w > z && (z = w);
      }
      return l[p + 0] !== x || l[p + 1] !== _ || l[p + 2] !== T || l[p + 3] !== E || l[p + 4] !== A || l[p + 5] !== z ? (l[p + 0] = x, l[p + 1] = _, l[p + 2] = T, l[p + 3] = E, l[p + 4] = A, l[p + 5] = z, true) : false;
    } else {
      const h = p + 8, v = o[p + 6], x = h + u, _ = v + u;
      let T = g, E = false, A = false;
      t ? T || (E = t.has(x), A = t.has(_), T = !E && !A) : (E = true, A = true);
      const z = T || E, D = T || A;
      let I = false;
      z && (I = f(h, u, T));
      let U = false;
      D && (U = f(v, u, T));
      const C = I || U;
      if (C)
        for (let k = 0; k < 3; k++) {
          const w = h + k, M = v + k, J = l[w], Z = l[w + 3], nt = l[M], j = l[M + 3];
          l[p + k] = J < nt ? J : nt, l[p + k + 3] = Z > j ? Z : j;
        }
      return C;
    }
  }
}
var tr = new Box3();
function pe(a, t, e, i) {
  return wt(a, t, tr), e.intersectBox(tr, i);
}
function wo(a, t, e, i, s, r) {
  const { geometry: o, _indirectBuffer: n } = a;
  for (let l = i, c = i + s; l < c; l++) {
    let d = n ? n[l] : l;
    Ni(o, t, e, d, r);
  }
}
function bo(a, t, e, i, s) {
  const { geometry: r, _indirectBuffer: o } = a;
  let n = 1 / 0, l = null;
  for (let c = i, d = i + s; c < d; c++) {
    let f;
    f = Ni(r, t, e, o ? o[c] : c), f && f.distance < n && (l = f, n = f.distance);
  }
  return l;
}
function xo(a, t, e, i, s, r, o) {
  const { geometry: n } = e, { index: l } = n, c = n.attributes.position;
  for (let d = a, f = t + a; d < f; d++) {
    let p;
    if (p = e.resolveTriangleIndex(d), Ct(o, p * 3, l, c), o.needsUpdate = true, i(o, p, s, r))
      return true;
  }
  return false;
}
var er = new Vector3();
function _o(a, t, e, i, s) {
  vt.setBuffer(a._roots[t]), fs(0, a, e, i, s), vt.clearBuffer();
}
function fs(a, t, e, i, s) {
  const { float32Array: r, uint16Array: o, uint32Array: n } = vt, l = a * 2;
  if (Mt(l, o)) {
    const d = Rt(a, n), f = Nt(l, o);
    mo(t, e, i, d, f, s);
  } else {
    const d = Vt(a);
    pe(d, r, i, er) && fs(d, t, e, i, s);
    const f = Ht(a, n);
    pe(f, r, i, er) && fs(f, t, e, i, s);
  }
}
var ir = new Vector3();
var To = ["x", "y", "z"];
function Co(a, t, e, i) {
  vt.setBuffer(a._roots[t]);
  const s = ds(0, a, e, i);
  return vt.clearBuffer(), s;
}
function ds(a, t, e, i) {
  const { float32Array: s, uint16Array: r, uint32Array: o } = vt;
  let n = a * 2;
  if (Mt(n, r)) {
    const c = Rt(a, o), d = Nt(n, r);
    return go(t, e, i, c, d);
  } else {
    const c = Hr(a, o), d = To[c], p = i.direction[d] >= 0;
    let u, g;
    p ? (u = Vt(a), g = Ht(a, o)) : (u = Ht(a, o), g = Vt(a));
    const b = pe(u, s, i, ir) ? ds(u, t, e, i) : null;
    if (b) {
      const x = b.point[d];
      if (p ? x <= s[g + c] : (
        // min bounding data
        x >= s[g + c + 3]
      ))
        return b;
    }
    const v = pe(g, s, i, ir) ? ds(g, t, e, i) : null;
    return b && v ? b.distance <= v.distance ? b : v : b || v || null;
  }
}
var Ti = new Box3();
var Ae = new Gt();
var Oe = new Gt();
var Xe = new Matrix4();
var sr = new kt();
var Ci = new kt();
function So(a, t, e, i) {
  vt.setBuffer(a._roots[t]);
  const s = ps(0, a, e, i);
  return vt.clearBuffer(), s;
}
function ps(a, t, e, i, s = null) {
  const { float32Array: r, uint16Array: o, uint32Array: n } = vt;
  let l = a * 2;
  if (s === null && (e.boundingBox || e.computeBoundingBox(), sr.set(e.boundingBox.min, e.boundingBox.max, i), s = sr), Mt(l, o)) {
    const d = t.geometry, f = d.index, p = d.attributes.position, u = e.index, g = e.attributes.position, m = Rt(a, n), b = Nt(l, o);
    if (Xe.copy(i).invert(), e.boundsTree)
      return wt(a, r, Ci), Ci.matrix.copy(Xe), Ci.needsUpdate = true, e.boundsTree.shapecast({
        intersectsBounds: (v) => Ci.intersectsBox(v),
        intersectsTriangle: (v) => {
          v.a.applyMatrix4(i), v.b.applyMatrix4(i), v.c.applyMatrix4(i), v.needsUpdate = true;
          for (let x = m * 3, _ = (b + m) * 3; x < _; x += 3)
            if (Ct(Oe, x, f, p), Oe.needsUpdate = true, v.intersectsTriangle(Oe))
              return true;
          return false;
        }
      });
    for (let h = m * 3, v = (b + m) * 3; h < v; h += 3) {
      Ct(Ae, h, f, p), Ae.a.applyMatrix4(Xe), Ae.b.applyMatrix4(Xe), Ae.c.applyMatrix4(Xe), Ae.needsUpdate = true;
      for (let x = 0, _ = u.count; x < _; x += 3)
        if (Ct(Oe, x, u, g), Oe.needsUpdate = true, Ae.intersectsTriangle(Oe))
          return true;
    }
  } else {
    const d = a + 8, f = n[a + 6];
    return wt(d, r, Ti), !!(s.intersectsBox(Ti) && ps(d, t, e, i, s) || (wt(f, r, Ti), s.intersectsBox(Ti) && ps(f, t, e, i, s)));
  }
}
var Si = new Matrix4();
var rs = new kt();
var qe = new kt();
var Eo = new Vector3();
var Ao = new Vector3();
var Oo = new Vector3();
var Do = new Vector3();
function Po(a, t, e, i = {}, s = {}, r = 0, o = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), rs.set(t.boundingBox.min, t.boundingBox.max, e), rs.needsUpdate = true;
  const n = a.geometry, l = n.attributes.position, c = n.index, d = t.attributes.position, f = t.index, p = Ut.getPrimitive(), u = Ut.getPrimitive();
  let g = Eo, m = Ao, b = null, h = null;
  s && (b = Oo, h = Do);
  let v = 1 / 0, x = null, _ = null;
  return Si.copy(e).invert(), qe.matrix.copy(Si), a.shapecast(
    {
      boundsTraverseOrder: (T) => rs.distanceToBox(T),
      intersectsBounds: (T, E, A) => A < v && A < o ? (E && (qe.min.copy(T.min), qe.max.copy(T.max), qe.needsUpdate = true), true) : false,
      intersectsRange: (T, E) => {
        if (t.boundsTree)
          return t.boundsTree.shapecast({
            boundsTraverseOrder: (z) => qe.distanceToBox(z),
            intersectsBounds: (z, D, I) => I < v && I < o,
            intersectsRange: (z, D) => {
              for (let I = z, U = z + D; I < U; I++) {
                Ct(u, 3 * I, f, d), u.a.applyMatrix4(e), u.b.applyMatrix4(e), u.c.applyMatrix4(e), u.needsUpdate = true;
                for (let C = T, k = T + E; C < k; C++) {
                  Ct(p, 3 * C, c, l), p.needsUpdate = true;
                  const w = p.distanceToTriangle(u, g, b);
                  if (w < v && (m.copy(g), h && h.copy(b), v = w, x = C, _ = I), w < r)
                    return true;
                }
              }
            }
          });
        {
          const A = Fe(t);
          for (let z = 0, D = A; z < D; z++) {
            Ct(u, 3 * z, f, d), u.a.applyMatrix4(e), u.b.applyMatrix4(e), u.c.applyMatrix4(e), u.needsUpdate = true;
            for (let I = T, U = T + E; I < U; I++) {
              Ct(p, 3 * I, c, l), p.needsUpdate = true;
              const C = p.distanceToTriangle(u, g, b);
              if (C < v && (m.copy(g), h && h.copy(b), v = C, x = I, _ = z), C < r)
                return true;
            }
          }
        }
      }
    }
  ), Ut.releasePrimitive(p), Ut.releasePrimitive(u), v === 1 / 0 ? null : (i.point ? i.point.copy(m) : i.point = m.clone(), i.distance = v, i.faceIndex = x, s && (s.point ? s.point.copy(h) : s.point = h.clone(), s.point.applyMatrix4(Si), m.applyMatrix4(Si), s.distance = m.sub(s.point).length(), s.faceIndex = _), i);
}
function zo(a, t = null) {
  t && Array.isArray(t) && (t = new Set(t));
  const e = a.geometry, i = e.index ? e.index.array : null, s = e.attributes.position;
  let r, o, n, l, c = 0;
  const d = a._roots;
  for (let p = 0, u = d.length; p < u; p++)
    r = d[p], o = new Uint32Array(r), n = new Uint16Array(r), l = new Float32Array(r), f(0, c), c += r.byteLength;
  function f(p, u, g = false) {
    const m = p * 2;
    if (n[m + 15] === Ui) {
      const h = o[p + 6], v = n[m + 14];
      let x = 1 / 0, _ = 1 / 0, T = 1 / 0, E = -1 / 0, A = -1 / 0, z = -1 / 0;
      for (let D = h, I = h + v; D < I; D++) {
        const U = 3 * a.resolveTriangleIndex(D);
        for (let C = 0; C < 3; C++) {
          let k = U + C;
          k = i ? i[k] : k;
          const w = s.getX(k), M = s.getY(k), J = s.getZ(k);
          w < x && (x = w), w > E && (E = w), M < _ && (_ = M), M > A && (A = M), J < T && (T = J), J > z && (z = J);
        }
      }
      return l[p + 0] !== x || l[p + 1] !== _ || l[p + 2] !== T || l[p + 3] !== E || l[p + 4] !== A || l[p + 5] !== z ? (l[p + 0] = x, l[p + 1] = _, l[p + 2] = T, l[p + 3] = E, l[p + 4] = A, l[p + 5] = z, true) : false;
    } else {
      const h = p + 8, v = o[p + 6], x = h + u, _ = v + u;
      let T = g, E = false, A = false;
      t ? T || (E = t.has(x), A = t.has(_), T = !E && !A) : (E = true, A = true);
      const z = T || E, D = T || A;
      let I = false;
      z && (I = f(h, u, T));
      let U = false;
      D && (U = f(v, u, T));
      const C = I || U;
      if (C)
        for (let k = 0; k < 3; k++) {
          const w = h + k, M = v + k, J = l[w], Z = l[w + 3], nt = l[M], j = l[M + 3];
          l[p + k] = J < nt ? J : nt, l[p + k + 3] = Z > j ? Z : j;
        }
      return C;
    }
  }
}
var rr = new Vector3();
function ko(a, t, e, i, s) {
  vt.setBuffer(a._roots[t]), ms(0, a, e, i, s), vt.clearBuffer();
}
function ms(a, t, e, i, s) {
  const { float32Array: r, uint16Array: o, uint32Array: n } = vt, l = a * 2;
  if (Mt(l, o)) {
    const d = Rt(a, n), f = Nt(l, o);
    wo(t, e, i, d, f, s);
  } else {
    const d = Vt(a);
    pe(d, r, i, rr) && ms(d, t, e, i, s);
    const f = Ht(a, n);
    pe(f, r, i, rr) && ms(f, t, e, i, s);
  }
}
var nr = new Vector3();
var Bo = ["x", "y", "z"];
function Io(a, t, e, i) {
  vt.setBuffer(a._roots[t]);
  const s = gs(0, a, e, i);
  return vt.clearBuffer(), s;
}
function gs(a, t, e, i) {
  const { float32Array: s, uint16Array: r, uint32Array: o } = vt;
  let n = a * 2;
  if (Mt(n, r)) {
    const c = Rt(a, o), d = Nt(n, r);
    return bo(t, e, i, c, d);
  } else {
    const c = Hr(a, o), d = Bo[c], p = i.direction[d] >= 0;
    let u, g;
    p ? (u = Vt(a), g = Ht(a, o)) : (u = Ht(a, o), g = Vt(a));
    const b = pe(u, s, i, nr) ? gs(u, t, e, i) : null;
    if (b) {
      const x = b.point[d];
      if (p ? x <= s[g + c] : (
        // min bounding data
        x >= s[g + c + 3]
      ))
        return b;
    }
    const v = pe(g, s, i, nr) ? gs(g, t, e, i) : null;
    return b && v ? b.distance <= v.distance ? b : v : b || v || null;
  }
}
var Ei = new Box3();
var De = new Gt();
var Pe = new Gt();
var Je = new Matrix4();
var or = new kt();
var Ai = new kt();
function Mo(a, t, e, i) {
  vt.setBuffer(a._roots[t]);
  const s = vs(0, a, e, i);
  return vt.clearBuffer(), s;
}
function vs(a, t, e, i, s = null) {
  const { float32Array: r, uint16Array: o, uint32Array: n } = vt;
  let l = a * 2;
  if (s === null && (e.boundingBox || e.computeBoundingBox(), or.set(e.boundingBox.min, e.boundingBox.max, i), s = or), Mt(l, o)) {
    const d = t.geometry, f = d.index, p = d.attributes.position, u = e.index, g = e.attributes.position, m = Rt(a, n), b = Nt(l, o);
    if (Je.copy(i).invert(), e.boundsTree)
      return wt(a, r, Ai), Ai.matrix.copy(Je), Ai.needsUpdate = true, e.boundsTree.shapecast({
        intersectsBounds: (v) => Ai.intersectsBox(v),
        intersectsTriangle: (v) => {
          v.a.applyMatrix4(i), v.b.applyMatrix4(i), v.c.applyMatrix4(i), v.needsUpdate = true;
          for (let x = m, _ = b + m; x < _; x++)
            if (Ct(Pe, 3 * t.resolveTriangleIndex(x), f, p), Pe.needsUpdate = true, v.intersectsTriangle(Pe))
              return true;
          return false;
        }
      });
    for (let h = m, v = b + m; h < v; h++) {
      const x = t.resolveTriangleIndex(h);
      Ct(De, 3 * x, f, p), De.a.applyMatrix4(Je), De.b.applyMatrix4(Je), De.c.applyMatrix4(Je), De.needsUpdate = true;
      for (let _ = 0, T = u.count; _ < T; _ += 3)
        if (Ct(Pe, _, u, g), Pe.needsUpdate = true, De.intersectsTriangle(Pe))
          return true;
    }
  } else {
    const d = a + 8, f = n[a + 6];
    return wt(d, r, Ei), !!(s.intersectsBox(Ei) && vs(d, t, e, i, s) || (wt(f, r, Ei), s.intersectsBox(Ei) && vs(f, t, e, i, s)));
  }
}
var Oi = new Matrix4();
var ns = new kt();
var $e = new kt();
var Ro = new Vector3();
var Lo = new Vector3();
var Fo = new Vector3();
var Uo = new Vector3();
function No(a, t, e, i = {}, s = {}, r = 0, o = 1 / 0) {
  t.boundingBox || t.computeBoundingBox(), ns.set(t.boundingBox.min, t.boundingBox.max, e), ns.needsUpdate = true;
  const n = a.geometry, l = n.attributes.position, c = n.index, d = t.attributes.position, f = t.index, p = Ut.getPrimitive(), u = Ut.getPrimitive();
  let g = Ro, m = Lo, b = null, h = null;
  s && (b = Fo, h = Uo);
  let v = 1 / 0, x = null, _ = null;
  return Oi.copy(e).invert(), $e.matrix.copy(Oi), a.shapecast(
    {
      boundsTraverseOrder: (T) => ns.distanceToBox(T),
      intersectsBounds: (T, E, A) => A < v && A < o ? (E && ($e.min.copy(T.min), $e.max.copy(T.max), $e.needsUpdate = true), true) : false,
      intersectsRange: (T, E) => {
        if (t.boundsTree) {
          const A = t.boundsTree;
          return A.shapecast({
            boundsTraverseOrder: (z) => $e.distanceToBox(z),
            intersectsBounds: (z, D, I) => I < v && I < o,
            intersectsRange: (z, D) => {
              for (let I = z, U = z + D; I < U; I++) {
                const C = A.resolveTriangleIndex(I);
                Ct(u, 3 * C, f, d), u.a.applyMatrix4(e), u.b.applyMatrix4(e), u.c.applyMatrix4(e), u.needsUpdate = true;
                for (let k = T, w = T + E; k < w; k++) {
                  const M = a.resolveTriangleIndex(k);
                  Ct(p, 3 * M, c, l), p.needsUpdate = true;
                  const J = p.distanceToTriangle(u, g, b);
                  if (J < v && (m.copy(g), h && h.copy(b), v = J, x = k, _ = I), J < r)
                    return true;
                }
              }
            }
          });
        } else {
          const A = Fe(t);
          for (let z = 0, D = A; z < D; z++) {
            Ct(u, 3 * z, f, d), u.a.applyMatrix4(e), u.b.applyMatrix4(e), u.c.applyMatrix4(e), u.needsUpdate = true;
            for (let I = T, U = T + E; I < U; I++) {
              const C = a.resolveTriangleIndex(I);
              Ct(p, 3 * C, c, l), p.needsUpdate = true;
              const k = p.distanceToTriangle(u, g, b);
              if (k < v && (m.copy(g), h && h.copy(b), v = k, x = I, _ = z), k < r)
                return true;
            }
          }
        }
      }
    }
  ), Ut.releasePrimitive(p), Ut.releasePrimitive(u), v === 1 / 0 ? null : (i.point ? i.point.copy(m) : i.point = m.clone(), i.distance = v, i.faceIndex = x, s && (s.point ? s.point.copy(h) : s.point = h.clone(), s.point.applyMatrix4(Oi), m.applyMatrix4(Oi), s.distance = m.sub(s.point).length(), s.faceIndex = _), i);
}
function Vo() {
  return typeof SharedArrayBuffer < "u";
}
var ni = new vt.constructor();
var Ii = new vt.constructor();
var ue = new As(() => new Box3());
var ze = new Box3();
var ke = new Box3();
var os = new Box3();
var as = new Box3();
var ls = false;
function Ho(a, t, e, i) {
  if (ls)
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  ls = true;
  const s = a._roots, r = t._roots;
  let o, n = 0, l = 0;
  const c = new Matrix4().copy(e).invert();
  for (let d = 0, f = s.length; d < f; d++) {
    ni.setBuffer(s[d]), l = 0;
    const p = ue.getPrimitive();
    wt(0, ni.float32Array, p), p.applyMatrix4(c);
    for (let u = 0, g = r.length; u < g && (Ii.setBuffer(r[d]), o = jt(
      0,
      0,
      e,
      c,
      i,
      n,
      l,
      0,
      0,
      p
    ), Ii.clearBuffer(), l += r[u].length, !o); u++)
      ;
    if (ue.releasePrimitive(p), ni.clearBuffer(), n += s[d].length, o)
      break;
  }
  return ls = false, o;
}
function jt(a, t, e, i, s, r = 0, o = 0, n = 0, l = 0, c = null, d = false) {
  let f, p;
  d ? (f = Ii, p = ni) : (f = ni, p = Ii);
  const u = f.float32Array, g = f.uint32Array, m = f.uint16Array, b = p.float32Array, h = p.uint32Array, v = p.uint16Array, x = a * 2, _ = t * 2, T = Mt(x, m), E = Mt(_, v);
  let A = false;
  if (E && T)
    d ? A = s(
      Rt(t, h),
      Nt(t * 2, v),
      Rt(a, g),
      Nt(a * 2, m),
      l,
      o + t,
      n,
      r + a
    ) : A = s(
      Rt(a, g),
      Nt(a * 2, m),
      Rt(t, h),
      Nt(t * 2, v),
      n,
      r + a,
      l,
      o + t
    );
  else if (E) {
    const z = ue.getPrimitive();
    wt(t, b, z), z.applyMatrix4(e);
    const D = Vt(a), I = Ht(a, g);
    wt(D, u, ze), wt(I, u, ke);
    const U = z.intersectsBox(ze), C = z.intersectsBox(ke);
    A = U && jt(
      t,
      D,
      i,
      e,
      s,
      o,
      r,
      l,
      n + 1,
      z,
      !d
    ) || C && jt(
      t,
      I,
      i,
      e,
      s,
      o,
      r,
      l,
      n + 1,
      z,
      !d
    ), ue.releasePrimitive(z);
  } else {
    const z = Vt(t), D = Ht(t, h);
    wt(z, b, os), wt(D, b, as);
    const I = c.intersectsBox(os), U = c.intersectsBox(as);
    if (I && U)
      A = jt(
        a,
        z,
        e,
        i,
        s,
        r,
        o,
        n,
        l + 1,
        c,
        d
      ) || jt(
        a,
        D,
        e,
        i,
        s,
        r,
        o,
        n,
        l + 1,
        c,
        d
      );
    else if (I)
      if (T)
        A = jt(
          a,
          z,
          e,
          i,
          s,
          r,
          o,
          n,
          l + 1,
          c,
          d
        );
      else {
        const C = ue.getPrimitive();
        C.copy(os).applyMatrix4(e);
        const k = Vt(a), w = Ht(a, g);
        wt(k, u, ze), wt(w, u, ke);
        const M = C.intersectsBox(ze), J = C.intersectsBox(ke);
        A = M && jt(
          z,
          k,
          i,
          e,
          s,
          o,
          r,
          l,
          n + 1,
          C,
          !d
        ) || J && jt(
          z,
          w,
          i,
          e,
          s,
          o,
          r,
          l,
          n + 1,
          C,
          !d
        ), ue.releasePrimitive(C);
      }
    else if (U)
      if (T)
        A = jt(
          a,
          D,
          e,
          i,
          s,
          r,
          o,
          n,
          l + 1,
          c,
          d
        );
      else {
        const C = ue.getPrimitive();
        C.copy(as).applyMatrix4(e);
        const k = Vt(a), w = Ht(a, g);
        wt(k, u, ze), wt(w, u, ke);
        const M = C.intersectsBox(ze), J = C.intersectsBox(ke);
        A = M && jt(
          D,
          k,
          i,
          e,
          s,
          o,
          r,
          l,
          n + 1,
          C,
          !d
        ) || J && jt(
          D,
          w,
          i,
          e,
          s,
          o,
          r,
          l,
          n + 1,
          C,
          !d
        ), ue.releasePrimitive(C);
      }
  }
  return A;
}
var Di = new kt();
var ar = new Box3();
var Os = class _Os {
  static serialize(t, e = {}) {
    e = {
      cloneBuffers: true,
      ...e
    };
    const i = t.geometry, s = t._roots, r = t._indirectBuffer, o = i.getIndex();
    let n;
    return e.cloneBuffers ? n = {
      roots: s.map((l) => l.slice()),
      index: o.array.slice(),
      indirectBuffer: r ? r.slice() : null
    } : n = {
      roots: s,
      index: o.array,
      indirectBuffer: r
    }, n;
  }
  static deserialize(t, e, i = {}) {
    i = {
      setIndex: true,
      indirect: !!t.indirectBuffer,
      ...i
    };
    const { index: s, roots: r, indirectBuffer: o } = t, n = new _Os(e, { ...i, [ts]: true });
    if (n._roots = r, n._indirectBuffer = o || null, i.setIndex) {
      const l = e.getIndex();
      if (l === null) {
        const c = new BufferAttribute(t.index, 1, false);
        e.setIndex(c);
      } else
        l.array !== s && (l.array.set(s), l.needsUpdate = true);
    }
    return n;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(t, e = {}) {
    if (t.isBufferGeometry) {
      if (t.index && t.index.isInterleavedBufferAttribute)
        throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    } else
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    if (e = Object.assign({
      strategy: Ur,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [ts]: false
    }, e), e.useSharedArrayBuffer && !Vo())
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    this.geometry = t, this._roots = null, this._indirectBuffer = null, e[ts] || (ro(this, e), !t.boundingBox && e.setBoundingBox && (t.boundingBox = this.getBoundingBox(new Box3())));
    const { _indirectBuffer: i } = this;
    this.resolveTriangleIndex = e.indirect ? (s) => i[s] : (s) => s;
  }
  refit(t = null) {
    return (this.indirect ? zo : yo)(this, t);
  }
  traverse(t, e = 0) {
    const i = this._roots[e], s = new Uint32Array(i), r = new Uint16Array(i);
    o(0);
    function o(n, l = 0) {
      const c = n * 2, d = r[c + 15] === Ui;
      if (d) {
        const f = s[n + 6], p = r[c + 14];
        t(l, d, new Float32Array(i, n * 4, 6), f, p);
      } else {
        const f = n + ki / 4, p = s[n + 6], u = s[n + 7];
        t(l, d, new Float32Array(i, n * 4, 6), u) || (o(f, l + 1), o(p, l + 1));
      }
    }
  }
  /* Core Cast Functions */
  raycast(t, e = FrontSide) {
    const i = this._roots, s = this.geometry, r = [], o = e.isMaterial, n = Array.isArray(e), l = s.groups, c = o ? e.side : e, d = this.indirect ? ko : _o;
    for (let f = 0, p = i.length; f < p; f++) {
      const u = n ? e[l[f].materialIndex].side : c, g = r.length;
      if (d(this, f, u, t, r), n) {
        const m = l[f].materialIndex;
        for (let b = g, h = r.length; b < h; b++)
          r[b].face.materialIndex = m;
      }
    }
    return r;
  }
  raycastFirst(t, e = FrontSide) {
    const i = this._roots, s = this.geometry, r = e.isMaterial, o = Array.isArray(e);
    let n = null;
    const l = s.groups, c = r ? e.side : e, d = this.indirect ? Io : Co;
    for (let f = 0, p = i.length; f < p; f++) {
      const u = o ? e[l[f].materialIndex].side : c, g = d(this, f, u, t);
      g != null && (n == null || g.distance < n.distance) && (n = g, o && (g.face.materialIndex = l[f].materialIndex));
    }
    return n;
  }
  intersectsGeometry(t, e) {
    let i = false;
    const s = this._roots, r = this.indirect ? Mo : So;
    for (let o = 0, n = s.length; o < n && (i = r(this, o, t, e), !i); o++)
      ;
    return i;
  }
  shapecast(t) {
    const e = Ut.getPrimitive(), i = this.indirect ? xo : vo;
    let {
      boundsTraverseOrder: s,
      intersectsBounds: r,
      intersectsRange: o,
      intersectsTriangle: n
    } = t;
    if (o && n) {
      const f = o;
      o = (p, u, g, m, b) => f(p, u, g, m, b) ? true : i(p, u, this, n, g, m, e);
    } else
      o || (n ? o = (f, p, u, g) => i(f, p, this, n, u, g, e) : o = (f, p, u) => u);
    let l = false, c = 0;
    const d = this._roots;
    for (let f = 0, p = d.length; f < p; f++) {
      const u = d[f];
      if (l = ho(this, f, r, o, s, c), l)
        break;
      c += u.byteLength;
    }
    return Ut.releasePrimitive(e), l;
  }
  bvhcast(t, e, i) {
    let {
      intersectsRanges: s,
      intersectsTriangles: r
    } = i;
    const o = Ut.getPrimitive(), n = this.geometry.index, l = this.geometry.attributes.position, c = this.indirect ? (g) => {
      const m = this.resolveTriangleIndex(g);
      Ct(o, m * 3, n, l);
    } : (g) => {
      Ct(o, g * 3, n, l);
    }, d = Ut.getPrimitive(), f = t.geometry.index, p = t.geometry.attributes.position, u = t.indirect ? (g) => {
      const m = t.resolveTriangleIndex(g);
      Ct(d, m * 3, f, p);
    } : (g) => {
      Ct(d, g * 3, f, p);
    };
    if (r) {
      const g = (m, b, h, v, x, _, T, E) => {
        for (let A = h, z = h + v; A < z; A++) {
          u(A), d.a.applyMatrix4(e), d.b.applyMatrix4(e), d.c.applyMatrix4(e), d.needsUpdate = true;
          for (let D = m, I = m + b; D < I; D++)
            if (c(D), o.needsUpdate = true, r(o, d, D, A, x, _, T, E))
              return true;
        }
        return false;
      };
      if (s) {
        const m = s;
        s = function(b, h, v, x, _, T, E, A) {
          return m(b, h, v, x, _, T, E, A) ? true : g(b, h, v, x, _, T, E, A);
        };
      } else
        s = g;
    }
    return Ho(this, t, e, s);
  }
  /* Derived Cast Functions */
  intersectsBox(t, e) {
    return Di.set(t.min, t.max, e), Di.needsUpdate = true, this.shapecast(
      {
        intersectsBounds: (i) => Di.intersectsBox(i),
        intersectsTriangle: (i) => Di.intersectsTriangle(i)
      }
    );
  }
  intersectsSphere(t) {
    return this.shapecast(
      {
        intersectsBounds: (e) => t.intersectsBox(e),
        intersectsTriangle: (e) => e.intersectsSphere(t)
      }
    );
  }
  closestPointToGeometry(t, e, i = {}, s = {}, r = 0, o = 1 / 0) {
    return (this.indirect ? No : Po)(
      this,
      t,
      e,
      i,
      s,
      r,
      o
    );
  }
  closestPointToPoint(t, e = {}, i = 0, s = 1 / 0) {
    return uo(
      this,
      t,
      e,
      i,
      s
    );
  }
  getBoundingBox(t) {
    return t.makeEmpty(), this._roots.forEach((i) => {
      wt(0, new Float32Array(i), ar), t.union(ar);
    }), t;
  }
};
function lr(a, t, e) {
  return a === null || (a.point.applyMatrix4(t.matrixWorld), a.distance = a.point.distanceTo(e.ray.origin), a.object = t, a.distance < e.near || a.distance > e.far) ? null : a;
}
var cs = new Ray();
var cr = new Matrix4();
var Zo = Mesh.prototype.raycast;
function Wo(a, t) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    cr.copy(this.matrixWorld).invert(), cs.copy(a.ray).applyMatrix4(cr);
    const e = this.geometry.boundsTree;
    if (a.firstHitOnly === true) {
      const i = lr(e.raycastFirst(cs, this.material), this, a);
      i && t.push(i);
    } else {
      const i = e.raycast(cs, this.material);
      for (let s = 0, r = i.length; s < r; s++) {
        const o = lr(i[s], this, a);
        o && t.push(o);
      }
    }
  } else
    Zo.call(this, a, t);
}
function Yo(a) {
  return this.boundsTree = new Os(this, a), this.boundsTree;
}
function jo() {
  this.boundsTree = null;
}
var Qo = class Zr {
  constructor() {
    P(this, "onDisposed", new it()), P(this, "list", /* @__PURE__ */ new Map()), P(this, "enabled", false), P(this, "_clock"), P(this, "onInit", new it()), P(this, "update", () => {
      if (!this.enabled)
        return;
      const t = this._clock.getDelta();
      for (const [e, i] of this.list)
        i.enabled && i.isUpdateable() && i.update(t);
      requestAnimationFrame(this.update);
    }), this._clock = new Clock(), Zr.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  add(t, e) {
    if (this.list.has(t))
      throw new Error(
        "You're trying to add a component that already exists in the components instance. Use Components.get() instead."
      );
    Le.validate(t), this.list.set(t, e);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  get(t) {
    const e = t.uuid;
    if (!this.list.has(e)) {
      const i = new t(this);
      return this.list.has(e) || this.add(e, i), i;
    }
    return this.list.get(e);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   */
  init() {
    this.enabled = true, this._clock.start(), this.update(), this.onInit.trigger();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    for (const [t, e] of this.list)
      e.enabled = false, e.isDisposeable() && e.dispose();
    this._clock.stop(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = Yo, BufferGeometry.prototype.disposeBoundsTree = jo, Mesh.prototype.raycast = Wo;
  }
};
P(Qo, "release", "2.4.3");
var Go = class {
  constructor(t) {
    P(this, "_event"), P(this, "_position", new Vector2()), P(this, "onDisposed", new it()), P(this, "updateMouseInfo", (e) => {
      this._event = e;
    }), this.dom = t, this.setupEvents(true);
  }
  /**
   * The real position of the mouse or touch of the Three.js canvas.
   */
  get position() {
    return this.updatePosition(false), this._position.clone();
  }
  /**
   * The raw position of the mouse or touch of the Three.js canvas.
   */
  get rawPosition() {
    return this.updatePosition(true), this._position.clone();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  updatePosition(t) {
    if (this._event) {
      const e = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(e, this._event, t), this._position.y = this.getPositionY(e, this._event, t);
    }
  }
  getPositionY(t, e, i) {
    const s = this.getDataObject(e);
    return i ? s.clientY : -((s.clientY - t.top) / (t.bottom - t.top)) * 2 + 1;
  }
  getPositionX(t, e, i) {
    const s = this.getDataObject(e);
    return i ? s.clientX : (s.clientX - t.left) / (t.right - t.left) * 2 - 1;
  }
  getDataObject(t) {
    return t instanceof MouseEvent ? t : t.touches[0];
  }
  setupEvents(t) {
    t ? (this.dom.addEventListener("pointermove", this.updateMouseInfo), this.dom.addEventListener("touchstart", this.updateMouseInfo)) : (this.dom.removeEventListener("pointermove", this.updateMouseInfo), this.dom.removeEventListener("touchstart", this.updateMouseInfo));
  }
};
var Wr = class Yr extends Zt {
  constructor(t) {
    super(t), P(this, "onDisposed", new it()), P(this, "onFragmentsLoaded", new it()), P(this, "onFragmentsDisposed", new it()), P(this, "baseCoordinationModel", ""), P(this, "baseCoordinationMatrix", new Matrix4()), P(this, "enabled", true), P(this, "initialized", false), P(this, "_core"), this.components.add(Yr.uuid, this);
  }
  /**
   * Map containing all loaded fragment models.
   * The key is the group's unique identifier, and the value is the model itself.
   */
  get list() {
    return this.core.models.list;
  }
  get core() {
    if (!this._core)
      throw new Error("FragmentsManager not initialized. Call init() first.");
    return this._core;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.core.dispose(), this.baseCoordinationModel = "", this.onFragmentsLoaded.reset(), this.onFragmentsDisposed.reset(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  init(t) {
    this._core = new ss(t), this.initialized = true;
  }
  // /**
  //  * Gets a map of model IDs to sets of express IDs for the given fragment ID map.
  //  * @param fragmentIdMap - A map of fragment IDs to their corresponding express IDs.
  //  * @returns A map of model IDs to sets of express IDs.
  //  */
  // getModelIdMap(fragmentIdMap: FRAGS.FragmentIdMap) {
  //   const map: { [modelID: string]: Set<number> } = {};
  //   for (const fragmentID in fragmentIdMap) {
  //     const fragment = this.list.get(fragmentID);
  //     if (!(fragment && fragment.group)) continue;
  //     const model = fragment.group;
  //     if (!(model.uuid in map)) map[model.uuid] = new Set();
  //     const expressIDs = fragmentIdMap[fragmentID];
  //     for (const expressID of expressIDs) {
  //       map[model.uuid].add(expressID);
  //     }
  //   }
  //   return map;
  // }
  // /**
  //  * Converts a map of model IDs to sets of express IDs to a fragment ID map.
  //  * @param modelIdMap - A map of model IDs to their corresponding express IDs.
  //  * @returns A fragment ID map.
  //  * @remarks
  //  * This method iterates through the provided model ID map, retrieves the corresponding model from the `groups` map,
  //  * and then calls the `getFragmentMap` method of the model to obtain a fragment ID map for the given express IDs.
  //  * The fragment ID maps are then merged into a single map and returned.
  //  * If a model with a given ID is not found in the `groups` map, the method skips that model and continues with the next one.
  //  */
  // modelIdToFragmentIdMap(modelIdMap: { [modelID: string]: Set<number> }) {
  //   let fragmentIdMap: FRAGS.FragmentIdMap = {};
  //   for (const modelID in modelIdMap) {
  //     const model = this.groups.get(modelID);
  //     if (!model) continue;
  //     const expressIDs = modelIdMap[modelID];
  //     const map = model.getFragmentMap(expressIDs);
  //     fragmentIdMap = { ...fragmentIdMap, ...map };
  //   }
  //   return fragmentIdMap;
  // }
  // /**
  //  * Converts a collection of IFC GUIDs to a fragmentIdMap.
  //  *
  //  * @param guids - An iterable collection of global IDs to be converted to a fragment ID map.
  //  *
  //  * @returns A fragment ID map, where the keys are fragment IDs and the values are the corresponding express IDs.
  //  */
  // guidToFragmentIdMap(guids: Iterable<string>) {
  //   const modelIdMap: { [modelID: string]: Set<number> } = {};
  //   for (const [id, model] of this.groups) {
  //     if (!(id in modelIdMap)) modelIdMap[id] = new Set();
  //     for (const globalId of guids) {
  //       const expressID = model.globalToExpressIDs.get(globalId);
  //       if (expressID) modelIdMap[id].add(expressID);
  //     }
  //   }
  //   const fragmentIdMap = this.modelIdToFragmentIdMap(modelIdMap);
  //   return fragmentIdMap;
  // }
  // /**
  //  * Converts a fragment ID map to a collection of IFC GUIDs.
  //  *
  //  * @param fragmentIdMap - A fragment ID map to be converted to a collection of IFC GUIDs.
  //  *
  //  * @returns An array of IFC GUIDs.
  //  */
  // fragmentIdMapToGuids(fragmentIdMap: FRAGS.FragmentIdMap) {
  //   const guids: string[] = [];
  //   const modelIdMap = this.getModelIdMap(fragmentIdMap);
  //   for (const modelID in modelIdMap) {
  //     const model = this.groups.get(modelID);
  //     if (!model) continue;
  //     const expressIDs = modelIdMap[modelID];
  //     for (const expressID of expressIDs) {
  //       for (const [guid, id] of model.globalToExpressIDs.entries()) {
  //         if (id === expressID) {
  //           guids.push(guid);
  //           break;
  //         }
  //       }
  //     }
  //   }
  //   return guids;
  // }
  // /**
  //  * Applies coordinate transformation to the provided models.
  //  * If no models are provided, all groups are used.
  //  * The first model in the list becomes the base model for coordinate transformation.
  //  * All other models are then transformed to match the base model's coordinate system.
  //  *
  //  * @param models - The models to apply coordinate transformation to.
  //  * If not provided, all models are used.
  //  */
  // coordinate(models = Array.from(this.groups.values())) {
  //   const isFirstModel = this.baseCoordinationModel.length === 0;
  //   if (isFirstModel) {
  //     const first = models.pop();
  //     if (!first) {
  //       return;
  //     }
  //     this.baseCoordinationModel = first.uuid;
  //     this.baseCoordinationMatrix = first.coordinationMatrix.clone();
  //   }
  //   if (!models.length) {
  //     return;
  //   }
  //   for (const model of models) {
  //     if (model.coordinationMatrix.equals(this.baseCoordinationMatrix)) {
  //       continue;
  //     }
  //     model.position.set(0, 0, 0);
  //     model.rotation.set(0, 0, 0);
  //     model.scale.set(1, 1, 1);
  //     model.updateMatrix();
  //     this.applyBaseCoordinateSystem(model, model.coordinationMatrix);
  //   }
  // }
  // /**
  //  * Applies the base coordinate system to the provided object.
  //  *
  //  * This function takes an object and its original coordinate system as input.
  //  * It then inverts the original coordinate system and applies the base coordinate system
  //  * to the object. This ensures that the object's position, rotation, and scale are
  //  * transformed to match the base coordinate system (which is taken from the first model loaded).
  //  *
  //  * @param object - The object to which the base coordinate system will be applied.
  //  * This should be an instance of THREE.Object3D.
  //  *
  //  * @param originalCoordinateSystem - The original coordinate system of the object.
  //  * This should be a THREE.Matrix4 representing the object's transformation matrix.
  //  */
  // applyBaseCoordinateSystem(
  //   object: THREE.Object3D | THREE.Vector3,
  //   originalCoordinateSystem?: THREE.Matrix4,
  // ) {
  //   if (originalCoordinateSystem) {
  //     object.applyMatrix4(originalCoordinateSystem.clone().invert());
  //   }
  //   object.applyMatrix4(this.baseCoordinationMatrix);
  // }
  // /**
  //  * Creates a copy of the whole model or a part of it.
  //  *
  //  * @param model - The model to clone.
  //  * @param items - Optional - The part of the model to be cloned. If not given, the whole group is cloned.
  //  *
  //  */
  // clone(model: FRAGS.FragmentsGroup, items?: FRAGS.FragmentIdMap) {
  //   const clone = model.cloneGroup(items);
  //   this.groups.set(clone.uuid, clone);
  //   for (const frag of clone.items) {
  //     this.list.set(frag.id, frag);
  //   }
  //   return clone;
  // }
};
P(Wr, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
var It = Wr;
var Ko = class {
  constructor(t, e) {
    P(this, "enabled", true), P(this, "components"), P(this, "onDisposed", new it()), P(this, "mouse"), P(this, "three", new Raycaster()), P(this, "world");
    const i = e.renderer;
    if (!i)
      throw new Error("A renderer is needed for the raycaster to work!");
    this.world = e, this.mouse = new Go(i.three.domElement), this.components = t;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   * @param position - the screen position to use for raycasting. If not provided,
   * the last pointer (mouse/touch) position will be used.
   */
  async castRay(t = Array.from(this.world.meshes), e = this.mouse.position) {
    if (!this.world)
      throw new Error("A world is needed to cast rays!");
    const i = this.world.camera.three, s = this.components.get(It), r = this.world.renderer.three.domElement, o = this.mouse.rawPosition, n = await s.core.pick({ camera: i, dom: r, mouse: o });
    if (t.length === 0)
      return n;
    this.three.setFromCamera(e, i);
    const l = this.intersect(t);
    return n ? l && l.distance < n.distance ? l : n : l;
  }
  // /**
  //  * Casts a ray from a given origin in a given direction and returns the first item found.
  //  * This method also takes into account the clipping planes used by the renderer.
  //  *
  //  * @param origin - The origin of the ray.
  //  * @param direction - The direction of the ray.
  //  * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
  //  * @returns The first intersection found or `null` if no intersection was found.
  //  */
  // castRayFromVector(
  //   origin: THREE.Vector3,
  //   direction: THREE.Vector3,
  //   items = Array.from(this.world.meshes),
  // ) {
  //   // TODO: Implement for fragmentsmodel
  //   this.three.set(origin, direction);
  //   return this.intersect(items);
  // }
  intersect(t = Array.from(this.world.meshes)) {
    const e = this.three.intersectObjects(t), i = this.filterClippingPlanes(e);
    return i.length > 0 ? i[0] : null;
  }
  filterClippingPlanes(t) {
    if (!this.world.renderer)
      throw new Error("Renderer not found!");
    const e = this.world.renderer.three;
    if (!e.clippingPlanes)
      return t;
    const i = e.clippingPlanes;
    return t.length <= 0 || !i || (i == null ? void 0 : i.length) <= 0 ? t : t.filter(
      (s) => i.every((r) => r.distanceToPoint(s.point) > 0)
    );
  }
};
var jr = class Qr extends Zt {
  constructor(t) {
    super(t), P(this, "enabled", true), P(this, "list", /* @__PURE__ */ new Map()), P(this, "onDisposed", new it()), t.add(Qr.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(t) {
    if (this.list.has(t.uuid))
      return this.list.get(t.uuid);
    const e = new Ko(this.components, t);
    return this.list.set(t.uuid, e), t.onDisposed.add(() => {
      this.delete(t);
    }), e;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(t) {
    const e = this.list.get(t.uuid);
    e && e.dispose(), this.list.delete(t.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [t, e] of this.list)
      e.dispose();
    this.list.clear(), this.onDisposed.trigger();
  }
};
P(jr, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
var Xo = jr;
var qo = class {
  constructor(t) {
    P(this, "enabled", false), P(this, "id", "FirstPerson"), this.camera = t;
  }
  /** {@link NavigationMode.set} */
  set(t) {
    if (this.enabled = t, t) {
      if (this.camera.projection.current !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const t = this.camera.controls, e = new Vector3();
    t.distance--, t.getPosition(e), t.minDistance = 1, t.maxDistance = 1, t.distance = 1, t.moveTo(
      e.x,
      e.y,
      e.z
    ), t.truckSpeed = 50, t.mouseButtons.wheel = Dt.ACTION.DOLLY, t.touches.two = Dt.ACTION.TOUCH_ZOOM_TRUCK;
  }
};
var Jo = class {
  constructor(t) {
    P(this, "enabled", true), P(this, "id", "Orbit"), this.camera = t, this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(t) {
    this.enabled = t, t && this.activateOrbitControls();
  }
  activateOrbitControls() {
    const t = this.camera.controls;
    t.minDistance = 1, t.maxDistance = 300;
    const e = new Vector3();
    t.getPosition(e);
    const i = e.length();
    t.distance = i, t.truckSpeed = 2;
    const { rotation: s } = this.camera.three, r = new Vector3(0, 0, -1).applyEuler(s), o = e.addScaledVector(r, i);
    t.moveTo(o.x, o.y, o.z);
  }
};
var $o = class {
  constructor(t) {
    P(this, "enabled", false), P(this, "id", "Plan"), P(this, "mouseAction1"), P(this, "mouseAction2"), P(this, "mouseInitialized", false), P(this, "defaultAzimuthSpeed"), P(this, "defaultPolarSpeed"), this.camera = t, this.defaultAzimuthSpeed = t.controls.azimuthRotateSpeed, this.defaultPolarSpeed = t.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(t) {
    this.enabled = t;
    const e = this.camera.controls;
    e.azimuthRotateSpeed = t ? 0 : this.defaultAzimuthSpeed, e.polarRotateSpeed = t ? 0 : this.defaultPolarSpeed, this.mouseInitialized || (this.mouseAction1 = e.touches.one, this.mouseAction2 = e.touches.two, this.mouseInitialized = true), t ? (e.mouseButtons.left = Dt.ACTION.TRUCK, e.touches.one = Dt.ACTION.TOUCH_TRUCK, e.touches.two = Dt.ACTION.TOUCH_ZOOM) : (e.mouseButtons.left = Dt.ACTION.ROTATE, e.touches.one = this.mouseAction1, e.touches.two = this.mouseAction2);
  }
};
var ta = class {
  constructor(t) {
    P(this, "onChanged", new it()), P(this, "current", "Perspective"), P(this, "camera"), P(this, "matchOrthoDistanceEnabled", false), P(this, "_component"), P(this, "_previousDistance", -1), this._component = t, this.camera = t.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(t) {
    this.current !== t && (t === "Orthographic" ? this.setOrthoCamera() : await this.setPerspectiveCamera(), this.onChanged.trigger(this.camera));
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const e = this.current === "Perspective" ? "Orthographic" : "Perspective";
    await this.set(e);
  }
  setOrthoCamera() {
    if (this._component.mode === null || this._component.mode.id === "FirstPerson")
      return;
    this._previousDistance = this._component.controls.distance, this._component.controls.distance = 200;
    const t = this.getPerspectiveDims();
    if (!t)
      return;
    const { width: e, height: i } = t;
    this.setupOrthoCamera(i, e), this.camera = this._component.threeOrtho, this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const t = this._component.currentWorld;
    if (!t || !t.renderer)
      return null;
    const e = new Vector3();
    this._component.threePersp.getWorldDirection(e);
    const i = new Vector3();
    this._component.controls.getTarget(i);
    const r = i.clone().sub(this._component.threePersp.position).dot(e), o = t.renderer.getSize(), n = o.x / o.y, l = this._component.threePersp, c = r * 2 * Math.atan(l.fov * (Math.PI / 180) / 2);
    return { width: c * n, height: c };
  }
  setupOrthoCamera(t, e) {
    this._component.controls.mouseButtons.wheel = Dt.ACTION.ZOOM, this._component.controls.mouseButtons.middle = Dt.ACTION.ZOOM;
    const i = this._component.threePersp, s = this._component.threeOrtho;
    s.zoom = 1, s.left = e / -2, s.right = e / 2, s.top = t / 2, s.bottom = t / -2, s.updateProjectionMatrix(), s.position.copy(i.position), s.quaternion.copy(i.quaternion), this._component.controls.camera = s;
  }
  getDistance() {
    const t = this._component.threePersp, e = this._component.threeOrtho;
    return (e.top - e.bottom) / e.zoom / (2 * Math.atan(t.fov * (Math.PI / 180) / 2));
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = Dt.ACTION.DOLLY, this._component.controls.mouseButtons.middle = Dt.ACTION.DOLLY;
    const t = this._component.threePersp, e = this._component.threeOrtho;
    t.position.copy(e.position), t.quaternion.copy(e.quaternion), this._component.controls.mouseButtons.wheel = Dt.ACTION.DOLLY, this.matchOrthoDistanceEnabled ? this._component.controls.distance = this.getDistance() : this._component.controls.distance = this._previousDistance, await this._component.controls.zoomTo(1), t.updateProjectionMatrix(), this._component.controls.camera = t, this.camera = t, this.current = "Perspective";
  }
};
var ea = class extends ai {
  constructor(t) {
    super(t), P(this, "projection"), P(this, "threeOrtho"), P(this, "threePersp"), P(this, "_userInputButtons", {}), P(this, "_frustumSize", 50), P(this, "_navigationModes", /* @__PURE__ */ new Map()), P(this, "_mode", null), P(this, "previousSize", null), this.threePersp = this.three, this.threeOrtho = this.newOrthoCamera(), this.projection = new ta(this), this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    }), this.projection.onChanged.add(
      (e) => {
        this.three = e, this.updateAspect();
      }
    ), this.onWorldChanged.add(({ action: e }) => {
      e === "added" && (this._navigationModes.clear(), this._navigationModes.set("Orbit", new Jo(this)), this._navigationModes.set("FirstPerson", new qo(this)), this._navigationModes.set("Plan", new $o(this)), this._mode = this._navigationModes.get("Orbit"), this.mode.set(true, { preventTargetAdjustment: true }), this.currentWorld && this.currentWorld.renderer && (this.previousSize = this.currentWorld.renderer.getSize().clone()));
    });
  }
  /**
   * Getter for the current navigation mode.
   * Throws an error if the mode is not found or the camera is not initialized.
   *
   * @returns {NavigationMode} The current navigation mode.
   *
   * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
   */
  get mode() {
    if (!this._mode)
      throw new Error("Mode not found, camera not initialized");
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose(), this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(t) {
    if (this.mode !== null && this.mode.id !== t) {
      if (this.mode.set(false), !this._navigationModes.has(t))
        throw new Error("The specified mode does not exist!");
      this._mode = this._navigationModes.get(t), this.mode.set(true);
    }
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(t, e = 1.5) {
    if (!this.enabled)
      return;
    const i = Number.MAX_VALUE, s = Number.MIN_VALUE, r = new Vector3(i, i, i), o = new Vector3(s, s, s);
    for (const p of t) {
      const u = new Box3().setFromObject(p);
      u.min.x < r.x && (r.x = u.min.x), u.min.y < r.y && (r.y = u.min.y), u.min.z < r.z && (r.z = u.min.z), u.max.x > o.x && (o.x = u.max.x), u.max.y > o.y && (o.y = u.max.y), u.max.z > o.z && (o.z = u.max.z);
    }
    const n = new Box3(r, o), l = new Vector3();
    n.getSize(l);
    const c = new Vector3();
    n.getCenter(c);
    const d = Math.max(l.x, l.y, l.z) * e, f = new Sphere(c, d);
    await this.controls.fitToSphere(f, true);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(t) {
    t ? this.enableUserInput() : this.disableUserInput();
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left, this._userInputButtons.right = this.controls.mouseButtons.right, this._userInputButtons.middle = this.controls.mouseButtons.middle, this._userInputButtons.wheel = this.controls.mouseButtons.wheel, this.controls.mouseButtons.left = 0, this.controls.mouseButtons.right = 0, this.controls.mouseButtons.middle = 0, this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    Object.keys(this._userInputButtons).length !== 0 && (this.controls.mouseButtons.left = this._userInputButtons.left, this.controls.mouseButtons.right = this._userInputButtons.right, this.controls.mouseButtons.middle = this._userInputButtons.middle, this.controls.mouseButtons.wheel = this._userInputButtons.wheel);
  }
  newOrthoCamera() {
    const t = window.innerWidth / window.innerHeight;
    return new OrthographicCamera(
      this._frustumSize * t / -2,
      this._frustumSize * t / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer || !this.previousSize)
      return;
    const t = this.currentWorld.renderer.getSize(), e = this.threeOrtho.top, i = this.threeOrtho.right, s = t.y / this.previousSize.y, r = t.x / this.previousSize.x, o = e * s, n = i * r;
    this.threeOrtho.left = -n, this.threeOrtho.right = n, this.threeOrtho.top = o, this.threeOrtho.bottom = -o, this.threeOrtho.updateProjectionMatrix(), this.previousSize.copy(t);
  }
};
var Pi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ia(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
function zi(a) {
  throw new Error('Could not dynamically require "' + a + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Gr = { exports: {} };
(function(a, t) {
  (function(e) {
    a.exports = e();
  })(function() {
    return function e(i, s, r) {
      function o(c, d) {
        if (!s[c]) {
          if (!i[c]) {
            var f = typeof zi == "function" && zi;
            if (!d && f)
              return f(c, true);
            if (n)
              return n(c, true);
            var p = new Error("Cannot find module '" + c + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var u = s[c] = { exports: {} };
          i[c][0].call(u.exports, function(g) {
            var m = i[c][1][g];
            return o(m || g);
          }, u, u.exports, e, i, s, r);
        }
        return s[c].exports;
      }
      for (var n = typeof zi == "function" && zi, l = 0; l < r.length; l++)
        o(r[l]);
      return o;
    }({ 1: [function(e, i, s) {
      var r = e("./utils"), o = e("./support"), n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      s.encode = function(l) {
        for (var c, d, f, p, u, g, m, b = [], h = 0, v = l.length, x = v, _ = r.getTypeOf(l) !== "string"; h < l.length; )
          x = v - h, f = _ ? (c = l[h++], d = h < v ? l[h++] : 0, h < v ? l[h++] : 0) : (c = l.charCodeAt(h++), d = h < v ? l.charCodeAt(h++) : 0, h < v ? l.charCodeAt(h++) : 0), p = c >> 2, u = (3 & c) << 4 | d >> 4, g = 1 < x ? (15 & d) << 2 | f >> 6 : 64, m = 2 < x ? 63 & f : 64, b.push(n.charAt(p) + n.charAt(u) + n.charAt(g) + n.charAt(m));
        return b.join("");
      }, s.decode = function(l) {
        var c, d, f, p, u, g, m = 0, b = 0, h = "data:";
        if (l.substr(0, h.length) === h)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var v, x = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === n.charAt(64) && x--, l.charAt(l.length - 2) === n.charAt(64) && x--, x % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (v = o.uint8array ? new Uint8Array(0 | x) : new Array(0 | x); m < l.length; )
          c = n.indexOf(l.charAt(m++)) << 2 | (p = n.indexOf(l.charAt(m++))) >> 4, d = (15 & p) << 4 | (u = n.indexOf(l.charAt(m++))) >> 2, f = (3 & u) << 6 | (g = n.indexOf(l.charAt(m++))), v[b++] = c, u !== 64 && (v[b++] = d), g !== 64 && (v[b++] = f);
        return v;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, i, s) {
      var r = e("./external"), o = e("./stream/DataWorker"), n = e("./stream/Crc32Probe"), l = e("./stream/DataLengthProbe");
      function c(d, f, p, u, g) {
        this.compressedSize = d, this.uncompressedSize = f, this.crc32 = p, this.compression = u, this.compressedContent = g;
      }
      c.prototype = { getContentWorker: function() {
        var d = new o(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), f = this;
        return d.on("end", function() {
          if (this.streamInfo.data_length !== f.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), d;
      }, getCompressedWorker: function() {
        return new o(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(d, f, p) {
        return d.pipe(new n()).pipe(new l("uncompressedSize")).pipe(f.compressWorker(p)).pipe(new l("compressedSize")).withStreamInfo("compression", f);
      }, i.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, i, s) {
      var r = e("./stream/GenericWorker");
      s.STORE = { magic: "\0\0", compressWorker: function() {
        return new r("STORE compression");
      }, uncompressWorker: function() {
        return new r("STORE decompression");
      } }, s.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, i, s) {
      var r = e("./utils"), o = function() {
        for (var n, l = [], c = 0; c < 256; c++) {
          n = c;
          for (var d = 0; d < 8; d++)
            n = 1 & n ? 3988292384 ^ n >>> 1 : n >>> 1;
          l[c] = n;
        }
        return l;
      }();
      i.exports = function(n, l) {
        return n !== void 0 && n.length ? r.getTypeOf(n) !== "string" ? function(c, d, f, p) {
          var u = o, g = p + f;
          c ^= -1;
          for (var m = p; m < g; m++)
            c = c >>> 8 ^ u[255 & (c ^ d[m])];
          return -1 ^ c;
        }(0 | l, n, n.length, 0) : function(c, d, f, p) {
          var u = o, g = p + f;
          c ^= -1;
          for (var m = p; m < g; m++)
            c = c >>> 8 ^ u[255 & (c ^ d.charCodeAt(m))];
          return -1 ^ c;
        }(0 | l, n, n.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, i, s) {
      s.base64 = false, s.binary = false, s.dir = false, s.createFolders = true, s.date = null, s.compression = null, s.compressionOptions = null, s.comment = null, s.unixPermissions = null, s.dosPermissions = null;
    }, {}], 6: [function(e, i, s) {
      var r = null;
      r = typeof Promise < "u" ? Promise : e("lie"), i.exports = { Promise: r };
    }, { lie: 37 }], 7: [function(e, i, s) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = e("pako"), n = e("./utils"), l = e("./stream/GenericWorker"), c = r ? "uint8array" : "array";
      function d(f, p) {
        l.call(this, "FlateWorker/" + f), this._pako = null, this._pakoAction = f, this._pakoOptions = p, this.meta = {};
      }
      s.magic = "\b\0", n.inherits(d, l), d.prototype.processChunk = function(f) {
        this.meta = f.meta, this._pako === null && this._createPako(), this._pako.push(n.transformTo(c, f.data), false);
      }, d.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], true);
      }, d.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, d.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var f = this;
        this._pako.onData = function(p) {
          f.push({ data: p, meta: f.meta });
        };
      }, s.compressWorker = function(f) {
        return new d("Deflate", f);
      }, s.uncompressWorker = function() {
        return new d("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, i, s) {
      function r(u, g) {
        var m, b = "";
        for (m = 0; m < g; m++)
          b += String.fromCharCode(255 & u), u >>>= 8;
        return b;
      }
      function o(u, g, m, b, h, v) {
        var x, _, T = u.file, E = u.compression, A = v !== c.utf8encode, z = n.transformTo("string", v(T.name)), D = n.transformTo("string", c.utf8encode(T.name)), I = T.comment, U = n.transformTo("string", v(I)), C = n.transformTo("string", c.utf8encode(I)), k = D.length !== T.name.length, w = C.length !== I.length, M = "", J = "", Z = "", nt = T.dir, j = T.date, at = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        g && !m || (at.crc32 = u.crc32, at.compressedSize = u.compressedSize, at.uncompressedSize = u.uncompressedSize);
        var N = 0;
        g && (N |= 8), A || !k && !w || (N |= 2048);
        var F = 0, rt = 0;
        nt && (F |= 16), h === "UNIX" ? (rt = 798, F |= function(q, bt) {
          var Ot = q;
          return q || (Ot = bt ? 16893 : 33204), (65535 & Ot) << 16;
        }(T.unixPermissions, nt)) : (rt = 20, F |= function(q) {
          return 63 & (q || 0);
        }(T.dosPermissions)), x = j.getUTCHours(), x <<= 6, x |= j.getUTCMinutes(), x <<= 5, x |= j.getUTCSeconds() / 2, _ = j.getUTCFullYear() - 1980, _ <<= 4, _ |= j.getUTCMonth() + 1, _ <<= 5, _ |= j.getUTCDate(), k && (J = r(1, 1) + r(d(z), 4) + D, M += "up" + r(J.length, 2) + J), w && (Z = r(1, 1) + r(d(U), 4) + C, M += "uc" + r(Z.length, 2) + Z);
        var $ = "";
        return $ += `
\0`, $ += r(N, 2), $ += E.magic, $ += r(x, 2), $ += r(_, 2), $ += r(at.crc32, 4), $ += r(at.compressedSize, 4), $ += r(at.uncompressedSize, 4), $ += r(z.length, 2), $ += r(M.length, 2), { fileRecord: f.LOCAL_FILE_HEADER + $ + z + M, dirRecord: f.CENTRAL_FILE_HEADER + r(rt, 2) + $ + r(U.length, 2) + "\0\0\0\0" + r(F, 4) + r(b, 4) + z + M + U };
      }
      var n = e("../utils"), l = e("../stream/GenericWorker"), c = e("../utf8"), d = e("../crc32"), f = e("../signature");
      function p(u, g, m, b) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = m, this.encodeFileName = b, this.streamFiles = u, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      n.inherits(p, l), p.prototype.push = function(u) {
        var g = u.meta.percent || 0, m = this.entriesCount, b = this._sources.length;
        this.accumulate ? this.contentBuffer.push(u) : (this.bytesWritten += u.data.length, l.prototype.push.call(this, { data: u.data, meta: { currentFile: this.currentFile, percent: m ? (g + 100 * (m - b - 1)) / m : 100 } }));
      }, p.prototype.openedSource = function(u) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = u.file.name;
        var g = this.streamFiles && !u.file.dir;
        if (g) {
          var m = o(u, g, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: m.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, p.prototype.closedSource = function(u) {
        this.accumulate = false;
        var g = this.streamFiles && !u.file.dir, m = o(u, g, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(m.dirRecord), g)
          this.push({ data: function(b) {
            return f.DATA_DESCRIPTOR + r(b.crc32, 4) + r(b.compressedSize, 4) + r(b.uncompressedSize, 4);
          }(u), meta: { percent: 100 } });
        else
          for (this.push({ data: m.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var u = this.bytesWritten, g = 0; g < this.dirRecords.length; g++)
          this.push({ data: this.dirRecords[g], meta: { percent: 100 } });
        var m = this.bytesWritten - u, b = function(h, v, x, _, T) {
          var E = n.transformTo("string", T(_));
          return f.CENTRAL_DIRECTORY_END + "\0\0\0\0" + r(h, 2) + r(h, 2) + r(v, 4) + r(x, 4) + r(E.length, 2) + E;
        }(this.dirRecords.length, m, u, this.zipComment, this.encodeFileName);
        this.push({ data: b, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(u) {
        this._sources.push(u);
        var g = this;
        return u.on("data", function(m) {
          g.processChunk(m);
        }), u.on("end", function() {
          g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
        }), u.on("error", function(m) {
          g.error(m);
        }), this;
      }, p.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, p.prototype.error = function(u) {
        var g = this._sources;
        if (!l.prototype.error.call(this, u))
          return false;
        for (var m = 0; m < g.length; m++)
          try {
            g[m].error(u);
          } catch {
          }
        return true;
      }, p.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var u = this._sources, g = 0; g < u.length; g++)
          u[g].lock();
      }, i.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, i, s) {
      var r = e("../compressions"), o = e("./ZipFileWorker");
      s.generateWorker = function(n, l, c) {
        var d = new o(l.streamFiles, c, l.platform, l.encodeFileName), f = 0;
        try {
          n.forEach(function(p, u) {
            f++;
            var g = function(v, x) {
              var _ = v || x, T = r[_];
              if (!T)
                throw new Error(_ + " is not a valid compression method !");
              return T;
            }(u.options.compression, l.compression), m = u.options.compressionOptions || l.compressionOptions || {}, b = u.dir, h = u.date;
            u._compressWorker(g, m).withStreamInfo("file", { name: p, dir: b, date: h, comment: u.comment || "", unixPermissions: u.unixPermissions, dosPermissions: u.dosPermissions }).pipe(d);
          }), d.entriesCount = f;
        } catch (p) {
          d.error(p);
        }
        return d;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, i, s) {
      function r() {
        if (!(this instanceof r))
          return new r();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new r();
          for (var n in this)
            typeof this[n] != "function" && (o[n] = this[n]);
          return o;
        };
      }
      (r.prototype = e("./object")).loadAsync = e("./load"), r.support = e("./support"), r.defaults = e("./defaults"), r.version = "3.10.1", r.loadAsync = function(o, n) {
        return new r().loadAsync(o, n);
      }, r.external = e("./external"), i.exports = r;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, i, s) {
      var r = e("./utils"), o = e("./external"), n = e("./utf8"), l = e("./zipEntries"), c = e("./stream/Crc32Probe"), d = e("./nodejsUtils");
      function f(p) {
        return new o.Promise(function(u, g) {
          var m = p.decompressed.getContentWorker().pipe(new c());
          m.on("error", function(b) {
            g(b);
          }).on("end", function() {
            m.streamInfo.crc32 !== p.decompressed.crc32 ? g(new Error("Corrupted zip : CRC32 mismatch")) : u();
          }).resume();
        });
      }
      i.exports = function(p, u) {
        var g = this;
        return u = r.extend(u || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), d.isNode && d.isStream(p) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : r.prepareContent("the loaded zip file", p, true, u.optimizedBinaryString, u.base64).then(function(m) {
          var b = new l(u);
          return b.load(m), b;
        }).then(function(m) {
          var b = [o.Promise.resolve(m)], h = m.files;
          if (u.checkCRC32)
            for (var v = 0; v < h.length; v++)
              b.push(f(h[v]));
          return o.Promise.all(b);
        }).then(function(m) {
          for (var b = m.shift(), h = b.files, v = 0; v < h.length; v++) {
            var x = h[v], _ = x.fileNameStr, T = r.resolve(x.fileNameStr);
            g.file(T, x.decompressed, { binary: true, optimizedBinaryString: true, date: x.date, dir: x.dir, comment: x.fileCommentStr.length ? x.fileCommentStr : null, unixPermissions: x.unixPermissions, dosPermissions: x.dosPermissions, createFolders: u.createFolders }), x.dir || (g.file(T).unsafeOriginalName = _);
          }
          return b.zipComment.length && (g.comment = b.zipComment), g;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, i, s) {
      var r = e("../utils"), o = e("../stream/GenericWorker");
      function n(l, c) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = false, this._bindStream(c);
      }
      r.inherits(n, o), n.prototype._bindStream = function(l) {
        var c = this;
        (this._stream = l).pause(), l.on("data", function(d) {
          c.push({ data: d, meta: { percent: 0 } });
        }).on("error", function(d) {
          c.isPaused ? this.generatedError = d : c.error(d);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = true : c.end();
        });
      }, n.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), true);
      }, n.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, i.exports = n;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, i, s) {
      var r = e("readable-stream").Readable;
      function o(n, l, c) {
        r.call(this, l), this._helper = n;
        var d = this;
        n.on("data", function(f, p) {
          d.push(f) || d._helper.pause(), c && c(p);
        }).on("error", function(f) {
          d.emit("error", f);
        }).on("end", function() {
          d.push(null);
        });
      }
      e("../utils").inherits(o, r), o.prototype._read = function() {
        this._helper.resume();
      }, i.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, i, s) {
      i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(r, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(r, o);
        if (typeof r == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(r, o);
      }, allocBuffer: function(r) {
        if (Buffer.alloc)
          return Buffer.alloc(r);
        var o = new Buffer(r);
        return o.fill(0), o;
      }, isBuffer: function(r) {
        return Buffer.isBuffer(r);
      }, isStream: function(r) {
        return r && typeof r.on == "function" && typeof r.pause == "function" && typeof r.resume == "function";
      } };
    }, {}], 15: [function(e, i, s) {
      function r(T, E, A) {
        var z, D = n.getTypeOf(E), I = n.extend(A || {}, d);
        I.date = I.date || /* @__PURE__ */ new Date(), I.compression !== null && (I.compression = I.compression.toUpperCase()), typeof I.unixPermissions == "string" && (I.unixPermissions = parseInt(I.unixPermissions, 8)), I.unixPermissions && 16384 & I.unixPermissions && (I.dir = true), I.dosPermissions && 16 & I.dosPermissions && (I.dir = true), I.dir && (T = h(T)), I.createFolders && (z = b(T)) && v.call(this, z, true);
        var U = D === "string" && I.binary === false && I.base64 === false;
        A && A.binary !== void 0 || (I.binary = !U), (E instanceof f && E.uncompressedSize === 0 || I.dir || !E || E.length === 0) && (I.base64 = false, I.binary = true, E = "", I.compression = "STORE", D = "string");
        var C = null;
        C = E instanceof f || E instanceof l ? E : g.isNode && g.isStream(E) ? new m(T, E) : n.prepareContent(T, E, I.binary, I.optimizedBinaryString, I.base64);
        var k = new p(T, C, I);
        this.files[T] = k;
      }
      var o = e("./utf8"), n = e("./utils"), l = e("./stream/GenericWorker"), c = e("./stream/StreamHelper"), d = e("./defaults"), f = e("./compressedObject"), p = e("./zipObject"), u = e("./generate"), g = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), b = function(T) {
        T.slice(-1) === "/" && (T = T.substring(0, T.length - 1));
        var E = T.lastIndexOf("/");
        return 0 < E ? T.substring(0, E) : "";
      }, h = function(T) {
        return T.slice(-1) !== "/" && (T += "/"), T;
      }, v = function(T, E) {
        return E = E !== void 0 ? E : d.createFolders, T = h(T), this.files[T] || r.call(this, T, null, { dir: true, createFolders: E }), this.files[T];
      };
      function x(T) {
        return Object.prototype.toString.call(T) === "[object RegExp]";
      }
      var _ = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(T) {
        var E, A, z;
        for (E in this.files)
          z = this.files[E], (A = E.slice(this.root.length, E.length)) && E.slice(0, this.root.length) === this.root && T(A, z);
      }, filter: function(T) {
        var E = [];
        return this.forEach(function(A, z) {
          T(A, z) && E.push(z);
        }), E;
      }, file: function(T, E, A) {
        if (arguments.length !== 1)
          return T = this.root + T, r.call(this, T, E, A), this;
        if (x(T)) {
          var z = T;
          return this.filter(function(I, U) {
            return !U.dir && z.test(I);
          });
        }
        var D = this.files[this.root + T];
        return D && !D.dir ? D : null;
      }, folder: function(T) {
        if (!T)
          return this;
        if (x(T))
          return this.filter(function(D, I) {
            return I.dir && T.test(D);
          });
        var E = this.root + T, A = v.call(this, E), z = this.clone();
        return z.root = A.name, z;
      }, remove: function(T) {
        T = this.root + T;
        var E = this.files[T];
        if (E || (T.slice(-1) !== "/" && (T += "/"), E = this.files[T]), E && !E.dir)
          delete this.files[T];
        else
          for (var A = this.filter(function(D, I) {
            return I.name.slice(0, T.length) === T;
          }), z = 0; z < A.length; z++)
            delete this.files[A[z].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(T) {
        var E, A = {};
        try {
          if ((A = n.extend(T || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = A.type.toLowerCase(), A.compression = A.compression.toUpperCase(), A.type === "binarystring" && (A.type = "string"), !A.type)
            throw new Error("No output type specified.");
          n.checkSupport(A.type), A.platform !== "darwin" && A.platform !== "freebsd" && A.platform !== "linux" && A.platform !== "sunos" || (A.platform = "UNIX"), A.platform === "win32" && (A.platform = "DOS");
          var z = A.comment || this.comment || "";
          E = u.generateWorker(this, A, z);
        } catch (D) {
          (E = new l("error")).error(D);
        }
        return new c(E, A.type || "string", A.mimeType);
      }, generateAsync: function(T, E) {
        return this.generateInternalStream(T).accumulate(E);
      }, generateNodeStream: function(T, E) {
        return (T = T || {}).type || (T.type = "nodebuffer"), this.generateInternalStream(T).toNodejsStream(E);
      } };
      i.exports = _;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, i, s) {
      i.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, i, s) {
      var r = e("./DataReader");
      function o(n) {
        r.call(this, n);
        for (var l = 0; l < this.data.length; l++)
          n[l] = 255 & n[l];
      }
      e("../utils").inherits(o, r), o.prototype.byteAt = function(n) {
        return this.data[this.zero + n];
      }, o.prototype.lastIndexOfSignature = function(n) {
        for (var l = n.charCodeAt(0), c = n.charCodeAt(1), d = n.charCodeAt(2), f = n.charCodeAt(3), p = this.length - 4; 0 <= p; --p)
          if (this.data[p] === l && this.data[p + 1] === c && this.data[p + 2] === d && this.data[p + 3] === f)
            return p - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(n) {
        var l = n.charCodeAt(0), c = n.charCodeAt(1), d = n.charCodeAt(2), f = n.charCodeAt(3), p = this.readData(4);
        return l === p[0] && c === p[1] && d === p[2] && f === p[3];
      }, o.prototype.readData = function(n) {
        if (this.checkOffset(n), n === 0)
          return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + n);
        return this.index += n, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, i, s) {
      var r = e("../utils");
      function o(n) {
        this.data = n, this.length = n.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(n) {
        this.checkIndex(this.index + n);
      }, checkIndex: function(n) {
        if (this.length < this.zero + n || n < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + n + "). Corrupted zip ?");
      }, setIndex: function(n) {
        this.checkIndex(n), this.index = n;
      }, skip: function(n) {
        this.setIndex(this.index + n);
      }, byteAt: function() {
      }, readInt: function(n) {
        var l, c = 0;
        for (this.checkOffset(n), l = this.index + n - 1; l >= this.index; l--)
          c = (c << 8) + this.byteAt(l);
        return this.index += n, c;
      }, readString: function(n) {
        return r.transformTo("string", this.readData(n));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var n = this.readInt(4);
        return new Date(Date.UTC(1980 + (n >> 25 & 127), (n >> 21 & 15) - 1, n >> 16 & 31, n >> 11 & 31, n >> 5 & 63, (31 & n) << 1));
      } }, i.exports = o;
    }, { "../utils": 32 }], 19: [function(e, i, s) {
      var r = e("./Uint8ArrayReader");
      function o(n) {
        r.call(this, n);
      }
      e("../utils").inherits(o, r), o.prototype.readData = function(n) {
        this.checkOffset(n);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + n);
        return this.index += n, l;
      }, i.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, i, s) {
      var r = e("./DataReader");
      function o(n) {
        r.call(this, n);
      }
      e("../utils").inherits(o, r), o.prototype.byteAt = function(n) {
        return this.data.charCodeAt(this.zero + n);
      }, o.prototype.lastIndexOfSignature = function(n) {
        return this.data.lastIndexOf(n) - this.zero;
      }, o.prototype.readAndCheckSignature = function(n) {
        return n === this.readData(4);
      }, o.prototype.readData = function(n) {
        this.checkOffset(n);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + n);
        return this.index += n, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, i, s) {
      var r = e("./ArrayReader");
      function o(n) {
        r.call(this, n);
      }
      e("../utils").inherits(o, r), o.prototype.readData = function(n) {
        if (this.checkOffset(n), n === 0)
          return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + n);
        return this.index += n, l;
      }, i.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, i, s) {
      var r = e("../utils"), o = e("../support"), n = e("./ArrayReader"), l = e("./StringReader"), c = e("./NodeBufferReader"), d = e("./Uint8ArrayReader");
      i.exports = function(f) {
        var p = r.getTypeOf(f);
        return r.checkSupport(p), p !== "string" || o.uint8array ? p === "nodebuffer" ? new c(f) : o.uint8array ? new d(r.transformTo("uint8array", f)) : new n(r.transformTo("array", f)) : new l(f);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, i, s) {
      s.LOCAL_FILE_HEADER = "PK", s.CENTRAL_FILE_HEADER = "PK", s.CENTRAL_DIRECTORY_END = "PK", s.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", s.ZIP64_CENTRAL_DIRECTORY_END = "PK", s.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, i, s) {
      var r = e("./GenericWorker"), o = e("../utils");
      function n(l) {
        r.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(n, r), n.prototype.processChunk = function(l) {
        this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
      }, i.exports = n;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, i, s) {
      var r = e("./GenericWorker"), o = e("../crc32");
      function n() {
        r.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(n, r), n.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, i.exports = n;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, i, s) {
      var r = e("../utils"), o = e("./GenericWorker");
      function n(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      r.inherits(n, o), n.prototype.processChunk = function(l) {
        if (l) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, i.exports = n;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, i, s) {
      var r = e("../utils"), o = e("./GenericWorker");
      function n(l) {
        o.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, l.then(function(d) {
          c.dataIsReady = true, c.data = d, c.max = d && d.length || 0, c.type = r.getTypeOf(d), c.isPaused || c._tickAndRepeat();
        }, function(d) {
          c.error(d);
        });
      }
      r.inherits(n, o), n.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, n.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, r.delay(this._tickAndRepeat, [], this)), true);
      }, n.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (r.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, n.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var l = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, c);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, i.exports = n;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, i, s) {
      function r(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      r.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (o) {
          this.emit("error", o);
        }
        return true;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = true, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), true);
      }, on: function(o, n) {
        return this._listeners[o].push(n), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, n) {
        if (this._listeners[o])
          for (var l = 0; l < this._listeners[o].length; l++)
            this._listeners[o][l].call(this, n);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var n = this;
        return o.on("data", function(l) {
          n.processChunk(l);
        }), o.on("end", function() {
          n.end();
        }), o.on("error", function(l) {
          n.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var o = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), o = true), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, n) {
        return this.extraStreamInfo[o] = n, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, i.exports = r;
    }, {}], 29: [function(e, i, s) {
      var r = e("../utils"), o = e("./ConvertWorker"), n = e("./GenericWorker"), l = e("../base64"), c = e("../support"), d = e("../external"), f = null;
      if (c.nodestream)
        try {
          f = e("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function p(g, m) {
        return new d.Promise(function(b, h) {
          var v = [], x = g._internalType, _ = g._outputType, T = g._mimeType;
          g.on("data", function(E, A) {
            v.push(E), m && m(A);
          }).on("error", function(E) {
            v = [], h(E);
          }).on("end", function() {
            try {
              var E = function(A, z, D) {
                switch (A) {
                  case "blob":
                    return r.newBlob(r.transformTo("arraybuffer", z), D);
                  case "base64":
                    return l.encode(z);
                  default:
                    return r.transformTo(A, z);
                }
              }(_, function(A, z) {
                var D, I = 0, U = null, C = 0;
                for (D = 0; D < z.length; D++)
                  C += z[D].length;
                switch (A) {
                  case "string":
                    return z.join("");
                  case "array":
                    return Array.prototype.concat.apply([], z);
                  case "uint8array":
                    for (U = new Uint8Array(C), D = 0; D < z.length; D++)
                      U.set(z[D], I), I += z[D].length;
                    return U;
                  case "nodebuffer":
                    return Buffer.concat(z);
                  default:
                    throw new Error("concat : unsupported type '" + A + "'");
                }
              }(x, v), T);
              b(E);
            } catch (A) {
              h(A);
            }
            v = [];
          }).resume();
        });
      }
      function u(g, m, b) {
        var h = m;
        switch (m) {
          case "blob":
          case "arraybuffer":
            h = "uint8array";
            break;
          case "base64":
            h = "string";
        }
        try {
          this._internalType = h, this._outputType = m, this._mimeType = b, r.checkSupport(h), this._worker = g.pipe(new o(h)), g.lock();
        } catch (v) {
          this._worker = new n("error"), this._worker.error(v);
        }
      }
      u.prototype = { accumulate: function(g) {
        return p(this, g);
      }, on: function(g, m) {
        var b = this;
        return g === "data" ? this._worker.on(g, function(h) {
          m.call(b, h.data, h.meta);
        }) : this._worker.on(g, function() {
          r.delay(m, arguments, b);
        }), this;
      }, resume: function() {
        return r.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(g) {
        if (r.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new f(this, { objectMode: this._outputType !== "nodebuffer" }, g);
      } }, i.exports = u;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, i, s) {
      if (s.base64 = true, s.array = true, s.string = true, s.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", s.nodebuffer = typeof Buffer < "u", s.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        s.blob = false;
      else {
        var r = new ArrayBuffer(0);
        try {
          s.blob = new Blob([r], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(r), s.blob = o.getBlob("application/zip").size === 0;
          } catch {
            s.blob = false;
          }
        }
      }
      try {
        s.nodestream = !!e("readable-stream").Readable;
      } catch {
        s.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e, i, s) {
      for (var r = e("./utils"), o = e("./support"), n = e("./nodejsUtils"), l = e("./stream/GenericWorker"), c = new Array(256), d = 0; d < 256; d++)
        c[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      c[254] = c[254] = 1;
      function f() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        l.call(this, "utf-8 encode");
      }
      s.utf8encode = function(u) {
        return o.nodebuffer ? n.newBufferFrom(u, "utf-8") : function(g) {
          var m, b, h, v, x, _ = g.length, T = 0;
          for (v = 0; v < _; v++)
            (64512 & (b = g.charCodeAt(v))) == 55296 && v + 1 < _ && (64512 & (h = g.charCodeAt(v + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (h - 56320), v++), T += b < 128 ? 1 : b < 2048 ? 2 : b < 65536 ? 3 : 4;
          for (m = o.uint8array ? new Uint8Array(T) : new Array(T), v = x = 0; x < T; v++)
            (64512 & (b = g.charCodeAt(v))) == 55296 && v + 1 < _ && (64512 & (h = g.charCodeAt(v + 1))) == 56320 && (b = 65536 + (b - 55296 << 10) + (h - 56320), v++), b < 128 ? m[x++] = b : (b < 2048 ? m[x++] = 192 | b >>> 6 : (b < 65536 ? m[x++] = 224 | b >>> 12 : (m[x++] = 240 | b >>> 18, m[x++] = 128 | b >>> 12 & 63), m[x++] = 128 | b >>> 6 & 63), m[x++] = 128 | 63 & b);
          return m;
        }(u);
      }, s.utf8decode = function(u) {
        return o.nodebuffer ? r.transformTo("nodebuffer", u).toString("utf-8") : function(g) {
          var m, b, h, v, x = g.length, _ = new Array(2 * x);
          for (m = b = 0; m < x; )
            if ((h = g[m++]) < 128)
              _[b++] = h;
            else if (4 < (v = c[h]))
              _[b++] = 65533, m += v - 1;
            else {
              for (h &= v === 2 ? 31 : v === 3 ? 15 : 7; 1 < v && m < x; )
                h = h << 6 | 63 & g[m++], v--;
              1 < v ? _[b++] = 65533 : h < 65536 ? _[b++] = h : (h -= 65536, _[b++] = 55296 | h >> 10 & 1023, _[b++] = 56320 | 1023 & h);
            }
          return _.length !== b && (_.subarray ? _ = _.subarray(0, b) : _.length = b), r.applyFromCharCode(_);
        }(u = r.transformTo(o.uint8array ? "uint8array" : "array", u));
      }, r.inherits(f, l), f.prototype.processChunk = function(u) {
        var g = r.transformTo(o.uint8array ? "uint8array" : "array", u.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var m = g;
            (g = new Uint8Array(m.length + this.leftOver.length)).set(this.leftOver, 0), g.set(m, this.leftOver.length);
          } else
            g = this.leftOver.concat(g);
          this.leftOver = null;
        }
        var b = function(v, x) {
          var _;
          for ((x = x || v.length) > v.length && (x = v.length), _ = x - 1; 0 <= _ && (192 & v[_]) == 128; )
            _--;
          return _ < 0 || _ === 0 ? x : _ + c[v[_]] > x ? _ : x;
        }(g), h = g;
        b !== g.length && (o.uint8array ? (h = g.subarray(0, b), this.leftOver = g.subarray(b, g.length)) : (h = g.slice(0, b), this.leftOver = g.slice(b, g.length))), this.push({ data: s.utf8decode(h), meta: u.meta });
      }, f.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = f, r.inherits(p, l), p.prototype.processChunk = function(u) {
        this.push({ data: s.utf8encode(u.data), meta: u.meta });
      }, s.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, i, s) {
      var r = e("./support"), o = e("./base64"), n = e("./nodejsUtils"), l = e("./external");
      function c(m) {
        return m;
      }
      function d(m, b) {
        for (var h = 0; h < m.length; ++h)
          b[h] = 255 & m.charCodeAt(h);
        return b;
      }
      e("setimmediate"), s.newBlob = function(m, b) {
        s.checkSupport("blob");
        try {
          return new Blob([m], { type: b });
        } catch {
          try {
            var h = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return h.append(m), h.getBlob(b);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var f = { stringifyByChunk: function(m, b, h) {
        var v = [], x = 0, _ = m.length;
        if (_ <= h)
          return String.fromCharCode.apply(null, m);
        for (; x < _; )
          b === "array" || b === "nodebuffer" ? v.push(String.fromCharCode.apply(null, m.slice(x, Math.min(x + h, _)))) : v.push(String.fromCharCode.apply(null, m.subarray(x, Math.min(x + h, _)))), x += h;
        return v.join("");
      }, stringifyByChar: function(m) {
        for (var b = "", h = 0; h < m.length; h++)
          b += String.fromCharCode(m[h]);
        return b;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return r.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return r.nodebuffer && String.fromCharCode.apply(null, n.allocBuffer(1)).length === 1;
        } catch {
          return false;
        }
      }() } };
      function p(m) {
        var b = 65536, h = s.getTypeOf(m), v = true;
        if (h === "uint8array" ? v = f.applyCanBeUsed.uint8array : h === "nodebuffer" && (v = f.applyCanBeUsed.nodebuffer), v)
          for (; 1 < b; )
            try {
              return f.stringifyByChunk(m, h, b);
            } catch {
              b = Math.floor(b / 2);
            }
        return f.stringifyByChar(m);
      }
      function u(m, b) {
        for (var h = 0; h < m.length; h++)
          b[h] = m[h];
        return b;
      }
      s.applyFromCharCode = p;
      var g = {};
      g.string = { string: c, array: function(m) {
        return d(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return g.string.uint8array(m).buffer;
      }, uint8array: function(m) {
        return d(m, new Uint8Array(m.length));
      }, nodebuffer: function(m) {
        return d(m, n.allocBuffer(m.length));
      } }, g.array = { string: p, array: c, arraybuffer: function(m) {
        return new Uint8Array(m).buffer;
      }, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return n.newBufferFrom(m);
      } }, g.arraybuffer = { string: function(m) {
        return p(new Uint8Array(m));
      }, array: function(m) {
        return u(new Uint8Array(m), new Array(m.byteLength));
      }, arraybuffer: c, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return n.newBufferFrom(new Uint8Array(m));
      } }, g.uint8array = { string: p, array: function(m) {
        return u(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return m.buffer;
      }, uint8array: c, nodebuffer: function(m) {
        return n.newBufferFrom(m);
      } }, g.nodebuffer = { string: p, array: function(m) {
        return u(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return g.nodebuffer.uint8array(m).buffer;
      }, uint8array: function(m) {
        return u(m, new Uint8Array(m.length));
      }, nodebuffer: c }, s.transformTo = function(m, b) {
        if (b = b || "", !m)
          return b;
        s.checkSupport(m);
        var h = s.getTypeOf(b);
        return g[h][m](b);
      }, s.resolve = function(m) {
        for (var b = m.split("/"), h = [], v = 0; v < b.length; v++) {
          var x = b[v];
          x === "." || x === "" && v !== 0 && v !== b.length - 1 || (x === ".." ? h.pop() : h.push(x));
        }
        return h.join("/");
      }, s.getTypeOf = function(m) {
        return typeof m == "string" ? "string" : Object.prototype.toString.call(m) === "[object Array]" ? "array" : r.nodebuffer && n.isBuffer(m) ? "nodebuffer" : r.uint8array && m instanceof Uint8Array ? "uint8array" : r.arraybuffer && m instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, s.checkSupport = function(m) {
        if (!r[m.toLowerCase()])
          throw new Error(m + " is not supported by this platform");
      }, s.MAX_VALUE_16BITS = 65535, s.MAX_VALUE_32BITS = -1, s.pretty = function(m) {
        var b, h, v = "";
        for (h = 0; h < (m || "").length; h++)
          v += "\\x" + ((b = m.charCodeAt(h)) < 16 ? "0" : "") + b.toString(16).toUpperCase();
        return v;
      }, s.delay = function(m, b, h) {
        setImmediate(function() {
          m.apply(h || null, b || []);
        });
      }, s.inherits = function(m, b) {
        function h() {
        }
        h.prototype = b.prototype, m.prototype = new h();
      }, s.extend = function() {
        var m, b, h = {};
        for (m = 0; m < arguments.length; m++)
          for (b in arguments[m])
            Object.prototype.hasOwnProperty.call(arguments[m], b) && h[b] === void 0 && (h[b] = arguments[m][b]);
        return h;
      }, s.prepareContent = function(m, b, h, v, x) {
        return l.Promise.resolve(b).then(function(_) {
          return r.blob && (_ instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(_)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(T, E) {
            var A = new FileReader();
            A.onload = function(z) {
              T(z.target.result);
            }, A.onerror = function(z) {
              E(z.target.error);
            }, A.readAsArrayBuffer(_);
          }) : _;
        }).then(function(_) {
          var T = s.getTypeOf(_);
          return T ? (T === "arraybuffer" ? _ = s.transformTo("uint8array", _) : T === "string" && (x ? _ = o.decode(_) : h && v !== true && (_ = function(E) {
            return d(E, r.uint8array ? new Uint8Array(E.length) : new Array(E.length));
          }(_))), _) : l.Promise.reject(new Error("Can't read the data of '" + m + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, i, s) {
      var r = e("./reader/readerFor"), o = e("./utils"), n = e("./signature"), l = e("./zipEntry"), c = e("./support");
      function d(f) {
        this.files = [], this.loadOptions = f;
      }
      d.prototype = { checkSignature: function(f) {
        if (!this.reader.readAndCheckSignature(f)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(p) + ", expected " + o.pretty(f) + ")");
        }
      }, isSignature: function(f, p) {
        var u = this.reader.index;
        this.reader.setIndex(f);
        var g = this.reader.readString(4) === p;
        return this.reader.setIndex(u), g;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var f = this.reader.readData(this.zipCommentLength), p = c.uint8array ? "uint8array" : "array", u = o.transformTo(p, f);
        this.zipComment = this.loadOptions.decodeFileName(u);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var f, p, u, g = this.zip64EndOfCentralSize - 44; 0 < g; )
          f = this.reader.readInt(2), p = this.reader.readInt(4), u = this.reader.readData(p), this.zip64ExtensibleData[f] = { id: f, length: p, value: u };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var f, p;
        for (f = 0; f < this.files.length; f++)
          p = this.files[f], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(n.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var f;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(n.CENTRAL_FILE_HEADER); )
          (f = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(f);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var f = this.reader.lastIndexOfSignature(n.CENTRAL_DIRECTORY_END);
        if (f < 0)
          throw this.isSignature(0, n.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(f);
        var p = f;
        if (this.checkSignature(n.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (f = this.reader.lastIndexOfSignature(n.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(f), this.checkSignature(n.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, n.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(n.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(n.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var u = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (u += 20, u += 12 + this.zip64EndOfCentralSize);
        var g = p - u;
        if (0 < g)
          this.isSignature(p, n.CENTRAL_FILE_HEADER) || (this.reader.zero = g);
        else if (g < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(g) + " bytes.");
      }, prepareReader: function(f) {
        this.reader = r(f);
      }, load: function(f) {
        this.prepareReader(f), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, i.exports = d;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, i, s) {
      var r = e("./reader/readerFor"), o = e("./utils"), n = e("./compressedObject"), l = e("./crc32"), c = e("./utf8"), d = e("./compressions"), f = e("./support");
      function p(u, g) {
        this.options = u, this.loadOptions = g;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(u) {
        var g, m;
        if (u.skip(22), this.fileNameLength = u.readInt(2), m = u.readInt(2), this.fileName = u.readData(this.fileNameLength), u.skip(m), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((g = function(b) {
          for (var h in d)
            if (Object.prototype.hasOwnProperty.call(d, h) && d[h].magic === b)
              return d[h];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new n(this.compressedSize, this.uncompressedSize, this.crc32, g, u.readData(this.compressedSize));
      }, readCentralPart: function(u) {
        this.versionMadeBy = u.readInt(2), u.skip(2), this.bitFlag = u.readInt(2), this.compressionMethod = u.readString(2), this.date = u.readDate(), this.crc32 = u.readInt(4), this.compressedSize = u.readInt(4), this.uncompressedSize = u.readInt(4);
        var g = u.readInt(2);
        if (this.extraFieldsLength = u.readInt(2), this.fileCommentLength = u.readInt(2), this.diskNumberStart = u.readInt(2), this.internalFileAttributes = u.readInt(2), this.externalFileAttributes = u.readInt(4), this.localHeaderOffset = u.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        u.skip(g), this.readExtraFields(u), this.parseZIP64ExtraField(u), this.fileComment = u.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var u = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), u == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), u == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var u = r(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = u.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = u.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = u.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = u.readInt(4));
        }
      }, readExtraFields: function(u) {
        var g, m, b, h = u.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); u.index + 4 < h; )
          g = u.readInt(2), m = u.readInt(2), b = u.readData(m), this.extraFields[g] = { id: g, length: m, value: b };
        u.setIndex(h);
      }, handleUTF8: function() {
        var u = f.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var g = this.findExtraFieldUnicodePath();
          if (g !== null)
            this.fileNameStr = g;
          else {
            var m = o.transformTo(u, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(m);
          }
          var b = this.findExtraFieldUnicodeComment();
          if (b !== null)
            this.fileCommentStr = b;
          else {
            var h = o.transformTo(u, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(h);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var u = this.extraFields[28789];
        if (u) {
          var g = r(u.value);
          return g.readInt(1) !== 1 || l(this.fileName) !== g.readInt(4) ? null : c.utf8decode(g.readData(u.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var u = this.extraFields[25461];
        if (u) {
          var g = r(u.value);
          return g.readInt(1) !== 1 || l(this.fileComment) !== g.readInt(4) ? null : c.utf8decode(g.readData(u.length - 5));
        }
        return null;
      } }, i.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, i, s) {
      function r(g, m, b) {
        this.name = g, this.dir = b.dir, this.date = b.date, this.comment = b.comment, this.unixPermissions = b.unixPermissions, this.dosPermissions = b.dosPermissions, this._data = m, this._dataBinary = b.binary, this.options = { compression: b.compression, compressionOptions: b.compressionOptions };
      }
      var o = e("./stream/StreamHelper"), n = e("./stream/DataWorker"), l = e("./utf8"), c = e("./compressedObject"), d = e("./stream/GenericWorker");
      r.prototype = { internalStream: function(g) {
        var m = null, b = "string";
        try {
          if (!g)
            throw new Error("No output type specified.");
          var h = (b = g.toLowerCase()) === "string" || b === "text";
          b !== "binarystring" && b !== "text" || (b = "string"), m = this._decompressWorker();
          var v = !this._dataBinary;
          v && !h && (m = m.pipe(new l.Utf8EncodeWorker())), !v && h && (m = m.pipe(new l.Utf8DecodeWorker()));
        } catch (x) {
          (m = new d("error")).error(x);
        }
        return new o(m, b, "");
      }, async: function(g, m) {
        return this.internalStream(g).accumulate(m);
      }, nodeStream: function(g, m) {
        return this.internalStream(g || "nodebuffer").toNodejsStream(m);
      }, _compressWorker: function(g, m) {
        if (this._data instanceof c && this._data.compression.magic === g.magic)
          return this._data.getCompressedWorker();
        var b = this._decompressWorker();
        return this._dataBinary || (b = b.pipe(new l.Utf8EncodeWorker())), c.createWorkerFrom(b, g, m);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof d ? this._data : new n(this._data);
      } };
      for (var f = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, u = 0; u < f.length; u++)
        r.prototype[f[u]] = p;
      i.exports = r;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, i, s) {
      (function(r) {
        var o, n, l = r.MutationObserver || r.WebKitMutationObserver;
        if (l) {
          var c = 0, d = new l(g), f = r.document.createTextNode("");
          d.observe(f, { characterData: true }), o = function() {
            f.data = c = ++c % 2;
          };
        } else if (r.setImmediate || r.MessageChannel === void 0)
          o = "document" in r && "onreadystatechange" in r.document.createElement("script") ? function() {
            var m = r.document.createElement("script");
            m.onreadystatechange = function() {
              g(), m.onreadystatechange = null, m.parentNode.removeChild(m), m = null;
            }, r.document.documentElement.appendChild(m);
          } : function() {
            setTimeout(g, 0);
          };
        else {
          var p = new r.MessageChannel();
          p.port1.onmessage = g, o = function() {
            p.port2.postMessage(0);
          };
        }
        var u = [];
        function g() {
          var m, b;
          n = true;
          for (var h = u.length; h; ) {
            for (b = u, u = [], m = -1; ++m < h; )
              b[m]();
            h = u.length;
          }
          n = false;
        }
        i.exports = function(m) {
          u.push(m) !== 1 || n || o();
        };
      }).call(this, typeof Pi < "u" ? Pi : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, i, s) {
      var r = e("immediate");
      function o() {
      }
      var n = {}, l = ["REJECTED"], c = ["FULFILLED"], d = ["PENDING"];
      function f(h) {
        if (typeof h != "function")
          throw new TypeError("resolver must be a function");
        this.state = d, this.queue = [], this.outcome = void 0, h !== o && m(this, h);
      }
      function p(h, v, x) {
        this.promise = h, typeof v == "function" && (this.onFulfilled = v, this.callFulfilled = this.otherCallFulfilled), typeof x == "function" && (this.onRejected = x, this.callRejected = this.otherCallRejected);
      }
      function u(h, v, x) {
        r(function() {
          var _;
          try {
            _ = v(x);
          } catch (T) {
            return n.reject(h, T);
          }
          _ === h ? n.reject(h, new TypeError("Cannot resolve promise with itself")) : n.resolve(h, _);
        });
      }
      function g(h) {
        var v = h && h.then;
        if (h && (typeof h == "object" || typeof h == "function") && typeof v == "function")
          return function() {
            v.apply(h, arguments);
          };
      }
      function m(h, v) {
        var x = false;
        function _(A) {
          x || (x = true, n.reject(h, A));
        }
        function T(A) {
          x || (x = true, n.resolve(h, A));
        }
        var E = b(function() {
          v(T, _);
        });
        E.status === "error" && _(E.value);
      }
      function b(h, v) {
        var x = {};
        try {
          x.value = h(v), x.status = "success";
        } catch (_) {
          x.status = "error", x.value = _;
        }
        return x;
      }
      (i.exports = f).prototype.finally = function(h) {
        if (typeof h != "function")
          return this;
        var v = this.constructor;
        return this.then(function(x) {
          return v.resolve(h()).then(function() {
            return x;
          });
        }, function(x) {
          return v.resolve(h()).then(function() {
            throw x;
          });
        });
      }, f.prototype.catch = function(h) {
        return this.then(null, h);
      }, f.prototype.then = function(h, v) {
        if (typeof h != "function" && this.state === c || typeof v != "function" && this.state === l)
          return this;
        var x = new this.constructor(o);
        return this.state !== d ? u(x, this.state === c ? h : v, this.outcome) : this.queue.push(new p(x, h, v)), x;
      }, p.prototype.callFulfilled = function(h) {
        n.resolve(this.promise, h);
      }, p.prototype.otherCallFulfilled = function(h) {
        u(this.promise, this.onFulfilled, h);
      }, p.prototype.callRejected = function(h) {
        n.reject(this.promise, h);
      }, p.prototype.otherCallRejected = function(h) {
        u(this.promise, this.onRejected, h);
      }, n.resolve = function(h, v) {
        var x = b(g, v);
        if (x.status === "error")
          return n.reject(h, x.value);
        var _ = x.value;
        if (_)
          m(h, _);
        else {
          h.state = c, h.outcome = v;
          for (var T = -1, E = h.queue.length; ++T < E; )
            h.queue[T].callFulfilled(v);
        }
        return h;
      }, n.reject = function(h, v) {
        h.state = l, h.outcome = v;
        for (var x = -1, _ = h.queue.length; ++x < _; )
          h.queue[x].callRejected(v);
        return h;
      }, f.resolve = function(h) {
        return h instanceof this ? h : n.resolve(new this(o), h);
      }, f.reject = function(h) {
        var v = new this(o);
        return n.reject(v, h);
      }, f.all = function(h) {
        var v = this;
        if (Object.prototype.toString.call(h) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var x = h.length, _ = false;
        if (!x)
          return this.resolve([]);
        for (var T = new Array(x), E = 0, A = -1, z = new this(o); ++A < x; )
          D(h[A], A);
        return z;
        function D(I, U) {
          v.resolve(I).then(function(C) {
            T[U] = C, ++E !== x || _ || (_ = true, n.resolve(z, T));
          }, function(C) {
            _ || (_ = true, n.reject(z, C));
          });
        }
      }, f.race = function(h) {
        var v = this;
        if (Object.prototype.toString.call(h) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var x = h.length, _ = false;
        if (!x)
          return this.resolve([]);
        for (var T = -1, E = new this(o); ++T < x; )
          A = h[T], v.resolve(A).then(function(z) {
            _ || (_ = true, n.resolve(E, z));
          }, function(z) {
            _ || (_ = true, n.reject(E, z));
          });
        var A;
        return E;
      };
    }, { immediate: 36 }], 38: [function(e, i, s) {
      var r = {};
      (0, e("./lib/utils/common").assign)(r, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), i.exports = r;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, i, s) {
      var r = e("./zlib/deflate"), o = e("./utils/common"), n = e("./utils/strings"), l = e("./zlib/messages"), c = e("./zlib/zstream"), d = Object.prototype.toString, f = 0, p = -1, u = 0, g = 8;
      function m(h) {
        if (!(this instanceof m))
          return new m(h);
        this.options = o.assign({ level: p, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: u, to: "" }, h || {});
        var v = this.options;
        v.raw && 0 < v.windowBits ? v.windowBits = -v.windowBits : v.gzip && 0 < v.windowBits && v.windowBits < 16 && (v.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var x = r.deflateInit2(this.strm, v.level, v.method, v.windowBits, v.memLevel, v.strategy);
        if (x !== f)
          throw new Error(l[x]);
        if (v.header && r.deflateSetHeader(this.strm, v.header), v.dictionary) {
          var _;
          if (_ = typeof v.dictionary == "string" ? n.string2buf(v.dictionary) : d.call(v.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(v.dictionary) : v.dictionary, (x = r.deflateSetDictionary(this.strm, _)) !== f)
            throw new Error(l[x]);
          this._dict_set = true;
        }
      }
      function b(h, v) {
        var x = new m(v);
        if (x.push(h, true), x.err)
          throw x.msg || l[x.err];
        return x.result;
      }
      m.prototype.push = function(h, v) {
        var x, _, T = this.strm, E = this.options.chunkSize;
        if (this.ended)
          return false;
        _ = v === ~~v ? v : v === true ? 4 : 0, typeof h == "string" ? T.input = n.string2buf(h) : d.call(h) === "[object ArrayBuffer]" ? T.input = new Uint8Array(h) : T.input = h, T.next_in = 0, T.avail_in = T.input.length;
        do {
          if (T.avail_out === 0 && (T.output = new o.Buf8(E), T.next_out = 0, T.avail_out = E), (x = r.deflate(T, _)) !== 1 && x !== f)
            return this.onEnd(x), !(this.ended = true);
          T.avail_out !== 0 && (T.avail_in !== 0 || _ !== 4 && _ !== 2) || (this.options.to === "string" ? this.onData(n.buf2binstring(o.shrinkBuf(T.output, T.next_out))) : this.onData(o.shrinkBuf(T.output, T.next_out)));
        } while ((0 < T.avail_in || T.avail_out === 0) && x !== 1);
        return _ === 4 ? (x = r.deflateEnd(this.strm), this.onEnd(x), this.ended = true, x === f) : _ !== 2 || (this.onEnd(f), !(T.avail_out = 0));
      }, m.prototype.onData = function(h) {
        this.chunks.push(h);
      }, m.prototype.onEnd = function(h) {
        h === f && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = h, this.msg = this.strm.msg;
      }, s.Deflate = m, s.deflate = b, s.deflateRaw = function(h, v) {
        return (v = v || {}).raw = true, b(h, v);
      }, s.gzip = function(h, v) {
        return (v = v || {}).gzip = true, b(h, v);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, i, s) {
      var r = e("./zlib/inflate"), o = e("./utils/common"), n = e("./utils/strings"), l = e("./zlib/constants"), c = e("./zlib/messages"), d = e("./zlib/zstream"), f = e("./zlib/gzheader"), p = Object.prototype.toString;
      function u(m) {
        if (!(this instanceof u))
          return new u(m);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, m || {});
        var b = this.options;
        b.raw && 0 <= b.windowBits && b.windowBits < 16 && (b.windowBits = -b.windowBits, b.windowBits === 0 && (b.windowBits = -15)), !(0 <= b.windowBits && b.windowBits < 16) || m && m.windowBits || (b.windowBits += 32), 15 < b.windowBits && b.windowBits < 48 && !(15 & b.windowBits) && (b.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var h = r.inflateInit2(this.strm, b.windowBits);
        if (h !== l.Z_OK)
          throw new Error(c[h]);
        this.header = new f(), r.inflateGetHeader(this.strm, this.header);
      }
      function g(m, b) {
        var h = new u(b);
        if (h.push(m, true), h.err)
          throw h.msg || c[h.err];
        return h.result;
      }
      u.prototype.push = function(m, b) {
        var h, v, x, _, T, E, A = this.strm, z = this.options.chunkSize, D = this.options.dictionary, I = false;
        if (this.ended)
          return false;
        v = b === ~~b ? b : b === true ? l.Z_FINISH : l.Z_NO_FLUSH, typeof m == "string" ? A.input = n.binstring2buf(m) : p.call(m) === "[object ArrayBuffer]" ? A.input = new Uint8Array(m) : A.input = m, A.next_in = 0, A.avail_in = A.input.length;
        do {
          if (A.avail_out === 0 && (A.output = new o.Buf8(z), A.next_out = 0, A.avail_out = z), (h = r.inflate(A, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && D && (E = typeof D == "string" ? n.string2buf(D) : p.call(D) === "[object ArrayBuffer]" ? new Uint8Array(D) : D, h = r.inflateSetDictionary(this.strm, E)), h === l.Z_BUF_ERROR && I === true && (h = l.Z_OK, I = false), h !== l.Z_STREAM_END && h !== l.Z_OK)
            return this.onEnd(h), !(this.ended = true);
          A.next_out && (A.avail_out !== 0 && h !== l.Z_STREAM_END && (A.avail_in !== 0 || v !== l.Z_FINISH && v !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (x = n.utf8border(A.output, A.next_out), _ = A.next_out - x, T = n.buf2string(A.output, x), A.next_out = _, A.avail_out = z - _, _ && o.arraySet(A.output, A.output, x, _, 0), this.onData(T)) : this.onData(o.shrinkBuf(A.output, A.next_out)))), A.avail_in === 0 && A.avail_out === 0 && (I = true);
        } while ((0 < A.avail_in || A.avail_out === 0) && h !== l.Z_STREAM_END);
        return h === l.Z_STREAM_END && (v = l.Z_FINISH), v === l.Z_FINISH ? (h = r.inflateEnd(this.strm), this.onEnd(h), this.ended = true, h === l.Z_OK) : v !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(A.avail_out = 0));
      }, u.prototype.onData = function(m) {
        this.chunks.push(m);
      }, u.prototype.onEnd = function(m) {
        m === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
      }, s.Inflate = u, s.inflate = g, s.inflateRaw = function(m, b) {
        return (b = b || {}).raw = true, g(m, b);
      }, s.ungzip = g;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, i, s) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      s.assign = function(l) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var d = c.shift();
          if (d) {
            if (typeof d != "object")
              throw new TypeError(d + "must be non-object");
            for (var f in d)
              d.hasOwnProperty(f) && (l[f] = d[f]);
          }
        }
        return l;
      }, s.shrinkBuf = function(l, c) {
        return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c, l);
      };
      var o = { arraySet: function(l, c, d, f, p) {
        if (c.subarray && l.subarray)
          l.set(c.subarray(d, d + f), p);
        else
          for (var u = 0; u < f; u++)
            l[p + u] = c[d + u];
      }, flattenChunks: function(l) {
        var c, d, f, p, u, g;
        for (c = f = 0, d = l.length; c < d; c++)
          f += l[c].length;
        for (g = new Uint8Array(f), c = p = 0, d = l.length; c < d; c++)
          u = l[c], g.set(u, p), p += u.length;
        return g;
      } }, n = { arraySet: function(l, c, d, f, p) {
        for (var u = 0; u < f; u++)
          l[p + u] = c[d + u];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      s.setTyped = function(l) {
        l ? (s.Buf8 = Uint8Array, s.Buf16 = Uint16Array, s.Buf32 = Int32Array, s.assign(s, o)) : (s.Buf8 = Array, s.Buf16 = Array, s.Buf32 = Array, s.assign(s, n));
      }, s.setTyped(r);
    }, {}], 42: [function(e, i, s) {
      var r = e("./common"), o = true, n = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        n = false;
      }
      for (var l = new r.Buf8(256), c = 0; c < 256; c++)
        l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function d(f, p) {
        if (p < 65537 && (f.subarray && n || !f.subarray && o))
          return String.fromCharCode.apply(null, r.shrinkBuf(f, p));
        for (var u = "", g = 0; g < p; g++)
          u += String.fromCharCode(f[g]);
        return u;
      }
      l[254] = l[254] = 1, s.string2buf = function(f) {
        var p, u, g, m, b, h = f.length, v = 0;
        for (m = 0; m < h; m++)
          (64512 & (u = f.charCodeAt(m))) == 55296 && m + 1 < h && (64512 & (g = f.charCodeAt(m + 1))) == 56320 && (u = 65536 + (u - 55296 << 10) + (g - 56320), m++), v += u < 128 ? 1 : u < 2048 ? 2 : u < 65536 ? 3 : 4;
        for (p = new r.Buf8(v), m = b = 0; b < v; m++)
          (64512 & (u = f.charCodeAt(m))) == 55296 && m + 1 < h && (64512 & (g = f.charCodeAt(m + 1))) == 56320 && (u = 65536 + (u - 55296 << 10) + (g - 56320), m++), u < 128 ? p[b++] = u : (u < 2048 ? p[b++] = 192 | u >>> 6 : (u < 65536 ? p[b++] = 224 | u >>> 12 : (p[b++] = 240 | u >>> 18, p[b++] = 128 | u >>> 12 & 63), p[b++] = 128 | u >>> 6 & 63), p[b++] = 128 | 63 & u);
        return p;
      }, s.buf2binstring = function(f) {
        return d(f, f.length);
      }, s.binstring2buf = function(f) {
        for (var p = new r.Buf8(f.length), u = 0, g = p.length; u < g; u++)
          p[u] = f.charCodeAt(u);
        return p;
      }, s.buf2string = function(f, p) {
        var u, g, m, b, h = p || f.length, v = new Array(2 * h);
        for (u = g = 0; u < h; )
          if ((m = f[u++]) < 128)
            v[g++] = m;
          else if (4 < (b = l[m]))
            v[g++] = 65533, u += b - 1;
          else {
            for (m &= b === 2 ? 31 : b === 3 ? 15 : 7; 1 < b && u < h; )
              m = m << 6 | 63 & f[u++], b--;
            1 < b ? v[g++] = 65533 : m < 65536 ? v[g++] = m : (m -= 65536, v[g++] = 55296 | m >> 10 & 1023, v[g++] = 56320 | 1023 & m);
          }
        return d(v, g);
      }, s.utf8border = function(f, p) {
        var u;
        for ((p = p || f.length) > f.length && (p = f.length), u = p - 1; 0 <= u && (192 & f[u]) == 128; )
          u--;
        return u < 0 || u === 0 ? p : u + l[f[u]] > p ? u : p;
      };
    }, { "./common": 41 }], 43: [function(e, i, s) {
      i.exports = function(r, o, n, l) {
        for (var c = 65535 & r | 0, d = r >>> 16 & 65535 | 0, f = 0; n !== 0; ) {
          for (n -= f = 2e3 < n ? 2e3 : n; d = d + (c = c + o[l++] | 0) | 0, --f; )
            ;
          c %= 65521, d %= 65521;
        }
        return c | d << 16 | 0;
      };
    }, {}], 44: [function(e, i, s) {
      i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, i, s) {
      var r = function() {
        for (var o, n = [], l = 0; l < 256; l++) {
          o = l;
          for (var c = 0; c < 8; c++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          n[l] = o;
        }
        return n;
      }();
      i.exports = function(o, n, l, c) {
        var d = r, f = c + l;
        o ^= -1;
        for (var p = c; p < f; p++)
          o = o >>> 8 ^ d[255 & (o ^ n[p])];
        return -1 ^ o;
      };
    }, {}], 46: [function(e, i, s) {
      var r, o = e("../utils/common"), n = e("./trees"), l = e("./adler32"), c = e("./crc32"), d = e("./messages"), f = 0, p = 4, u = 0, g = -2, m = -1, b = 4, h = 2, v = 8, x = 9, _ = 286, T = 30, E = 19, A = 2 * _ + 1, z = 15, D = 3, I = 258, U = I + D + 1, C = 42, k = 113, w = 1, M = 2, J = 3, Z = 4;
      function nt(y, H) {
        return y.msg = d[H], H;
      }
      function j(y) {
        return (y << 1) - (4 < y ? 9 : 0);
      }
      function at(y) {
        for (var H = y.length; 0 <= --H; )
          y[H] = 0;
      }
      function N(y) {
        var H = y.state, V = H.pending;
        V > y.avail_out && (V = y.avail_out), V !== 0 && (o.arraySet(y.output, H.pending_buf, H.pending_out, V, y.next_out), y.next_out += V, H.pending_out += V, y.total_out += V, y.avail_out -= V, H.pending -= V, H.pending === 0 && (H.pending_out = 0));
      }
      function F(y, H) {
        n._tr_flush_block(y, 0 <= y.block_start ? y.block_start : -1, y.strstart - y.block_start, H), y.block_start = y.strstart, N(y.strm);
      }
      function rt(y, H) {
        y.pending_buf[y.pending++] = H;
      }
      function $(y, H) {
        y.pending_buf[y.pending++] = H >>> 8 & 255, y.pending_buf[y.pending++] = 255 & H;
      }
      function q(y, H) {
        var V, O, S = y.max_chain_length, B = y.strstart, W = y.prev_length, Y = y.nice_match, R = y.strstart > y.w_size - U ? y.strstart - (y.w_size - U) : 0, K = y.window, tt = y.w_mask, X = y.prev, st = y.strstart + I, mt = K[B + W - 1], ht = K[B + W];
        y.prev_length >= y.good_match && (S >>= 2), Y > y.lookahead && (Y = y.lookahead);
        do
          if (K[(V = H) + W] === ht && K[V + W - 1] === mt && K[V] === K[B] && K[++V] === K[B + 1]) {
            B += 2, V++;
            do
              ;
            while (K[++B] === K[++V] && K[++B] === K[++V] && K[++B] === K[++V] && K[++B] === K[++V] && K[++B] === K[++V] && K[++B] === K[++V] && K[++B] === K[++V] && K[++B] === K[++V] && B < st);
            if (O = I - (st - B), B = st - I, W < O) {
              if (y.match_start = H, Y <= (W = O))
                break;
              mt = K[B + W - 1], ht = K[B + W];
            }
          }
        while ((H = X[H & tt]) > R && --S != 0);
        return W <= y.lookahead ? W : y.lookahead;
      }
      function bt(y) {
        var H, V, O, S, B, W, Y, R, K, tt, X = y.w_size;
        do {
          if (S = y.window_size - y.lookahead - y.strstart, y.strstart >= X + (X - U)) {
            for (o.arraySet(y.window, y.window, X, X, 0), y.match_start -= X, y.strstart -= X, y.block_start -= X, H = V = y.hash_size; O = y.head[--H], y.head[H] = X <= O ? O - X : 0, --V; )
              ;
            for (H = V = X; O = y.prev[--H], y.prev[H] = X <= O ? O - X : 0, --V; )
              ;
            S += X;
          }
          if (y.strm.avail_in === 0)
            break;
          if (W = y.strm, Y = y.window, R = y.strstart + y.lookahead, K = S, tt = void 0, tt = W.avail_in, K < tt && (tt = K), V = tt === 0 ? 0 : (W.avail_in -= tt, o.arraySet(Y, W.input, W.next_in, tt, R), W.state.wrap === 1 ? W.adler = l(W.adler, Y, tt, R) : W.state.wrap === 2 && (W.adler = c(W.adler, Y, tt, R)), W.next_in += tt, W.total_in += tt, tt), y.lookahead += V, y.lookahead + y.insert >= D)
            for (B = y.strstart - y.insert, y.ins_h = y.window[B], y.ins_h = (y.ins_h << y.hash_shift ^ y.window[B + 1]) & y.hash_mask; y.insert && (y.ins_h = (y.ins_h << y.hash_shift ^ y.window[B + D - 1]) & y.hash_mask, y.prev[B & y.w_mask] = y.head[y.ins_h], y.head[y.ins_h] = B, B++, y.insert--, !(y.lookahead + y.insert < D)); )
              ;
        } while (y.lookahead < U && y.strm.avail_in !== 0);
      }
      function Ot(y, H) {
        for (var V, O; ; ) {
          if (y.lookahead < U) {
            if (bt(y), y.lookahead < U && H === f)
              return w;
            if (y.lookahead === 0)
              break;
          }
          if (V = 0, y.lookahead >= D && (y.ins_h = (y.ins_h << y.hash_shift ^ y.window[y.strstart + D - 1]) & y.hash_mask, V = y.prev[y.strstart & y.w_mask] = y.head[y.ins_h], y.head[y.ins_h] = y.strstart), V !== 0 && y.strstart - V <= y.w_size - U && (y.match_length = q(y, V)), y.match_length >= D)
            if (O = n._tr_tally(y, y.strstart - y.match_start, y.match_length - D), y.lookahead -= y.match_length, y.match_length <= y.max_lazy_match && y.lookahead >= D) {
              for (y.match_length--; y.strstart++, y.ins_h = (y.ins_h << y.hash_shift ^ y.window[y.strstart + D - 1]) & y.hash_mask, V = y.prev[y.strstart & y.w_mask] = y.head[y.ins_h], y.head[y.ins_h] = y.strstart, --y.match_length != 0; )
                ;
              y.strstart++;
            } else
              y.strstart += y.match_length, y.match_length = 0, y.ins_h = y.window[y.strstart], y.ins_h = (y.ins_h << y.hash_shift ^ y.window[y.strstart + 1]) & y.hash_mask;
          else
            O = n._tr_tally(y, 0, y.window[y.strstart]), y.lookahead--, y.strstart++;
          if (O && (F(y, false), y.strm.avail_out === 0))
            return w;
        }
        return y.insert = y.strstart < D - 1 ? y.strstart : D - 1, H === p ? (F(y, true), y.strm.avail_out === 0 ? J : Z) : y.last_lit && (F(y, false), y.strm.avail_out === 0) ? w : M;
      }
      function ct(y, H) {
        for (var V, O, S; ; ) {
          if (y.lookahead < U) {
            if (bt(y), y.lookahead < U && H === f)
              return w;
            if (y.lookahead === 0)
              break;
          }
          if (V = 0, y.lookahead >= D && (y.ins_h = (y.ins_h << y.hash_shift ^ y.window[y.strstart + D - 1]) & y.hash_mask, V = y.prev[y.strstart & y.w_mask] = y.head[y.ins_h], y.head[y.ins_h] = y.strstart), y.prev_length = y.match_length, y.prev_match = y.match_start, y.match_length = D - 1, V !== 0 && y.prev_length < y.max_lazy_match && y.strstart - V <= y.w_size - U && (y.match_length = q(y, V), y.match_length <= 5 && (y.strategy === 1 || y.match_length === D && 4096 < y.strstart - y.match_start) && (y.match_length = D - 1)), y.prev_length >= D && y.match_length <= y.prev_length) {
            for (S = y.strstart + y.lookahead - D, O = n._tr_tally(y, y.strstart - 1 - y.prev_match, y.prev_length - D), y.lookahead -= y.prev_length - 1, y.prev_length -= 2; ++y.strstart <= S && (y.ins_h = (y.ins_h << y.hash_shift ^ y.window[y.strstart + D - 1]) & y.hash_mask, V = y.prev[y.strstart & y.w_mask] = y.head[y.ins_h], y.head[y.ins_h] = y.strstart), --y.prev_length != 0; )
              ;
            if (y.match_available = 0, y.match_length = D - 1, y.strstart++, O && (F(y, false), y.strm.avail_out === 0))
              return w;
          } else if (y.match_available) {
            if ((O = n._tr_tally(y, 0, y.window[y.strstart - 1])) && F(y, false), y.strstart++, y.lookahead--, y.strm.avail_out === 0)
              return w;
          } else
            y.match_available = 1, y.strstart++, y.lookahead--;
        }
        return y.match_available && (O = n._tr_tally(y, 0, y.window[y.strstart - 1]), y.match_available = 0), y.insert = y.strstart < D - 1 ? y.strstart : D - 1, H === p ? (F(y, true), y.strm.avail_out === 0 ? J : Z) : y.last_lit && (F(y, false), y.strm.avail_out === 0) ? w : M;
      }
      function ft(y, H, V, O, S) {
        this.good_length = y, this.max_lazy = H, this.nice_length = V, this.max_chain = O, this.func = S;
      }
      function St() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * A), this.dyn_dtree = new o.Buf16(2 * (2 * T + 1)), this.bl_tree = new o.Buf16(2 * (2 * E + 1)), at(this.dyn_ltree), at(this.dyn_dtree), at(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(z + 1), this.heap = new o.Buf16(2 * _ + 1), at(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * _ + 1), at(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function xt(y) {
        var H;
        return y && y.state ? (y.total_in = y.total_out = 0, y.data_type = h, (H = y.state).pending = 0, H.pending_out = 0, H.wrap < 0 && (H.wrap = -H.wrap), H.status = H.wrap ? C : k, y.adler = H.wrap === 2 ? 0 : 1, H.last_flush = f, n._tr_init(H), u) : nt(y, g);
      }
      function Xt(y) {
        var H = xt(y);
        return H === u && function(V) {
          V.window_size = 2 * V.w_size, at(V.head), V.max_lazy_match = r[V.level].max_lazy, V.good_match = r[V.level].good_length, V.nice_match = r[V.level].nice_length, V.max_chain_length = r[V.level].max_chain, V.strstart = 0, V.block_start = 0, V.lookahead = 0, V.insert = 0, V.match_length = V.prev_length = D - 1, V.match_available = 0, V.ins_h = 0;
        }(y.state), H;
      }
      function Wt(y, H, V, O, S, B) {
        if (!y)
          return g;
        var W = 1;
        if (H === m && (H = 6), O < 0 ? (W = 0, O = -O) : 15 < O && (W = 2, O -= 16), S < 1 || x < S || V !== v || O < 8 || 15 < O || H < 0 || 9 < H || B < 0 || b < B)
          return nt(y, g);
        O === 8 && (O = 9);
        var Y = new St();
        return (y.state = Y).strm = y, Y.wrap = W, Y.gzhead = null, Y.w_bits = O, Y.w_size = 1 << Y.w_bits, Y.w_mask = Y.w_size - 1, Y.hash_bits = S + 7, Y.hash_size = 1 << Y.hash_bits, Y.hash_mask = Y.hash_size - 1, Y.hash_shift = ~~((Y.hash_bits + D - 1) / D), Y.window = new o.Buf8(2 * Y.w_size), Y.head = new o.Buf16(Y.hash_size), Y.prev = new o.Buf16(Y.w_size), Y.lit_bufsize = 1 << S + 6, Y.pending_buf_size = 4 * Y.lit_bufsize, Y.pending_buf = new o.Buf8(Y.pending_buf_size), Y.d_buf = 1 * Y.lit_bufsize, Y.l_buf = 3 * Y.lit_bufsize, Y.level = H, Y.strategy = B, Y.method = V, Xt(y);
      }
      r = [new ft(0, 0, 0, 0, function(y, H) {
        var V = 65535;
        for (V > y.pending_buf_size - 5 && (V = y.pending_buf_size - 5); ; ) {
          if (y.lookahead <= 1) {
            if (bt(y), y.lookahead === 0 && H === f)
              return w;
            if (y.lookahead === 0)
              break;
          }
          y.strstart += y.lookahead, y.lookahead = 0;
          var O = y.block_start + V;
          if ((y.strstart === 0 || y.strstart >= O) && (y.lookahead = y.strstart - O, y.strstart = O, F(y, false), y.strm.avail_out === 0) || y.strstart - y.block_start >= y.w_size - U && (F(y, false), y.strm.avail_out === 0))
            return w;
        }
        return y.insert = 0, H === p ? (F(y, true), y.strm.avail_out === 0 ? J : Z) : (y.strstart > y.block_start && (F(y, false), y.strm.avail_out), w);
      }), new ft(4, 4, 8, 4, Ot), new ft(4, 5, 16, 8, Ot), new ft(4, 6, 32, 32, Ot), new ft(4, 4, 16, 16, ct), new ft(8, 16, 32, 32, ct), new ft(8, 16, 128, 128, ct), new ft(8, 32, 128, 256, ct), new ft(32, 128, 258, 1024, ct), new ft(32, 258, 258, 4096, ct)], s.deflateInit = function(y, H) {
        return Wt(y, H, v, 15, 8, 0);
      }, s.deflateInit2 = Wt, s.deflateReset = Xt, s.deflateResetKeep = xt, s.deflateSetHeader = function(y, H) {
        return y && y.state ? y.state.wrap !== 2 ? g : (y.state.gzhead = H, u) : g;
      }, s.deflate = function(y, H) {
        var V, O, S, B;
        if (!y || !y.state || 5 < H || H < 0)
          return y ? nt(y, g) : g;
        if (O = y.state, !y.output || !y.input && y.avail_in !== 0 || O.status === 666 && H !== p)
          return nt(y, y.avail_out === 0 ? -5 : g);
        if (O.strm = y, V = O.last_flush, O.last_flush = H, O.status === C)
          if (O.wrap === 2)
            y.adler = 0, rt(O, 31), rt(O, 139), rt(O, 8), O.gzhead ? (rt(O, (O.gzhead.text ? 1 : 0) + (O.gzhead.hcrc ? 2 : 0) + (O.gzhead.extra ? 4 : 0) + (O.gzhead.name ? 8 : 0) + (O.gzhead.comment ? 16 : 0)), rt(O, 255 & O.gzhead.time), rt(O, O.gzhead.time >> 8 & 255), rt(O, O.gzhead.time >> 16 & 255), rt(O, O.gzhead.time >> 24 & 255), rt(O, O.level === 9 ? 2 : 2 <= O.strategy || O.level < 2 ? 4 : 0), rt(O, 255 & O.gzhead.os), O.gzhead.extra && O.gzhead.extra.length && (rt(O, 255 & O.gzhead.extra.length), rt(O, O.gzhead.extra.length >> 8 & 255)), O.gzhead.hcrc && (y.adler = c(y.adler, O.pending_buf, O.pending, 0)), O.gzindex = 0, O.status = 69) : (rt(O, 0), rt(O, 0), rt(O, 0), rt(O, 0), rt(O, 0), rt(O, O.level === 9 ? 2 : 2 <= O.strategy || O.level < 2 ? 4 : 0), rt(O, 3), O.status = k);
          else {
            var W = v + (O.w_bits - 8 << 4) << 8;
            W |= (2 <= O.strategy || O.level < 2 ? 0 : O.level < 6 ? 1 : O.level === 6 ? 2 : 3) << 6, O.strstart !== 0 && (W |= 32), W += 31 - W % 31, O.status = k, $(O, W), O.strstart !== 0 && ($(O, y.adler >>> 16), $(O, 65535 & y.adler)), y.adler = 1;
          }
        if (O.status === 69)
          if (O.gzhead.extra) {
            for (S = O.pending; O.gzindex < (65535 & O.gzhead.extra.length) && (O.pending !== O.pending_buf_size || (O.gzhead.hcrc && O.pending > S && (y.adler = c(y.adler, O.pending_buf, O.pending - S, S)), N(y), S = O.pending, O.pending !== O.pending_buf_size)); )
              rt(O, 255 & O.gzhead.extra[O.gzindex]), O.gzindex++;
            O.gzhead.hcrc && O.pending > S && (y.adler = c(y.adler, O.pending_buf, O.pending - S, S)), O.gzindex === O.gzhead.extra.length && (O.gzindex = 0, O.status = 73);
          } else
            O.status = 73;
        if (O.status === 73)
          if (O.gzhead.name) {
            S = O.pending;
            do {
              if (O.pending === O.pending_buf_size && (O.gzhead.hcrc && O.pending > S && (y.adler = c(y.adler, O.pending_buf, O.pending - S, S)), N(y), S = O.pending, O.pending === O.pending_buf_size)) {
                B = 1;
                break;
              }
              B = O.gzindex < O.gzhead.name.length ? 255 & O.gzhead.name.charCodeAt(O.gzindex++) : 0, rt(O, B);
            } while (B !== 0);
            O.gzhead.hcrc && O.pending > S && (y.adler = c(y.adler, O.pending_buf, O.pending - S, S)), B === 0 && (O.gzindex = 0, O.status = 91);
          } else
            O.status = 91;
        if (O.status === 91)
          if (O.gzhead.comment) {
            S = O.pending;
            do {
              if (O.pending === O.pending_buf_size && (O.gzhead.hcrc && O.pending > S && (y.adler = c(y.adler, O.pending_buf, O.pending - S, S)), N(y), S = O.pending, O.pending === O.pending_buf_size)) {
                B = 1;
                break;
              }
              B = O.gzindex < O.gzhead.comment.length ? 255 & O.gzhead.comment.charCodeAt(O.gzindex++) : 0, rt(O, B);
            } while (B !== 0);
            O.gzhead.hcrc && O.pending > S && (y.adler = c(y.adler, O.pending_buf, O.pending - S, S)), B === 0 && (O.status = 103);
          } else
            O.status = 103;
        if (O.status === 103 && (O.gzhead.hcrc ? (O.pending + 2 > O.pending_buf_size && N(y), O.pending + 2 <= O.pending_buf_size && (rt(O, 255 & y.adler), rt(O, y.adler >> 8 & 255), y.adler = 0, O.status = k)) : O.status = k), O.pending !== 0) {
          if (N(y), y.avail_out === 0)
            return O.last_flush = -1, u;
        } else if (y.avail_in === 0 && j(H) <= j(V) && H !== p)
          return nt(y, -5);
        if (O.status === 666 && y.avail_in !== 0)
          return nt(y, -5);
        if (y.avail_in !== 0 || O.lookahead !== 0 || H !== f && O.status !== 666) {
          var Y = O.strategy === 2 ? function(R, K) {
            for (var tt; ; ) {
              if (R.lookahead === 0 && (bt(R), R.lookahead === 0)) {
                if (K === f)
                  return w;
                break;
              }
              if (R.match_length = 0, tt = n._tr_tally(R, 0, R.window[R.strstart]), R.lookahead--, R.strstart++, tt && (F(R, false), R.strm.avail_out === 0))
                return w;
            }
            return R.insert = 0, K === p ? (F(R, true), R.strm.avail_out === 0 ? J : Z) : R.last_lit && (F(R, false), R.strm.avail_out === 0) ? w : M;
          }(O, H) : O.strategy === 3 ? function(R, K) {
            for (var tt, X, st, mt, ht = R.window; ; ) {
              if (R.lookahead <= I) {
                if (bt(R), R.lookahead <= I && K === f)
                  return w;
                if (R.lookahead === 0)
                  break;
              }
              if (R.match_length = 0, R.lookahead >= D && 0 < R.strstart && (X = ht[st = R.strstart - 1]) === ht[++st] && X === ht[++st] && X === ht[++st]) {
                mt = R.strstart + I;
                do
                  ;
                while (X === ht[++st] && X === ht[++st] && X === ht[++st] && X === ht[++st] && X === ht[++st] && X === ht[++st] && X === ht[++st] && X === ht[++st] && st < mt);
                R.match_length = I - (mt - st), R.match_length > R.lookahead && (R.match_length = R.lookahead);
              }
              if (R.match_length >= D ? (tt = n._tr_tally(R, 1, R.match_length - D), R.lookahead -= R.match_length, R.strstart += R.match_length, R.match_length = 0) : (tt = n._tr_tally(R, 0, R.window[R.strstart]), R.lookahead--, R.strstart++), tt && (F(R, false), R.strm.avail_out === 0))
                return w;
            }
            return R.insert = 0, K === p ? (F(R, true), R.strm.avail_out === 0 ? J : Z) : R.last_lit && (F(R, false), R.strm.avail_out === 0) ? w : M;
          }(O, H) : r[O.level].func(O, H);
          if (Y !== J && Y !== Z || (O.status = 666), Y === w || Y === J)
            return y.avail_out === 0 && (O.last_flush = -1), u;
          if (Y === M && (H === 1 ? n._tr_align(O) : H !== 5 && (n._tr_stored_block(O, 0, 0, false), H === 3 && (at(O.head), O.lookahead === 0 && (O.strstart = 0, O.block_start = 0, O.insert = 0))), N(y), y.avail_out === 0))
            return O.last_flush = -1, u;
        }
        return H !== p ? u : O.wrap <= 0 ? 1 : (O.wrap === 2 ? (rt(O, 255 & y.adler), rt(O, y.adler >> 8 & 255), rt(O, y.adler >> 16 & 255), rt(O, y.adler >> 24 & 255), rt(O, 255 & y.total_in), rt(O, y.total_in >> 8 & 255), rt(O, y.total_in >> 16 & 255), rt(O, y.total_in >> 24 & 255)) : ($(O, y.adler >>> 16), $(O, 65535 & y.adler)), N(y), 0 < O.wrap && (O.wrap = -O.wrap), O.pending !== 0 ? u : 1);
      }, s.deflateEnd = function(y) {
        var H;
        return y && y.state ? (H = y.state.status) !== C && H !== 69 && H !== 73 && H !== 91 && H !== 103 && H !== k && H !== 666 ? nt(y, g) : (y.state = null, H === k ? nt(y, -3) : u) : g;
      }, s.deflateSetDictionary = function(y, H) {
        var V, O, S, B, W, Y, R, K, tt = H.length;
        if (!y || !y.state || (B = (V = y.state).wrap) === 2 || B === 1 && V.status !== C || V.lookahead)
          return g;
        for (B === 1 && (y.adler = l(y.adler, H, tt, 0)), V.wrap = 0, tt >= V.w_size && (B === 0 && (at(V.head), V.strstart = 0, V.block_start = 0, V.insert = 0), K = new o.Buf8(V.w_size), o.arraySet(K, H, tt - V.w_size, V.w_size, 0), H = K, tt = V.w_size), W = y.avail_in, Y = y.next_in, R = y.input, y.avail_in = tt, y.next_in = 0, y.input = H, bt(V); V.lookahead >= D; ) {
          for (O = V.strstart, S = V.lookahead - (D - 1); V.ins_h = (V.ins_h << V.hash_shift ^ V.window[O + D - 1]) & V.hash_mask, V.prev[O & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = O, O++, --S; )
            ;
          V.strstart = O, V.lookahead = D - 1, bt(V);
        }
        return V.strstart += V.lookahead, V.block_start = V.strstart, V.insert = V.lookahead, V.lookahead = 0, V.match_length = V.prev_length = D - 1, V.match_available = 0, y.next_in = Y, y.input = R, y.avail_in = W, V.wrap = B, u;
      }, s.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, i, s) {
      i.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e, i, s) {
      i.exports = function(r, o) {
        var n, l, c, d, f, p, u, g, m, b, h, v, x, _, T, E, A, z, D, I, U, C, k, w, M;
        n = r.state, l = r.next_in, w = r.input, c = l + (r.avail_in - 5), d = r.next_out, M = r.output, f = d - (o - r.avail_out), p = d + (r.avail_out - 257), u = n.dmax, g = n.wsize, m = n.whave, b = n.wnext, h = n.window, v = n.hold, x = n.bits, _ = n.lencode, T = n.distcode, E = (1 << n.lenbits) - 1, A = (1 << n.distbits) - 1;
        t:
          do {
            x < 15 && (v += w[l++] << x, x += 8, v += w[l++] << x, x += 8), z = _[v & E];
            e:
              for (; ; ) {
                if (v >>>= D = z >>> 24, x -= D, (D = z >>> 16 & 255) === 0)
                  M[d++] = 65535 & z;
                else {
                  if (!(16 & D)) {
                    if (!(64 & D)) {
                      z = _[(65535 & z) + (v & (1 << D) - 1)];
                      continue e;
                    }
                    if (32 & D) {
                      n.mode = 12;
                      break t;
                    }
                    r.msg = "invalid literal/length code", n.mode = 30;
                    break t;
                  }
                  I = 65535 & z, (D &= 15) && (x < D && (v += w[l++] << x, x += 8), I += v & (1 << D) - 1, v >>>= D, x -= D), x < 15 && (v += w[l++] << x, x += 8, v += w[l++] << x, x += 8), z = T[v & A];
                  i:
                    for (; ; ) {
                      if (v >>>= D = z >>> 24, x -= D, !(16 & (D = z >>> 16 & 255))) {
                        if (!(64 & D)) {
                          z = T[(65535 & z) + (v & (1 << D) - 1)];
                          continue i;
                        }
                        r.msg = "invalid distance code", n.mode = 30;
                        break t;
                      }
                      if (U = 65535 & z, x < (D &= 15) && (v += w[l++] << x, (x += 8) < D && (v += w[l++] << x, x += 8)), u < (U += v & (1 << D) - 1)) {
                        r.msg = "invalid distance too far back", n.mode = 30;
                        break t;
                      }
                      if (v >>>= D, x -= D, (D = d - f) < U) {
                        if (m < (D = U - D) && n.sane) {
                          r.msg = "invalid distance too far back", n.mode = 30;
                          break t;
                        }
                        if (k = h, (C = 0) === b) {
                          if (C += g - D, D < I) {
                            for (I -= D; M[d++] = h[C++], --D; )
                              ;
                            C = d - U, k = M;
                          }
                        } else if (b < D) {
                          if (C += g + b - D, (D -= b) < I) {
                            for (I -= D; M[d++] = h[C++], --D; )
                              ;
                            if (C = 0, b < I) {
                              for (I -= D = b; M[d++] = h[C++], --D; )
                                ;
                              C = d - U, k = M;
                            }
                          }
                        } else if (C += b - D, D < I) {
                          for (I -= D; M[d++] = h[C++], --D; )
                            ;
                          C = d - U, k = M;
                        }
                        for (; 2 < I; )
                          M[d++] = k[C++], M[d++] = k[C++], M[d++] = k[C++], I -= 3;
                        I && (M[d++] = k[C++], 1 < I && (M[d++] = k[C++]));
                      } else {
                        for (C = d - U; M[d++] = M[C++], M[d++] = M[C++], M[d++] = M[C++], 2 < (I -= 3); )
                          ;
                        I && (M[d++] = M[C++], 1 < I && (M[d++] = M[C++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (l < c && d < p);
        l -= I = x >> 3, v &= (1 << (x -= I << 3)) - 1, r.next_in = l, r.next_out = d, r.avail_in = l < c ? c - l + 5 : 5 - (l - c), r.avail_out = d < p ? p - d + 257 : 257 - (d - p), n.hold = v, n.bits = x;
      };
    }, {}], 49: [function(e, i, s) {
      var r = e("../utils/common"), o = e("./adler32"), n = e("./crc32"), l = e("./inffast"), c = e("./inftrees"), d = 1, f = 2, p = 0, u = -2, g = 1, m = 852, b = 592;
      function h(C) {
        return (C >>> 24 & 255) + (C >>> 8 & 65280) + ((65280 & C) << 8) + ((255 & C) << 24);
      }
      function v() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function x(C) {
        var k;
        return C && C.state ? (k = C.state, C.total_in = C.total_out = k.total = 0, C.msg = "", k.wrap && (C.adler = 1 & k.wrap), k.mode = g, k.last = 0, k.havedict = 0, k.dmax = 32768, k.head = null, k.hold = 0, k.bits = 0, k.lencode = k.lendyn = new r.Buf32(m), k.distcode = k.distdyn = new r.Buf32(b), k.sane = 1, k.back = -1, p) : u;
      }
      function _(C) {
        var k;
        return C && C.state ? ((k = C.state).wsize = 0, k.whave = 0, k.wnext = 0, x(C)) : u;
      }
      function T(C, k) {
        var w, M;
        return C && C.state ? (M = C.state, k < 0 ? (w = 0, k = -k) : (w = 1 + (k >> 4), k < 48 && (k &= 15)), k && (k < 8 || 15 < k) ? u : (M.window !== null && M.wbits !== k && (M.window = null), M.wrap = w, M.wbits = k, _(C))) : u;
      }
      function E(C, k) {
        var w, M;
        return C ? (M = new v(), (C.state = M).window = null, (w = T(C, k)) !== p && (C.state = null), w) : u;
      }
      var A, z, D = true;
      function I(C) {
        if (D) {
          var k;
          for (A = new r.Buf32(512), z = new r.Buf32(32), k = 0; k < 144; )
            C.lens[k++] = 8;
          for (; k < 256; )
            C.lens[k++] = 9;
          for (; k < 280; )
            C.lens[k++] = 7;
          for (; k < 288; )
            C.lens[k++] = 8;
          for (c(d, C.lens, 0, 288, A, 0, C.work, { bits: 9 }), k = 0; k < 32; )
            C.lens[k++] = 5;
          c(f, C.lens, 0, 32, z, 0, C.work, { bits: 5 }), D = false;
        }
        C.lencode = A, C.lenbits = 9, C.distcode = z, C.distbits = 5;
      }
      function U(C, k, w, M) {
        var J, Z = C.state;
        return Z.window === null && (Z.wsize = 1 << Z.wbits, Z.wnext = 0, Z.whave = 0, Z.window = new r.Buf8(Z.wsize)), M >= Z.wsize ? (r.arraySet(Z.window, k, w - Z.wsize, Z.wsize, 0), Z.wnext = 0, Z.whave = Z.wsize) : (M < (J = Z.wsize - Z.wnext) && (J = M), r.arraySet(Z.window, k, w - M, J, Z.wnext), (M -= J) ? (r.arraySet(Z.window, k, w - M, M, 0), Z.wnext = M, Z.whave = Z.wsize) : (Z.wnext += J, Z.wnext === Z.wsize && (Z.wnext = 0), Z.whave < Z.wsize && (Z.whave += J))), 0;
      }
      s.inflateReset = _, s.inflateReset2 = T, s.inflateResetKeep = x, s.inflateInit = function(C) {
        return E(C, 15);
      }, s.inflateInit2 = E, s.inflate = function(C, k) {
        var w, M, J, Z, nt, j, at, N, F, rt, $, q, bt, Ot, ct, ft, St, xt, Xt, Wt, y, H, V, O, S = 0, B = new r.Buf8(4), W = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!C || !C.state || !C.output || !C.input && C.avail_in !== 0)
          return u;
        (w = C.state).mode === 12 && (w.mode = 13), nt = C.next_out, J = C.output, at = C.avail_out, Z = C.next_in, M = C.input, j = C.avail_in, N = w.hold, F = w.bits, rt = j, $ = at, H = p;
        t:
          for (; ; )
            switch (w.mode) {
              case g:
                if (w.wrap === 0) {
                  w.mode = 13;
                  break;
                }
                for (; F < 16; ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                if (2 & w.wrap && N === 35615) {
                  B[w.check = 0] = 255 & N, B[1] = N >>> 8 & 255, w.check = n(w.check, B, 2, 0), F = N = 0, w.mode = 2;
                  break;
                }
                if (w.flags = 0, w.head && (w.head.done = false), !(1 & w.wrap) || (((255 & N) << 8) + (N >> 8)) % 31) {
                  C.msg = "incorrect header check", w.mode = 30;
                  break;
                }
                if ((15 & N) != 8) {
                  C.msg = "unknown compression method", w.mode = 30;
                  break;
                }
                if (F -= 4, y = 8 + (15 & (N >>>= 4)), w.wbits === 0)
                  w.wbits = y;
                else if (y > w.wbits) {
                  C.msg = "invalid window size", w.mode = 30;
                  break;
                }
                w.dmax = 1 << y, C.adler = w.check = 1, w.mode = 512 & N ? 10 : 12, F = N = 0;
                break;
              case 2:
                for (; F < 16; ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                if (w.flags = N, (255 & w.flags) != 8) {
                  C.msg = "unknown compression method", w.mode = 30;
                  break;
                }
                if (57344 & w.flags) {
                  C.msg = "unknown header flags set", w.mode = 30;
                  break;
                }
                w.head && (w.head.text = N >> 8 & 1), 512 & w.flags && (B[0] = 255 & N, B[1] = N >>> 8 & 255, w.check = n(w.check, B, 2, 0)), F = N = 0, w.mode = 3;
              case 3:
                for (; F < 32; ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                w.head && (w.head.time = N), 512 & w.flags && (B[0] = 255 & N, B[1] = N >>> 8 & 255, B[2] = N >>> 16 & 255, B[3] = N >>> 24 & 255, w.check = n(w.check, B, 4, 0)), F = N = 0, w.mode = 4;
              case 4:
                for (; F < 16; ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                w.head && (w.head.xflags = 255 & N, w.head.os = N >> 8), 512 & w.flags && (B[0] = 255 & N, B[1] = N >>> 8 & 255, w.check = n(w.check, B, 2, 0)), F = N = 0, w.mode = 5;
              case 5:
                if (1024 & w.flags) {
                  for (; F < 16; ) {
                    if (j === 0)
                      break t;
                    j--, N += M[Z++] << F, F += 8;
                  }
                  w.length = N, w.head && (w.head.extra_len = N), 512 & w.flags && (B[0] = 255 & N, B[1] = N >>> 8 & 255, w.check = n(w.check, B, 2, 0)), F = N = 0;
                } else
                  w.head && (w.head.extra = null);
                w.mode = 6;
              case 6:
                if (1024 & w.flags && (j < (q = w.length) && (q = j), q && (w.head && (y = w.head.extra_len - w.length, w.head.extra || (w.head.extra = new Array(w.head.extra_len)), r.arraySet(w.head.extra, M, Z, q, y)), 512 & w.flags && (w.check = n(w.check, M, q, Z)), j -= q, Z += q, w.length -= q), w.length))
                  break t;
                w.length = 0, w.mode = 7;
              case 7:
                if (2048 & w.flags) {
                  if (j === 0)
                    break t;
                  for (q = 0; y = M[Z + q++], w.head && y && w.length < 65536 && (w.head.name += String.fromCharCode(y)), y && q < j; )
                    ;
                  if (512 & w.flags && (w.check = n(w.check, M, q, Z)), j -= q, Z += q, y)
                    break t;
                } else
                  w.head && (w.head.name = null);
                w.length = 0, w.mode = 8;
              case 8:
                if (4096 & w.flags) {
                  if (j === 0)
                    break t;
                  for (q = 0; y = M[Z + q++], w.head && y && w.length < 65536 && (w.head.comment += String.fromCharCode(y)), y && q < j; )
                    ;
                  if (512 & w.flags && (w.check = n(w.check, M, q, Z)), j -= q, Z += q, y)
                    break t;
                } else
                  w.head && (w.head.comment = null);
                w.mode = 9;
              case 9:
                if (512 & w.flags) {
                  for (; F < 16; ) {
                    if (j === 0)
                      break t;
                    j--, N += M[Z++] << F, F += 8;
                  }
                  if (N !== (65535 & w.check)) {
                    C.msg = "header crc mismatch", w.mode = 30;
                    break;
                  }
                  F = N = 0;
                }
                w.head && (w.head.hcrc = w.flags >> 9 & 1, w.head.done = true), C.adler = w.check = 0, w.mode = 12;
                break;
              case 10:
                for (; F < 32; ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                C.adler = w.check = h(N), F = N = 0, w.mode = 11;
              case 11:
                if (w.havedict === 0)
                  return C.next_out = nt, C.avail_out = at, C.next_in = Z, C.avail_in = j, w.hold = N, w.bits = F, 2;
                C.adler = w.check = 1, w.mode = 12;
              case 12:
                if (k === 5 || k === 6)
                  break t;
              case 13:
                if (w.last) {
                  N >>>= 7 & F, F -= 7 & F, w.mode = 27;
                  break;
                }
                for (; F < 3; ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                switch (w.last = 1 & N, F -= 1, 3 & (N >>>= 1)) {
                  case 0:
                    w.mode = 14;
                    break;
                  case 1:
                    if (I(w), w.mode = 20, k !== 6)
                      break;
                    N >>>= 2, F -= 2;
                    break t;
                  case 2:
                    w.mode = 17;
                    break;
                  case 3:
                    C.msg = "invalid block type", w.mode = 30;
                }
                N >>>= 2, F -= 2;
                break;
              case 14:
                for (N >>>= 7 & F, F -= 7 & F; F < 32; ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                if ((65535 & N) != (N >>> 16 ^ 65535)) {
                  C.msg = "invalid stored block lengths", w.mode = 30;
                  break;
                }
                if (w.length = 65535 & N, F = N = 0, w.mode = 15, k === 6)
                  break t;
              case 15:
                w.mode = 16;
              case 16:
                if (q = w.length) {
                  if (j < q && (q = j), at < q && (q = at), q === 0)
                    break t;
                  r.arraySet(J, M, Z, q, nt), j -= q, Z += q, at -= q, nt += q, w.length -= q;
                  break;
                }
                w.mode = 12;
                break;
              case 17:
                for (; F < 14; ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                if (w.nlen = 257 + (31 & N), N >>>= 5, F -= 5, w.ndist = 1 + (31 & N), N >>>= 5, F -= 5, w.ncode = 4 + (15 & N), N >>>= 4, F -= 4, 286 < w.nlen || 30 < w.ndist) {
                  C.msg = "too many length or distance symbols", w.mode = 30;
                  break;
                }
                w.have = 0, w.mode = 18;
              case 18:
                for (; w.have < w.ncode; ) {
                  for (; F < 3; ) {
                    if (j === 0)
                      break t;
                    j--, N += M[Z++] << F, F += 8;
                  }
                  w.lens[W[w.have++]] = 7 & N, N >>>= 3, F -= 3;
                }
                for (; w.have < 19; )
                  w.lens[W[w.have++]] = 0;
                if (w.lencode = w.lendyn, w.lenbits = 7, V = { bits: w.lenbits }, H = c(0, w.lens, 0, 19, w.lencode, 0, w.work, V), w.lenbits = V.bits, H) {
                  C.msg = "invalid code lengths set", w.mode = 30;
                  break;
                }
                w.have = 0, w.mode = 19;
              case 19:
                for (; w.have < w.nlen + w.ndist; ) {
                  for (; ft = (S = w.lencode[N & (1 << w.lenbits) - 1]) >>> 16 & 255, St = 65535 & S, !((ct = S >>> 24) <= F); ) {
                    if (j === 0)
                      break t;
                    j--, N += M[Z++] << F, F += 8;
                  }
                  if (St < 16)
                    N >>>= ct, F -= ct, w.lens[w.have++] = St;
                  else {
                    if (St === 16) {
                      for (O = ct + 2; F < O; ) {
                        if (j === 0)
                          break t;
                        j--, N += M[Z++] << F, F += 8;
                      }
                      if (N >>>= ct, F -= ct, w.have === 0) {
                        C.msg = "invalid bit length repeat", w.mode = 30;
                        break;
                      }
                      y = w.lens[w.have - 1], q = 3 + (3 & N), N >>>= 2, F -= 2;
                    } else if (St === 17) {
                      for (O = ct + 3; F < O; ) {
                        if (j === 0)
                          break t;
                        j--, N += M[Z++] << F, F += 8;
                      }
                      F -= ct, y = 0, q = 3 + (7 & (N >>>= ct)), N >>>= 3, F -= 3;
                    } else {
                      for (O = ct + 7; F < O; ) {
                        if (j === 0)
                          break t;
                        j--, N += M[Z++] << F, F += 8;
                      }
                      F -= ct, y = 0, q = 11 + (127 & (N >>>= ct)), N >>>= 7, F -= 7;
                    }
                    if (w.have + q > w.nlen + w.ndist) {
                      C.msg = "invalid bit length repeat", w.mode = 30;
                      break;
                    }
                    for (; q--; )
                      w.lens[w.have++] = y;
                  }
                }
                if (w.mode === 30)
                  break;
                if (w.lens[256] === 0) {
                  C.msg = "invalid code -- missing end-of-block", w.mode = 30;
                  break;
                }
                if (w.lenbits = 9, V = { bits: w.lenbits }, H = c(d, w.lens, 0, w.nlen, w.lencode, 0, w.work, V), w.lenbits = V.bits, H) {
                  C.msg = "invalid literal/lengths set", w.mode = 30;
                  break;
                }
                if (w.distbits = 6, w.distcode = w.distdyn, V = { bits: w.distbits }, H = c(f, w.lens, w.nlen, w.ndist, w.distcode, 0, w.work, V), w.distbits = V.bits, H) {
                  C.msg = "invalid distances set", w.mode = 30;
                  break;
                }
                if (w.mode = 20, k === 6)
                  break t;
              case 20:
                w.mode = 21;
              case 21:
                if (6 <= j && 258 <= at) {
                  C.next_out = nt, C.avail_out = at, C.next_in = Z, C.avail_in = j, w.hold = N, w.bits = F, l(C, $), nt = C.next_out, J = C.output, at = C.avail_out, Z = C.next_in, M = C.input, j = C.avail_in, N = w.hold, F = w.bits, w.mode === 12 && (w.back = -1);
                  break;
                }
                for (w.back = 0; ft = (S = w.lencode[N & (1 << w.lenbits) - 1]) >>> 16 & 255, St = 65535 & S, !((ct = S >>> 24) <= F); ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                if (ft && !(240 & ft)) {
                  for (xt = ct, Xt = ft, Wt = St; ft = (S = w.lencode[Wt + ((N & (1 << xt + Xt) - 1) >> xt)]) >>> 16 & 255, St = 65535 & S, !(xt + (ct = S >>> 24) <= F); ) {
                    if (j === 0)
                      break t;
                    j--, N += M[Z++] << F, F += 8;
                  }
                  N >>>= xt, F -= xt, w.back += xt;
                }
                if (N >>>= ct, F -= ct, w.back += ct, w.length = St, ft === 0) {
                  w.mode = 26;
                  break;
                }
                if (32 & ft) {
                  w.back = -1, w.mode = 12;
                  break;
                }
                if (64 & ft) {
                  C.msg = "invalid literal/length code", w.mode = 30;
                  break;
                }
                w.extra = 15 & ft, w.mode = 22;
              case 22:
                if (w.extra) {
                  for (O = w.extra; F < O; ) {
                    if (j === 0)
                      break t;
                    j--, N += M[Z++] << F, F += 8;
                  }
                  w.length += N & (1 << w.extra) - 1, N >>>= w.extra, F -= w.extra, w.back += w.extra;
                }
                w.was = w.length, w.mode = 23;
              case 23:
                for (; ft = (S = w.distcode[N & (1 << w.distbits) - 1]) >>> 16 & 255, St = 65535 & S, !((ct = S >>> 24) <= F); ) {
                  if (j === 0)
                    break t;
                  j--, N += M[Z++] << F, F += 8;
                }
                if (!(240 & ft)) {
                  for (xt = ct, Xt = ft, Wt = St; ft = (S = w.distcode[Wt + ((N & (1 << xt + Xt) - 1) >> xt)]) >>> 16 & 255, St = 65535 & S, !(xt + (ct = S >>> 24) <= F); ) {
                    if (j === 0)
                      break t;
                    j--, N += M[Z++] << F, F += 8;
                  }
                  N >>>= xt, F -= xt, w.back += xt;
                }
                if (N >>>= ct, F -= ct, w.back += ct, 64 & ft) {
                  C.msg = "invalid distance code", w.mode = 30;
                  break;
                }
                w.offset = St, w.extra = 15 & ft, w.mode = 24;
              case 24:
                if (w.extra) {
                  for (O = w.extra; F < O; ) {
                    if (j === 0)
                      break t;
                    j--, N += M[Z++] << F, F += 8;
                  }
                  w.offset += N & (1 << w.extra) - 1, N >>>= w.extra, F -= w.extra, w.back += w.extra;
                }
                if (w.offset > w.dmax) {
                  C.msg = "invalid distance too far back", w.mode = 30;
                  break;
                }
                w.mode = 25;
              case 25:
                if (at === 0)
                  break t;
                if (q = $ - at, w.offset > q) {
                  if ((q = w.offset - q) > w.whave && w.sane) {
                    C.msg = "invalid distance too far back", w.mode = 30;
                    break;
                  }
                  bt = q > w.wnext ? (q -= w.wnext, w.wsize - q) : w.wnext - q, q > w.length && (q = w.length), Ot = w.window;
                } else
                  Ot = J, bt = nt - w.offset, q = w.length;
                for (at < q && (q = at), at -= q, w.length -= q; J[nt++] = Ot[bt++], --q; )
                  ;
                w.length === 0 && (w.mode = 21);
                break;
              case 26:
                if (at === 0)
                  break t;
                J[nt++] = w.length, at--, w.mode = 21;
                break;
              case 27:
                if (w.wrap) {
                  for (; F < 32; ) {
                    if (j === 0)
                      break t;
                    j--, N |= M[Z++] << F, F += 8;
                  }
                  if ($ -= at, C.total_out += $, w.total += $, $ && (C.adler = w.check = w.flags ? n(w.check, J, $, nt - $) : o(w.check, J, $, nt - $)), $ = at, (w.flags ? N : h(N)) !== w.check) {
                    C.msg = "incorrect data check", w.mode = 30;
                    break;
                  }
                  F = N = 0;
                }
                w.mode = 28;
              case 28:
                if (w.wrap && w.flags) {
                  for (; F < 32; ) {
                    if (j === 0)
                      break t;
                    j--, N += M[Z++] << F, F += 8;
                  }
                  if (N !== (4294967295 & w.total)) {
                    C.msg = "incorrect length check", w.mode = 30;
                    break;
                  }
                  F = N = 0;
                }
                w.mode = 29;
              case 29:
                H = 1;
                break t;
              case 30:
                H = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return u;
            }
        return C.next_out = nt, C.avail_out = at, C.next_in = Z, C.avail_in = j, w.hold = N, w.bits = F, (w.wsize || $ !== C.avail_out && w.mode < 30 && (w.mode < 27 || k !== 4)) && U(C, C.output, C.next_out, $ - C.avail_out) ? (w.mode = 31, -4) : (rt -= C.avail_in, $ -= C.avail_out, C.total_in += rt, C.total_out += $, w.total += $, w.wrap && $ && (C.adler = w.check = w.flags ? n(w.check, J, $, C.next_out - $) : o(w.check, J, $, C.next_out - $)), C.data_type = w.bits + (w.last ? 64 : 0) + (w.mode === 12 ? 128 : 0) + (w.mode === 20 || w.mode === 15 ? 256 : 0), (rt == 0 && $ === 0 || k === 4) && H === p && (H = -5), H);
      }, s.inflateEnd = function(C) {
        if (!C || !C.state)
          return u;
        var k = C.state;
        return k.window && (k.window = null), C.state = null, p;
      }, s.inflateGetHeader = function(C, k) {
        var w;
        return C && C.state && 2 & (w = C.state).wrap ? ((w.head = k).done = false, p) : u;
      }, s.inflateSetDictionary = function(C, k) {
        var w, M = k.length;
        return C && C.state ? (w = C.state).wrap !== 0 && w.mode !== 11 ? u : w.mode === 11 && o(1, k, M, 0) !== w.check ? -3 : U(C, k, M, M) ? (w.mode = 31, -4) : (w.havedict = 1, p) : u;
      }, s.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, i, s) {
      var r = e("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], n = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      i.exports = function(d, f, p, u, g, m, b, h) {
        var v, x, _, T, E, A, z, D, I, U = h.bits, C = 0, k = 0, w = 0, M = 0, J = 0, Z = 0, nt = 0, j = 0, at = 0, N = 0, F = null, rt = 0, $ = new r.Buf16(16), q = new r.Buf16(16), bt = null, Ot = 0;
        for (C = 0; C <= 15; C++)
          $[C] = 0;
        for (k = 0; k < u; k++)
          $[f[p + k]]++;
        for (J = U, M = 15; 1 <= M && $[M] === 0; M--)
          ;
        if (M < J && (J = M), M === 0)
          return g[m++] = 20971520, g[m++] = 20971520, h.bits = 1, 0;
        for (w = 1; w < M && $[w] === 0; w++)
          ;
        for (J < w && (J = w), C = j = 1; C <= 15; C++)
          if (j <<= 1, (j -= $[C]) < 0)
            return -1;
        if (0 < j && (d === 0 || M !== 1))
          return -1;
        for (q[1] = 0, C = 1; C < 15; C++)
          q[C + 1] = q[C] + $[C];
        for (k = 0; k < u; k++)
          f[p + k] !== 0 && (b[q[f[p + k]]++] = k);
        if (A = d === 0 ? (F = bt = b, 19) : d === 1 ? (F = o, rt -= 257, bt = n, Ot -= 257, 256) : (F = l, bt = c, -1), C = w, E = m, nt = k = N = 0, _ = -1, T = (at = 1 << (Z = J)) - 1, d === 1 && 852 < at || d === 2 && 592 < at)
          return 1;
        for (; ; ) {
          for (z = C - nt, I = b[k] < A ? (D = 0, b[k]) : b[k] > A ? (D = bt[Ot + b[k]], F[rt + b[k]]) : (D = 96, 0), v = 1 << C - nt, w = x = 1 << Z; g[E + (N >> nt) + (x -= v)] = z << 24 | D << 16 | I | 0, x !== 0; )
            ;
          for (v = 1 << C - 1; N & v; )
            v >>= 1;
          if (v !== 0 ? (N &= v - 1, N += v) : N = 0, k++, --$[C] == 0) {
            if (C === M)
              break;
            C = f[p + b[k]];
          }
          if (J < C && (N & T) !== _) {
            for (nt === 0 && (nt = J), E += w, j = 1 << (Z = C - nt); Z + nt < M && !((j -= $[Z + nt]) <= 0); )
              Z++, j <<= 1;
            if (at += 1 << Z, d === 1 && 852 < at || d === 2 && 592 < at)
              return 1;
            g[_ = N & T] = J << 24 | Z << 16 | E - m | 0;
          }
        }
        return N !== 0 && (g[E + N] = C - nt << 24 | 64 << 16 | 0), h.bits = J, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, i, s) {
      i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, i, s) {
      var r = e("../utils/common"), o = 0, n = 1;
      function l(S) {
        for (var B = S.length; 0 <= --B; )
          S[B] = 0;
      }
      var c = 0, d = 29, f = 256, p = f + 1 + d, u = 30, g = 19, m = 2 * p + 1, b = 15, h = 16, v = 7, x = 256, _ = 16, T = 17, E = 18, A = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], z = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], D = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], I = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], U = new Array(2 * (p + 2));
      l(U);
      var C = new Array(2 * u);
      l(C);
      var k = new Array(512);
      l(k);
      var w = new Array(256);
      l(w);
      var M = new Array(d);
      l(M);
      var J, Z, nt, j = new Array(u);
      function at(S, B, W, Y, R) {
        this.static_tree = S, this.extra_bits = B, this.extra_base = W, this.elems = Y, this.max_length = R, this.has_stree = S && S.length;
      }
      function N(S, B) {
        this.dyn_tree = S, this.max_code = 0, this.stat_desc = B;
      }
      function F(S) {
        return S < 256 ? k[S] : k[256 + (S >>> 7)];
      }
      function rt(S, B) {
        S.pending_buf[S.pending++] = 255 & B, S.pending_buf[S.pending++] = B >>> 8 & 255;
      }
      function $(S, B, W) {
        S.bi_valid > h - W ? (S.bi_buf |= B << S.bi_valid & 65535, rt(S, S.bi_buf), S.bi_buf = B >> h - S.bi_valid, S.bi_valid += W - h) : (S.bi_buf |= B << S.bi_valid & 65535, S.bi_valid += W);
      }
      function q(S, B, W) {
        $(S, W[2 * B], W[2 * B + 1]);
      }
      function bt(S, B) {
        for (var W = 0; W |= 1 & S, S >>>= 1, W <<= 1, 0 < --B; )
          ;
        return W >>> 1;
      }
      function Ot(S, B, W) {
        var Y, R, K = new Array(b + 1), tt = 0;
        for (Y = 1; Y <= b; Y++)
          K[Y] = tt = tt + W[Y - 1] << 1;
        for (R = 0; R <= B; R++) {
          var X = S[2 * R + 1];
          X !== 0 && (S[2 * R] = bt(K[X]++, X));
        }
      }
      function ct(S) {
        var B;
        for (B = 0; B < p; B++)
          S.dyn_ltree[2 * B] = 0;
        for (B = 0; B < u; B++)
          S.dyn_dtree[2 * B] = 0;
        for (B = 0; B < g; B++)
          S.bl_tree[2 * B] = 0;
        S.dyn_ltree[2 * x] = 1, S.opt_len = S.static_len = 0, S.last_lit = S.matches = 0;
      }
      function ft(S) {
        8 < S.bi_valid ? rt(S, S.bi_buf) : 0 < S.bi_valid && (S.pending_buf[S.pending++] = S.bi_buf), S.bi_buf = 0, S.bi_valid = 0;
      }
      function St(S, B, W, Y) {
        var R = 2 * B, K = 2 * W;
        return S[R] < S[K] || S[R] === S[K] && Y[B] <= Y[W];
      }
      function xt(S, B, W) {
        for (var Y = S.heap[W], R = W << 1; R <= S.heap_len && (R < S.heap_len && St(B, S.heap[R + 1], S.heap[R], S.depth) && R++, !St(B, Y, S.heap[R], S.depth)); )
          S.heap[W] = S.heap[R], W = R, R <<= 1;
        S.heap[W] = Y;
      }
      function Xt(S, B, W) {
        var Y, R, K, tt, X = 0;
        if (S.last_lit !== 0)
          for (; Y = S.pending_buf[S.d_buf + 2 * X] << 8 | S.pending_buf[S.d_buf + 2 * X + 1], R = S.pending_buf[S.l_buf + X], X++, Y === 0 ? q(S, R, B) : (q(S, (K = w[R]) + f + 1, B), (tt = A[K]) !== 0 && $(S, R -= M[K], tt), q(S, K = F(--Y), W), (tt = z[K]) !== 0 && $(S, Y -= j[K], tt)), X < S.last_lit; )
            ;
        q(S, x, B);
      }
      function Wt(S, B) {
        var W, Y, R, K = B.dyn_tree, tt = B.stat_desc.static_tree, X = B.stat_desc.has_stree, st = B.stat_desc.elems, mt = -1;
        for (S.heap_len = 0, S.heap_max = m, W = 0; W < st; W++)
          K[2 * W] !== 0 ? (S.heap[++S.heap_len] = mt = W, S.depth[W] = 0) : K[2 * W + 1] = 0;
        for (; S.heap_len < 2; )
          K[2 * (R = S.heap[++S.heap_len] = mt < 2 ? ++mt : 0)] = 1, S.depth[R] = 0, S.opt_len--, X && (S.static_len -= tt[2 * R + 1]);
        for (B.max_code = mt, W = S.heap_len >> 1; 1 <= W; W--)
          xt(S, K, W);
        for (R = st; W = S.heap[1], S.heap[1] = S.heap[S.heap_len--], xt(S, K, 1), Y = S.heap[1], S.heap[--S.heap_max] = W, S.heap[--S.heap_max] = Y, K[2 * R] = K[2 * W] + K[2 * Y], S.depth[R] = (S.depth[W] >= S.depth[Y] ? S.depth[W] : S.depth[Y]) + 1, K[2 * W + 1] = K[2 * Y + 1] = R, S.heap[1] = R++, xt(S, K, 1), 2 <= S.heap_len; )
          ;
        S.heap[--S.heap_max] = S.heap[1], function(ht, Lt) {
          var Ne, qt, Ve, _t, ci, Hi, se = Lt.dyn_tree, ks = Lt.max_code, ln = Lt.stat_desc.static_tree, cn = Lt.stat_desc.has_stree, hn = Lt.stat_desc.extra_bits, Bs = Lt.stat_desc.extra_base, He = Lt.stat_desc.max_length, hi = 0;
          for (_t = 0; _t <= b; _t++)
            ht.bl_count[_t] = 0;
          for (se[2 * ht.heap[ht.heap_max] + 1] = 0, Ne = ht.heap_max + 1; Ne < m; Ne++)
            He < (_t = se[2 * se[2 * (qt = ht.heap[Ne]) + 1] + 1] + 1) && (_t = He, hi++), se[2 * qt + 1] = _t, ks < qt || (ht.bl_count[_t]++, ci = 0, Bs <= qt && (ci = hn[qt - Bs]), Hi = se[2 * qt], ht.opt_len += Hi * (_t + ci), cn && (ht.static_len += Hi * (ln[2 * qt + 1] + ci)));
          if (hi !== 0) {
            do {
              for (_t = He - 1; ht.bl_count[_t] === 0; )
                _t--;
              ht.bl_count[_t]--, ht.bl_count[_t + 1] += 2, ht.bl_count[He]--, hi -= 2;
            } while (0 < hi);
            for (_t = He; _t !== 0; _t--)
              for (qt = ht.bl_count[_t]; qt !== 0; )
                ks < (Ve = ht.heap[--Ne]) || (se[2 * Ve + 1] !== _t && (ht.opt_len += (_t - se[2 * Ve + 1]) * se[2 * Ve], se[2 * Ve + 1] = _t), qt--);
          }
        }(S, B), Ot(K, mt, S.bl_count);
      }
      function y(S, B, W) {
        var Y, R, K = -1, tt = B[1], X = 0, st = 7, mt = 4;
        for (tt === 0 && (st = 138, mt = 3), B[2 * (W + 1) + 1] = 65535, Y = 0; Y <= W; Y++)
          R = tt, tt = B[2 * (Y + 1) + 1], ++X < st && R === tt || (X < mt ? S.bl_tree[2 * R] += X : R !== 0 ? (R !== K && S.bl_tree[2 * R]++, S.bl_tree[2 * _]++) : X <= 10 ? S.bl_tree[2 * T]++ : S.bl_tree[2 * E]++, K = R, mt = (X = 0) === tt ? (st = 138, 3) : R === tt ? (st = 6, 3) : (st = 7, 4));
      }
      function H(S, B, W) {
        var Y, R, K = -1, tt = B[1], X = 0, st = 7, mt = 4;
        for (tt === 0 && (st = 138, mt = 3), Y = 0; Y <= W; Y++)
          if (R = tt, tt = B[2 * (Y + 1) + 1], !(++X < st && R === tt)) {
            if (X < mt)
              for (; q(S, R, S.bl_tree), --X != 0; )
                ;
            else
              R !== 0 ? (R !== K && (q(S, R, S.bl_tree), X--), q(S, _, S.bl_tree), $(S, X - 3, 2)) : X <= 10 ? (q(S, T, S.bl_tree), $(S, X - 3, 3)) : (q(S, E, S.bl_tree), $(S, X - 11, 7));
            K = R, mt = (X = 0) === tt ? (st = 138, 3) : R === tt ? (st = 6, 3) : (st = 7, 4);
          }
      }
      l(j);
      var V = false;
      function O(S, B, W, Y) {
        $(S, (c << 1) + (Y ? 1 : 0), 3), function(R, K, tt, X) {
          ft(R), rt(R, tt), rt(R, ~tt), r.arraySet(R.pending_buf, R.window, K, tt, R.pending), R.pending += tt;
        }(S, B, W);
      }
      s._tr_init = function(S) {
        V || (function() {
          var B, W, Y, R, K, tt = new Array(b + 1);
          for (R = Y = 0; R < d - 1; R++)
            for (M[R] = Y, B = 0; B < 1 << A[R]; B++)
              w[Y++] = R;
          for (w[Y - 1] = R, R = K = 0; R < 16; R++)
            for (j[R] = K, B = 0; B < 1 << z[R]; B++)
              k[K++] = R;
          for (K >>= 7; R < u; R++)
            for (j[R] = K << 7, B = 0; B < 1 << z[R] - 7; B++)
              k[256 + K++] = R;
          for (W = 0; W <= b; W++)
            tt[W] = 0;
          for (B = 0; B <= 143; )
            U[2 * B + 1] = 8, B++, tt[8]++;
          for (; B <= 255; )
            U[2 * B + 1] = 9, B++, tt[9]++;
          for (; B <= 279; )
            U[2 * B + 1] = 7, B++, tt[7]++;
          for (; B <= 287; )
            U[2 * B + 1] = 8, B++, tt[8]++;
          for (Ot(U, p + 1, tt), B = 0; B < u; B++)
            C[2 * B + 1] = 5, C[2 * B] = bt(B, 5);
          J = new at(U, A, f + 1, p, b), Z = new at(C, z, 0, u, b), nt = new at(new Array(0), D, 0, g, v);
        }(), V = true), S.l_desc = new N(S.dyn_ltree, J), S.d_desc = new N(S.dyn_dtree, Z), S.bl_desc = new N(S.bl_tree, nt), S.bi_buf = 0, S.bi_valid = 0, ct(S);
      }, s._tr_stored_block = O, s._tr_flush_block = function(S, B, W, Y) {
        var R, K, tt = 0;
        0 < S.level ? (S.strm.data_type === 2 && (S.strm.data_type = function(X) {
          var st, mt = 4093624447;
          for (st = 0; st <= 31; st++, mt >>>= 1)
            if (1 & mt && X.dyn_ltree[2 * st] !== 0)
              return o;
          if (X.dyn_ltree[18] !== 0 || X.dyn_ltree[20] !== 0 || X.dyn_ltree[26] !== 0)
            return n;
          for (st = 32; st < f; st++)
            if (X.dyn_ltree[2 * st] !== 0)
              return n;
          return o;
        }(S)), Wt(S, S.l_desc), Wt(S, S.d_desc), tt = function(X) {
          var st;
          for (y(X, X.dyn_ltree, X.l_desc.max_code), y(X, X.dyn_dtree, X.d_desc.max_code), Wt(X, X.bl_desc), st = g - 1; 3 <= st && X.bl_tree[2 * I[st] + 1] === 0; st--)
            ;
          return X.opt_len += 3 * (st + 1) + 5 + 5 + 4, st;
        }(S), R = S.opt_len + 3 + 7 >>> 3, (K = S.static_len + 3 + 7 >>> 3) <= R && (R = K)) : R = K = W + 5, W + 4 <= R && B !== -1 ? O(S, B, W, Y) : S.strategy === 4 || K === R ? ($(S, 2 + (Y ? 1 : 0), 3), Xt(S, U, C)) : ($(S, 4 + (Y ? 1 : 0), 3), function(X, st, mt, ht) {
          var Lt;
          for ($(X, st - 257, 5), $(X, mt - 1, 5), $(X, ht - 4, 4), Lt = 0; Lt < ht; Lt++)
            $(X, X.bl_tree[2 * I[Lt] + 1], 3);
          H(X, X.dyn_ltree, st - 1), H(X, X.dyn_dtree, mt - 1);
        }(S, S.l_desc.max_code + 1, S.d_desc.max_code + 1, tt + 1), Xt(S, S.dyn_ltree, S.dyn_dtree)), ct(S), Y && ft(S);
      }, s._tr_tally = function(S, B, W) {
        return S.pending_buf[S.d_buf + 2 * S.last_lit] = B >>> 8 & 255, S.pending_buf[S.d_buf + 2 * S.last_lit + 1] = 255 & B, S.pending_buf[S.l_buf + S.last_lit] = 255 & W, S.last_lit++, B === 0 ? S.dyn_ltree[2 * W]++ : (S.matches++, B--, S.dyn_ltree[2 * (w[W] + f + 1)]++, S.dyn_dtree[2 * F(B)]++), S.last_lit === S.lit_bufsize - 1;
      }, s._tr_align = function(S) {
        $(S, 2, 3), q(S, x, U), function(B) {
          B.bi_valid === 16 ? (rt(B, B.bi_buf), B.bi_buf = 0, B.bi_valid = 0) : 8 <= B.bi_valid && (B.pending_buf[B.pending++] = 255 & B.bi_buf, B.bi_buf >>= 8, B.bi_valid -= 8);
        }(S);
      };
    }, { "../utils/common": 41 }], 53: [function(e, i, s) {
      i.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, i, s) {
      (function(r) {
        (function(o, n) {
          if (!o.setImmediate) {
            var l, c, d, f, p = 1, u = {}, g = false, m = o.document, b = Object.getPrototypeOf && Object.getPrototypeOf(o);
            b = b && b.setTimeout ? b : o, l = {}.toString.call(o.process) === "[object process]" ? function(_) {
              process.nextTick(function() {
                v(_);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var _ = true, T = o.onmessage;
                return o.onmessage = function() {
                  _ = false;
                }, o.postMessage("", "*"), o.onmessage = T, _;
              }
            }() ? (f = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", x, false) : o.attachEvent("onmessage", x), function(_) {
              o.postMessage(f + _, "*");
            }) : o.MessageChannel ? ((d = new MessageChannel()).port1.onmessage = function(_) {
              v(_.data);
            }, function(_) {
              d.port2.postMessage(_);
            }) : m && "onreadystatechange" in m.createElement("script") ? (c = m.documentElement, function(_) {
              var T = m.createElement("script");
              T.onreadystatechange = function() {
                v(_), T.onreadystatechange = null, c.removeChild(T), T = null;
              }, c.appendChild(T);
            }) : function(_) {
              setTimeout(v, 0, _);
            }, b.setImmediate = function(_) {
              typeof _ != "function" && (_ = new Function("" + _));
              for (var T = new Array(arguments.length - 1), E = 0; E < T.length; E++)
                T[E] = arguments[E + 1];
              var A = { callback: _, args: T };
              return u[p] = A, l(p), p++;
            }, b.clearImmediate = h;
          }
          function h(_) {
            delete u[_];
          }
          function v(_) {
            if (g)
              setTimeout(v, 0, _);
            else {
              var T = u[_];
              if (T) {
                g = true;
                try {
                  (function(E) {
                    var A = E.callback, z = E.args;
                    switch (z.length) {
                      case 0:
                        A();
                        break;
                      case 1:
                        A(z[0]);
                        break;
                      case 2:
                        A(z[0], z[1]);
                        break;
                      case 3:
                        A(z[0], z[1], z[2]);
                        break;
                      default:
                        A.apply(n, z);
                    }
                  })(T);
                } finally {
                  h(_), g = false;
                }
              }
            }
          }
          function x(_) {
            _.source === o && typeof _.data == "string" && _.data.indexOf(f) === 0 && v(+_.data.slice(f.length));
          }
        })(typeof self > "u" ? r === void 0 ? this : r : self);
      }).call(this, typeof Pi < "u" ? Pi : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Gr);
var sa = Gr.exports;
var hr = ia(sa);
var Kr = {};
var Vi = {};
(function(a) {
  const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", e = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", i = "[" + t + "][" + e + "]*", s = new RegExp("^" + i + "$"), r = function(n, l) {
    const c = [];
    let d = l.exec(n);
    for (; d; ) {
      const f = [];
      f.startIndex = l.lastIndex - d[0].length;
      const p = d.length;
      for (let u = 0; u < p; u++)
        f.push(d[u]);
      c.push(f), d = l.exec(n);
    }
    return c;
  }, o = function(n) {
    const l = s.exec(n);
    return !(l === null || typeof l > "u");
  };
  a.isExist = function(n) {
    return typeof n < "u";
  }, a.isEmptyObject = function(n) {
    return Object.keys(n).length === 0;
  }, a.merge = function(n, l, c) {
    if (l) {
      const d = Object.keys(l), f = d.length;
      for (let p = 0; p < f; p++)
        c === "strict" ? n[d[p]] = [l[d[p]]] : n[d[p]] = l[d[p]];
    }
  }, a.getValue = function(n) {
    return a.isExist(n) ? n : "";
  }, a.isName = o, a.getAllMatches = r, a.nameRegexp = i;
})(Vi);
var Ds = Vi;
var ra = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
Kr.validate = function(a, t) {
  t = Object.assign({}, ra, t);
  const e = [];
  let i = false, s = false;
  a[0] === "\uFEFF" && (a = a.substr(1));
  for (let r = 0; r < a.length; r++)
    if (a[r] === "<" && a[r + 1] === "?") {
      if (r += 2, r = fr(a, r), r.err)
        return r;
    } else if (a[r] === "<") {
      let o = r;
      if (r++, a[r] === "!") {
        r = dr(a, r);
        continue;
      } else {
        let n = false;
        a[r] === "/" && (n = true, r++);
        let l = "";
        for (; r < a.length && a[r] !== ">" && a[r] !== " " && a[r] !== "	" && a[r] !== `
` && a[r] !== "\r"; r++)
          l += a[r];
        if (l = l.trim(), l[l.length - 1] === "/" && (l = l.substring(0, l.length - 1), r--), !fa(l)) {
          let f;
          return l.trim().length === 0 ? f = "Invalid space after '<'." : f = "Tag '" + l + "' is an invalid name.", Tt("InvalidTag", f, Pt(a, r));
        }
        const c = aa(a, r);
        if (c === false)
          return Tt("InvalidAttr", "Attributes for '" + l + "' have open quote.", Pt(a, r));
        let d = c.value;
        if (r = c.index, d[d.length - 1] === "/") {
          const f = r - d.length;
          d = d.substring(0, d.length - 1);
          const p = pr(d, t);
          if (p === true)
            i = true;
          else
            return Tt(p.err.code, p.err.msg, Pt(a, f + p.err.line));
        } else if (n)
          if (c.tagClosed) {
            if (d.trim().length > 0)
              return Tt("InvalidTag", "Closing tag '" + l + "' can't have attributes or invalid starting.", Pt(a, o));
            if (e.length === 0)
              return Tt("InvalidTag", "Closing tag '" + l + "' has not been opened.", Pt(a, o));
            {
              const f = e.pop();
              if (l !== f.tagName) {
                let p = Pt(a, f.tagStartPos);
                return Tt(
                  "InvalidTag",
                  "Expected closing tag '" + f.tagName + "' (opened in line " + p.line + ", col " + p.col + ") instead of closing tag '" + l + "'.",
                  Pt(a, o)
                );
              }
              e.length == 0 && (s = true);
            }
          } else
            return Tt("InvalidTag", "Closing tag '" + l + "' doesn't have proper closing.", Pt(a, r));
        else {
          const f = pr(d, t);
          if (f !== true)
            return Tt(f.err.code, f.err.msg, Pt(a, r - d.length + f.err.line));
          if (s === true)
            return Tt("InvalidXml", "Multiple possible root nodes found.", Pt(a, r));
          t.unpairedTags.indexOf(l) !== -1 || e.push({ tagName: l, tagStartPos: o }), i = true;
        }
        for (r++; r < a.length; r++)
          if (a[r] === "<")
            if (a[r + 1] === "!") {
              r++, r = dr(a, r);
              continue;
            } else if (a[r + 1] === "?") {
              if (r = fr(a, ++r), r.err)
                return r;
            } else
              break;
          else if (a[r] === "&") {
            const f = ha(a, r);
            if (f == -1)
              return Tt("InvalidChar", "char '&' is not expected.", Pt(a, r));
            r = f;
          } else if (s === true && !ur(a[r]))
            return Tt("InvalidXml", "Extra text at the end", Pt(a, r));
        a[r] === "<" && r--;
      }
    } else {
      if (ur(a[r]))
        continue;
      return Tt("InvalidChar", "char '" + a[r] + "' is not expected.", Pt(a, r));
    }
  if (i) {
    if (e.length == 1)
      return Tt("InvalidTag", "Unclosed tag '" + e[0].tagName + "'.", Pt(a, e[0].tagStartPos));
    if (e.length > 0)
      return Tt("InvalidXml", "Invalid '" + JSON.stringify(e.map((r) => r.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else
    return Tt("InvalidXml", "Start tag expected.", 1);
  return true;
};
function ur(a) {
  return a === " " || a === "	" || a === `
` || a === "\r";
}
function fr(a, t) {
  const e = t;
  for (; t < a.length; t++)
    if (a[t] == "?" || a[t] == " ") {
      const i = a.substr(e, t - e);
      if (t > 5 && i === "xml")
        return Tt("InvalidXml", "XML declaration allowed only at the start of the document.", Pt(a, t));
      if (a[t] == "?" && a[t + 1] == ">") {
        t++;
        break;
      } else
        continue;
    }
  return t;
}
function dr(a, t) {
  if (a.length > t + 5 && a[t + 1] === "-" && a[t + 2] === "-") {
    for (t += 3; t < a.length; t++)
      if (a[t] === "-" && a[t + 1] === "-" && a[t + 2] === ">") {
        t += 2;
        break;
      }
  } else if (a.length > t + 8 && a[t + 1] === "D" && a[t + 2] === "O" && a[t + 3] === "C" && a[t + 4] === "T" && a[t + 5] === "Y" && a[t + 6] === "P" && a[t + 7] === "E") {
    let e = 1;
    for (t += 8; t < a.length; t++)
      if (a[t] === "<")
        e++;
      else if (a[t] === ">" && (e--, e === 0))
        break;
  } else if (a.length > t + 9 && a[t + 1] === "[" && a[t + 2] === "C" && a[t + 3] === "D" && a[t + 4] === "A" && a[t + 5] === "T" && a[t + 6] === "A" && a[t + 7] === "[") {
    for (t += 8; t < a.length; t++)
      if (a[t] === "]" && a[t + 1] === "]" && a[t + 2] === ">") {
        t += 2;
        break;
      }
  }
  return t;
}
var na = '"';
var oa = "'";
function aa(a, t) {
  let e = "", i = "", s = false;
  for (; t < a.length; t++) {
    if (a[t] === na || a[t] === oa)
      i === "" ? i = a[t] : i !== a[t] || (i = "");
    else if (a[t] === ">" && i === "") {
      s = true;
      break;
    }
    e += a[t];
  }
  return i !== "" ? false : {
    value: e,
    index: t,
    tagClosed: s
  };
}
var la = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function pr(a, t) {
  const e = Ds.getAllMatches(a, la), i = {};
  for (let s = 0; s < e.length; s++) {
    if (e[s][1].length === 0)
      return Tt("InvalidAttr", "Attribute '" + e[s][2] + "' has no space in starting.", ti(e[s]));
    if (e[s][3] !== void 0 && e[s][4] === void 0)
      return Tt("InvalidAttr", "Attribute '" + e[s][2] + "' is without value.", ti(e[s]));
    if (e[s][3] === void 0 && !t.allowBooleanAttributes)
      return Tt("InvalidAttr", "boolean attribute '" + e[s][2] + "' is not allowed.", ti(e[s]));
    const r = e[s][2];
    if (!ua(r))
      return Tt("InvalidAttr", "Attribute '" + r + "' is an invalid name.", ti(e[s]));
    if (!i.hasOwnProperty(r))
      i[r] = 1;
    else
      return Tt("InvalidAttr", "Attribute '" + r + "' is repeated.", ti(e[s]));
  }
  return true;
}
function ca(a, t) {
  let e = /\d/;
  for (a[t] === "x" && (t++, e = /[\da-fA-F]/); t < a.length; t++) {
    if (a[t] === ";")
      return t;
    if (!a[t].match(e))
      break;
  }
  return -1;
}
function ha(a, t) {
  if (t++, a[t] === ";")
    return -1;
  if (a[t] === "#")
    return t++, ca(a, t);
  let e = 0;
  for (; t < a.length; t++, e++)
    if (!(a[t].match(/\w/) && e < 20)) {
      if (a[t] === ";")
        break;
      return -1;
    }
  return t;
}
function Tt(a, t, e) {
  return {
    err: {
      code: a,
      msg: t,
      line: e.line || e,
      col: e.col
    }
  };
}
function ua(a) {
  return Ds.isName(a);
}
function fa(a) {
  return Ds.isName(a);
}
function Pt(a, t) {
  const e = a.substring(0, t).split(/\r?\n/);
  return {
    line: e.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: e[e.length - 1].length + 1
  };
}
function ti(a) {
  return a.startIndex + a[1].length;
}
var Ps = {};
var Xr = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(a, t) {
    return t;
  },
  attributeValueProcessor: function(a, t) {
    return t;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(a, t, e) {
    return a;
  }
  // skipEmptyListItem: false
};
var da = function(a) {
  return Object.assign({}, Xr, a);
};
Ps.buildOptions = da;
Ps.defaultOptions = Xr;
var pa = class {
  constructor(t) {
    this.tagname = t, this.child = [], this[":@"] = {};
  }
  add(t, e) {
    t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: e });
  }
  addChild(t) {
    t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child });
  }
};
var ma = pa;
var ga = Vi;
function va(a, t) {
  const e = {};
  if (a[t + 3] === "O" && a[t + 4] === "C" && a[t + 5] === "T" && a[t + 6] === "Y" && a[t + 7] === "P" && a[t + 8] === "E") {
    t = t + 9;
    let i = 1, s = false, r = false, o = "";
    for (; t < a.length; t++)
      if (a[t] === "<" && !r) {
        if (s && ba(a, t))
          t += 7, [entityName, val, t] = ya(a, t + 1), val.indexOf("&") === -1 && (e[Ca(entityName)] = {
            regx: RegExp(`&${entityName};`, "g"),
            val
          });
        else if (s && xa(a, t))
          t += 8;
        else if (s && _a(a, t))
          t += 8;
        else if (s && Ta(a, t))
          t += 9;
        else if (wa)
          r = true;
        else
          throw new Error("Invalid DOCTYPE");
        i++, o = "";
      } else if (a[t] === ">") {
        if (r ? a[t - 1] === "-" && a[t - 2] === "-" && (r = false, i--) : i--, i === 0)
          break;
      } else
        a[t] === "[" ? s = true : o += a[t];
    if (i !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: e, i: t };
}
function ya(a, t) {
  let e = "";
  for (; t < a.length && a[t] !== "'" && a[t] !== '"'; t++)
    e += a[t];
  if (e = e.trim(), e.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const i = a[t++];
  let s = "";
  for (; t < a.length && a[t] !== i; t++)
    s += a[t];
  return [e, s, t];
}
function wa(a, t) {
  return a[t + 1] === "!" && a[t + 2] === "-" && a[t + 3] === "-";
}
function ba(a, t) {
  return a[t + 1] === "!" && a[t + 2] === "E" && a[t + 3] === "N" && a[t + 4] === "T" && a[t + 5] === "I" && a[t + 6] === "T" && a[t + 7] === "Y";
}
function xa(a, t) {
  return a[t + 1] === "!" && a[t + 2] === "E" && a[t + 3] === "L" && a[t + 4] === "E" && a[t + 5] === "M" && a[t + 6] === "E" && a[t + 7] === "N" && a[t + 8] === "T";
}
function _a(a, t) {
  return a[t + 1] === "!" && a[t + 2] === "A" && a[t + 3] === "T" && a[t + 4] === "T" && a[t + 5] === "L" && a[t + 6] === "I" && a[t + 7] === "S" && a[t + 8] === "T";
}
function Ta(a, t) {
  return a[t + 1] === "!" && a[t + 2] === "N" && a[t + 3] === "O" && a[t + 4] === "T" && a[t + 5] === "A" && a[t + 6] === "T" && a[t + 7] === "I" && a[t + 8] === "O" && a[t + 9] === "N";
}
function Ca(a) {
  if (ga.isName(a))
    return a;
  throw new Error(`Invalid entity name ${a}`);
}
var Sa = va;
var Ea = /^[-+]?0x[a-fA-F0-9]+$/;
var Aa = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
var Oa = {
  hex: true,
  // oct: false,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function Da(a, t = {}) {
  if (t = Object.assign({}, Oa, t), !a || typeof a != "string")
    return a;
  let e = a.trim();
  if (t.skipLike !== void 0 && t.skipLike.test(e))
    return a;
  if (t.hex && Ea.test(e))
    return za(e, 16);
  if (e.search(/[eE]/) !== -1) {
    const i = e.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)/);
    if (i) {
      if (t.leadingZeros)
        e = (i[1] || "") + i[3];
      else if (!(i[2] === "0" && i[3][0] === "."))
        return e;
      return t.eNotation ? Number(e) : e;
    } else
      return e;
  } else {
    const i = Aa.exec(e);
    if (i) {
      const s = i[1], r = i[2];
      let o = Pa(i[3]);
      if (!t.leadingZeros && r.length > 0 && s && e[2] !== ".")
        return a;
      if (!t.leadingZeros && r.length > 0 && !s && e[1] !== ".")
        return a;
      {
        const n = Number(e), l = "" + n;
        return l.search(/[eE]/) !== -1 ? t.eNotation ? n : a : e.indexOf(".") !== -1 ? l === "0" && o === "" || l === o || s && l === "-" + o ? n : a : r ? o === l || s + o === l ? n : a : e === l || e === s + l ? n : a;
      }
    } else
      return a;
  }
}
function Pa(a) {
  return a && a.indexOf(".") !== -1 && (a = a.replace(/0+$/, ""), a === "." ? a = "0" : a[0] === "." ? a = "0" + a : a[a.length - 1] === "." && (a = a.substr(0, a.length - 1))), a;
}
function za(a, t) {
  if (parseInt)
    return parseInt(a, t);
  if (Number.parseInt)
    return Number.parseInt(a, t);
  if (window && window.parseInt)
    return window.parseInt(a, t);
  throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}
var ka = Da;
var qr = Vi;
var ei = ma;
var Ba = Sa;
var Ia = ka;
var Ma = class {
  constructor(t) {
    this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "" },
      pound: { regex: /&(pound|#163);/g, val: "" },
      yen: { regex: /&(yen|#165);/g, val: "" },
      euro: { regex: /&(euro|#8364);/g, val: "" },
      copyright: { regex: /&(copy|#169);/g, val: "" },
      reg: { regex: /&(reg|#174);/g, val: "" },
      inr: { regex: /&(inr|#8377);/g, val: "" },
      num_dec: { regex: /&#([0-9]{1,7});/g, val: (e, i) => String.fromCharCode(Number.parseInt(i, 10)) },
      num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (e, i) => String.fromCharCode(Number.parseInt(i, 16)) }
    }, this.addExternalEntities = Ra, this.parseXml = Va, this.parseTextData = La, this.resolveNameSpace = Fa, this.buildAttributesMap = Na, this.isItStopNode = Ya, this.replaceEntitiesValue = Za, this.readStopNodeData = Qa, this.saveTextToParentTag = Wa, this.addChild = Ha;
  }
};
function Ra(a) {
  const t = Object.keys(a);
  for (let e = 0; e < t.length; e++) {
    const i = t[e];
    this.lastEntities[i] = {
      regex: new RegExp("&" + i + ";", "g"),
      val: a[i]
    };
  }
}
function La(a, t, e, i, s, r, o) {
  if (a !== void 0 && (this.options.trimValues && !i && (a = a.trim()), a.length > 0)) {
    o || (a = this.replaceEntitiesValue(a));
    const n = this.options.tagValueProcessor(t, a, e, s, r);
    return n == null ? a : typeof n != typeof a || n !== a ? n : this.options.trimValues ? ws(a, this.options.parseTagValue, this.options.numberParseOptions) : a.trim() === a ? ws(a, this.options.parseTagValue, this.options.numberParseOptions) : a;
  }
}
function Fa(a) {
  if (this.options.removeNSPrefix) {
    const t = a.split(":"), e = a.charAt(0) === "/" ? "/" : "";
    if (t[0] === "xmlns")
      return "";
    t.length === 2 && (a = e + t[1]);
  }
  return a;
}
var Ua = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function Na(a, t, e) {
  if (!this.options.ignoreAttributes && typeof a == "string") {
    const i = qr.getAllMatches(a, Ua), s = i.length, r = {};
    for (let o = 0; o < s; o++) {
      const n = this.resolveNameSpace(i[o][1]);
      let l = i[o][4], c = this.options.attributeNamePrefix + n;
      if (n.length)
        if (this.options.transformAttributeName && (c = this.options.transformAttributeName(c)), c === "__proto__" && (c = "#__proto__"), l !== void 0) {
          this.options.trimValues && (l = l.trim()), l = this.replaceEntitiesValue(l);
          const d = this.options.attributeValueProcessor(n, l, t);
          d == null ? r[c] = l : typeof d != typeof l || d !== l ? r[c] = d : r[c] = ws(
            l,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else
          this.options.allowBooleanAttributes && (r[c] = true);
    }
    if (!Object.keys(r).length)
      return;
    if (this.options.attributesGroupName) {
      const o = {};
      return o[this.options.attributesGroupName] = r, o;
    }
    return r;
  }
}
var Va = function(a) {
  a = a.replace(/\r\n?/g, `
`);
  const t = new ei("!xml");
  let e = t, i = "", s = "";
  for (let r = 0; r < a.length; r++)
    if (a[r] === "<")
      if (a[r + 1] === "/") {
        const n = ye(a, ">", r, "Closing Tag is not closed.");
        let l = a.substring(r + 2, n).trim();
        if (this.options.removeNSPrefix) {
          const f = l.indexOf(":");
          f !== -1 && (l = l.substr(f + 1));
        }
        this.options.transformTagName && (l = this.options.transformTagName(l)), e && (i = this.saveTextToParentTag(i, e, s));
        const c = s.substring(s.lastIndexOf(".") + 1);
        if (l && this.options.unpairedTags.indexOf(l) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${l}>`);
        let d = 0;
        c && this.options.unpairedTags.indexOf(c) !== -1 ? (d = s.lastIndexOf(".", s.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : d = s.lastIndexOf("."), s = s.substring(0, d), e = this.tagsNodeStack.pop(), i = "", r = n;
      } else if (a[r + 1] === "?") {
        let n = ys(a, r, false, "?>");
        if (!n)
          throw new Error("Pi Tag is not closed.");
        if (i = this.saveTextToParentTag(i, e, s), !(this.options.ignoreDeclaration && n.tagName === "?xml" || this.options.ignorePiTags)) {
          const l = new ei(n.tagName);
          l.add(this.options.textNodeName, ""), n.tagName !== n.tagExp && n.attrExpPresent && (l[":@"] = this.buildAttributesMap(n.tagExp, s, n.tagName)), this.addChild(e, l, s);
        }
        r = n.closeIndex + 1;
      } else if (a.substr(r + 1, 3) === "!--") {
        const n = ye(a, "-->", r + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const l = a.substring(r + 4, n - 2);
          i = this.saveTextToParentTag(i, e, s), e.add(this.options.commentPropName, [{ [this.options.textNodeName]: l }]);
        }
        r = n;
      } else if (a.substr(r + 1, 2) === "!D") {
        const n = Ba(a, r);
        this.docTypeEntities = n.entities, r = n.i;
      } else if (a.substr(r + 1, 2) === "![") {
        const n = ye(a, "]]>", r, "CDATA is not closed.") - 2, l = a.substring(r + 9, n);
        i = this.saveTextToParentTag(i, e, s);
        let c = this.parseTextData(l, e.tagname, s, true, false, true, true);
        c == null && (c = ""), this.options.cdataPropName ? e.add(this.options.cdataPropName, [{ [this.options.textNodeName]: l }]) : e.add(this.options.textNodeName, c), r = n + 2;
      } else {
        let n = ys(a, r, this.options.removeNSPrefix), l = n.tagName;
        const c = n.rawTagName;
        let d = n.tagExp, f = n.attrExpPresent, p = n.closeIndex;
        this.options.transformTagName && (l = this.options.transformTagName(l)), e && i && e.tagname !== "!xml" && (i = this.saveTextToParentTag(i, e, s, false));
        const u = e;
        if (u && this.options.unpairedTags.indexOf(u.tagname) !== -1 && (e = this.tagsNodeStack.pop(), s = s.substring(0, s.lastIndexOf("."))), l !== t.tagname && (s += s ? "." + l : l), this.isItStopNode(this.options.stopNodes, s, l)) {
          let g = "";
          if (d.length > 0 && d.lastIndexOf("/") === d.length - 1)
            l[l.length - 1] === "/" ? (l = l.substr(0, l.length - 1), s = s.substr(0, s.length - 1), d = l) : d = d.substr(0, d.length - 1), r = n.closeIndex;
          else if (this.options.unpairedTags.indexOf(l) !== -1)
            r = n.closeIndex;
          else {
            const b = this.readStopNodeData(a, c, p + 1);
            if (!b)
              throw new Error(`Unexpected end of ${c}`);
            r = b.i, g = b.tagContent;
          }
          const m = new ei(l);
          l !== d && f && (m[":@"] = this.buildAttributesMap(d, s, l)), g && (g = this.parseTextData(g, l, s, true, f, true, true)), s = s.substr(0, s.lastIndexOf(".")), m.add(this.options.textNodeName, g), this.addChild(e, m, s);
        } else {
          if (d.length > 0 && d.lastIndexOf("/") === d.length - 1) {
            l[l.length - 1] === "/" ? (l = l.substr(0, l.length - 1), s = s.substr(0, s.length - 1), d = l) : d = d.substr(0, d.length - 1), this.options.transformTagName && (l = this.options.transformTagName(l));
            const g = new ei(l);
            l !== d && f && (g[":@"] = this.buildAttributesMap(d, s, l)), this.addChild(e, g, s), s = s.substr(0, s.lastIndexOf("."));
          } else {
            const g = new ei(l);
            this.tagsNodeStack.push(e), l !== d && f && (g[":@"] = this.buildAttributesMap(d, s, l)), this.addChild(e, g, s), e = g;
          }
          i = "", r = p;
        }
      }
    else
      i += a[r];
  return t.child;
};
function Ha(a, t, e) {
  const i = this.options.updateTag(t.tagname, e, t[":@"]);
  i === false || (typeof i == "string" && (t.tagname = i), a.addChild(t));
}
var Za = function(a) {
  if (this.options.processEntities) {
    for (let t in this.docTypeEntities) {
      const e = this.docTypeEntities[t];
      a = a.replace(e.regx, e.val);
    }
    for (let t in this.lastEntities) {
      const e = this.lastEntities[t];
      a = a.replace(e.regex, e.val);
    }
    if (this.options.htmlEntities)
      for (let t in this.htmlEntities) {
        const e = this.htmlEntities[t];
        a = a.replace(e.regex, e.val);
      }
    a = a.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return a;
};
function Wa(a, t, e, i) {
  return a && (i === void 0 && (i = Object.keys(t.child).length === 0), a = this.parseTextData(
    a,
    t.tagname,
    e,
    false,
    t[":@"] ? Object.keys(t[":@"]).length !== 0 : false,
    i
  ), a !== void 0 && a !== "" && t.add(this.options.textNodeName, a), a = ""), a;
}
function Ya(a, t, e) {
  const i = "*." + e;
  for (const s in a) {
    const r = a[s];
    if (i === r || t === r)
      return true;
  }
  return false;
}
function ja(a, t, e = ">") {
  let i, s = "";
  for (let r = t; r < a.length; r++) {
    let o = a[r];
    if (i)
      o === i && (i = "");
    else if (o === '"' || o === "'")
      i = o;
    else if (o === e[0])
      if (e[1]) {
        if (a[r + 1] === e[1])
          return {
            data: s,
            index: r
          };
      } else
        return {
          data: s,
          index: r
        };
    else
      o === "	" && (o = " ");
    s += o;
  }
}
function ye(a, t, e, i) {
  const s = a.indexOf(t, e);
  if (s === -1)
    throw new Error(i);
  return s + t.length - 1;
}
function ys(a, t, e, i = ">") {
  const s = ja(a, t + 1, i);
  if (!s)
    return;
  let r = s.data;
  const o = s.index, n = r.search(/\s/);
  let l = r, c = true;
  n !== -1 && (l = r.substring(0, n), r = r.substring(n + 1).trimStart());
  const d = l;
  if (e) {
    const f = l.indexOf(":");
    f !== -1 && (l = l.substr(f + 1), c = l !== s.data.substr(f + 1));
  }
  return {
    tagName: l,
    tagExp: r,
    closeIndex: o,
    attrExpPresent: c,
    rawTagName: d
  };
}
function Qa(a, t, e) {
  const i = e;
  let s = 1;
  for (; e < a.length; e++)
    if (a[e] === "<")
      if (a[e + 1] === "/") {
        const r = ye(a, ">", e, `${t} is not closed`);
        if (a.substring(e + 2, r).trim() === t && (s--, s === 0))
          return {
            tagContent: a.substring(i, e),
            i: r
          };
        e = r;
      } else if (a[e + 1] === "?")
        e = ye(a, "?>", e + 1, "StopNode is not closed.");
      else if (a.substr(e + 1, 3) === "!--")
        e = ye(a, "-->", e + 3, "StopNode is not closed.");
      else if (a.substr(e + 1, 2) === "![")
        e = ye(a, "]]>", e, "StopNode is not closed.") - 2;
      else {
        const r = ys(a, e, ">");
        r && ((r && r.tagName) === t && r.tagExp[r.tagExp.length - 1] !== "/" && s++, e = r.closeIndex);
      }
}
function ws(a, t, e) {
  if (t && typeof a == "string") {
    const i = a.trim();
    return i === "true" ? true : i === "false" ? false : Ia(a, e);
  } else
    return qr.isExist(a) ? a : "";
}
var Ga = Ma;
var Jr = {};
function Ka(a, t) {
  return $r(a, t);
}
function $r(a, t, e) {
  let i;
  const s = {};
  for (let r = 0; r < a.length; r++) {
    const o = a[r], n = Xa(o);
    let l = "";
    if (e === void 0 ? l = n : l = e + "." + n, n === t.textNodeName)
      i === void 0 ? i = o[n] : i += "" + o[n];
    else {
      if (n === void 0)
        continue;
      if (o[n]) {
        let c = $r(o[n], t, l);
        const d = Ja(c, t);
        o[":@"] ? qa(c, o[":@"], l, t) : Object.keys(c).length === 1 && c[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? c = c[t.textNodeName] : Object.keys(c).length === 0 && (t.alwaysCreateTextNode ? c[t.textNodeName] = "" : c = ""), s[n] !== void 0 && s.hasOwnProperty(n) ? (Array.isArray(s[n]) || (s[n] = [s[n]]), s[n].push(c)) : t.isArray(n, l, d) ? s[n] = [c] : s[n] = c;
      }
    }
  }
  return typeof i == "string" ? i.length > 0 && (s[t.textNodeName] = i) : i !== void 0 && (s[t.textNodeName] = i), s;
}
function Xa(a) {
  const t = Object.keys(a);
  for (let e = 0; e < t.length; e++) {
    const i = t[e];
    if (i !== ":@")
      return i;
  }
}
function qa(a, t, e, i) {
  if (t) {
    const s = Object.keys(t), r = s.length;
    for (let o = 0; o < r; o++) {
      const n = s[o];
      i.isArray(n, e + "." + n, true, true) ? a[n] = [t[n]] : a[n] = t[n];
    }
  }
}
function Ja(a, t) {
  const { textNodeName: e } = t, i = Object.keys(a).length;
  return !!(i === 0 || i === 1 && (a[e] || typeof a[e] == "boolean" || a[e] === 0));
}
Jr.prettify = Ka;
var { buildOptions: $a } = Ps;
var tl = Ga;
var { prettify: el } = Jr;
var il = Kr;
var sl = class {
  constructor(t) {
    this.externalEntities = {}, this.options = $a(t);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(t, e) {
    if (typeof t != "string")
      if (t.toString)
        t = t.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
    if (e) {
      e === true && (e = {});
      const r = il.validate(t, e);
      if (r !== true)
        throw Error(`${r.err.msg}:${r.err.line}:${r.err.col}`);
    }
    const i = new tl(this.options);
    i.addExternalEntities(this.externalEntities);
    const s = i.parseXml(t);
    return this.options.preserveOrder || s === void 0 ? s : el(s, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(t, e) {
    if (e.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (e === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[t] = e;
  }
};
var rl = sl;
var nl = rl;
var ol = {
  XMLParser: nl
};
var bs = class {
  /**
   * Constructs a new BCF Topic Comment instance.
   * @param components - The Components instance.
   * @param text - The initial comment text.
   */
  constructor(t, e) {
    P(this, "date", /* @__PURE__ */ new Date()), P(this, "author"), P(this, "guid", Le.create()), P(this, "viewpoint"), P(this, "modifiedAuthor"), P(this, "modifiedDate"), P(this, "topic"), P(this, "_components"), P(this, "_comment", ""), this._components = t, this._comment = e;
    const i = this._components.get(zt);
    this.author = i.config.author;
  }
  /**
   * Sets the comment text and updates the modified date and author.
   * The author will be the one defined in BCFTopics.config.author
   * @param value - The new comment text.
   */
  set comment(t) {
    var e;
    const i = this._components.get(zt);
    this._comment = t, this.modifiedDate = /* @__PURE__ */ new Date(), this.modifiedAuthor = i.config.author, (e = this.topic) == null || e.comments.set(this.guid, this);
  }
  /**
   * Gets the comment text.
   * @returns The comment text.
   */
  get comment() {
    return this._comment;
  }
  /**
   * Serializes the Comment instance into a BCF compliant XML string.
   *
   * @returns A string representing the Comment in BCFv2 XML format.
   */
  serialize() {
    let t = null;
    this.viewpoint && (t = `<Viewpoint Guid="${this.viewpoint.guid}"/>`);
    let e = null;
    this.modifiedDate && (e = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`);
    let i = null;
    return this.modifiedAuthor && (i = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`), `
      <Comment Guid="${this.guid}">
        <Date>${this.date.toISOString()}</Date>
        <Author>${this.author}</Author>
        <Comment>${this.comment}</Comment>
        ${t ?? ""}
        ${i ?? ""}
        ${e ?? ""}
      </Comment>
    `;
  }
};
var tn = class he {
  /**
   * Initializes a new instance of the `Topic` class representing a BCF (BIM Collaboration Format) topic.
   * It provides methods and properties to manage and serialize BCF topics.
   *
   * @remarks
   * The default creationUser is the one set in BCFTopics.config.author
   * It should not be created manually. Better use BCFTopics.create().
   *
   * @param components - The `Components` instance that provides access to other components and services.
   */
  constructor(t) {
    P(this, "guid", Le.create()), P(this, "title", he.default.title), P(this, "creationDate", /* @__PURE__ */ new Date()), P(this, "creationAuthor", ""), P(this, "viewpoints", new Bi()), P(this, "relatedTopics", new Bi()), P(this, "comments", new Re()), P(this, "customData", {}), P(this, "description"), P(this, "serverAssignedId"), P(this, "dueDate"), P(this, "modifiedAuthor"), P(this, "modifiedDate"), P(this, "index"), P(this, "_type", he.default.type), P(this, "_status", he.default.status), P(this, "_priority", he.default.priority), P(this, "_stage", he.default.stage), P(this, "_assignedTo", he.default.assignedTo), P(this, "_labels", he.default.labels ?? /* @__PURE__ */ new Set()), P(this, "_components"), this._components = t;
    const e = t.get(zt);
    this.creationAuthor = e.config.author, this.relatedTopics.guard = (i) => i !== this.guid;
  }
  set type(t) {
    const e = this._components.get(zt), { strict: i, types: s } = e.config;
    (!i || s.has(t)) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  set status(t) {
    const e = this._components.get(zt), { strict: i, statuses: s } = e.config;
    (!i || s.has(t)) && (this._status = t);
  }
  get status() {
    return this._status;
  }
  set priority(t) {
    const e = this._components.get(zt);
    if (t) {
      const { strict: i, priorities: s } = e.config;
      if (!(i ? s.has(t) : true))
        return;
      this._priority = t;
    } else
      this._priority = t;
  }
  get priority() {
    return this._priority;
  }
  set stage(t) {
    const e = this._components.get(zt);
    if (t) {
      const { strict: i, stages: s } = e.config;
      if (!(i ? s.has(t) : true))
        return;
      this._stage = t;
    } else
      this._stage = t;
  }
  get stage() {
    return this._stage;
  }
  set assignedTo(t) {
    const e = this._components.get(zt);
    if (t) {
      const { strict: i, users: s } = e.config;
      if (!(i ? s.has(t) : true))
        return;
      this._assignedTo = t;
    } else
      this._assignedTo = t;
  }
  get assignedTo() {
    return this._assignedTo;
  }
  set labels(t) {
    const e = this._components.get(zt), { strict: i, labels: s } = e.config;
    if (i) {
      const r = /* @__PURE__ */ new Set();
      for (const o of t)
        (!i || s.has(o)) && r.add(o);
      this._labels = r;
    } else
      this._labels = t;
  }
  get labels() {
    return this._labels;
  }
  get _managerVersion() {
    return this._components.get(zt).config.version;
  }
  /**
   * Sets properties of the BCF Topic based on the provided data.
   *
   * @remarks
   * This method iterates over the provided `data` object and updates the corresponding properties of the BCF Topic.
   * It skips the `guid` property as it should not be modified.
   *
   * @param data - An object containing the properties to be updated.
   * @returns The topic
   *
   * @example
   * ```typescript
   * const topic = new Topic(components);
   * topic.set({
   *   title: "New BCF Topic Title",
   *   description: "This is a new description.",
   *   status: "Resolved",
   * });
   * ```
   */
  set(t) {
    const e = t, i = this;
    for (const r in t) {
      if (r === "guid")
        continue;
      const o = e[r];
      r in this && (i[r] = o);
    }
    return this._components.get(zt).list.set(this.guid, this), this;
  }
  /**
   * Creates a new comment associated with the current topic.
   *
   * @param text - The text content of the comment.
   * @param viewpoint - (Optional) The viewpoint associated with the comment.
   *
   * @returns The newly created comment.
   *
   * @example
   * ```typescript
   * const viewpoint = viewpoints.create(world); // Created with an instance of Viewpoints
   * const topic = topics.create(); // Created with an instance of BCFTopics
   * topic.viewpoints.add(viewpoint);
   * const comment = topic.createComment("This is a new comment", viewpoint);
   * ```
   */
  createComment(t, e) {
    const i = new bs(this._components, t);
    return i.viewpoint = e, i.topic = this, this.comments.set(i.guid, i), i;
  }
  createLabelTags(t = this._managerVersion) {
    let e = "Labels";
    t === "2.1" && (e = "Labels"), t === "3" && (e = "Label");
    let i = [...this.labels].map((s) => `<${e}>${s}</${e}>`).join(`
`);
    for (const s in this.customData) {
      const r = this.customData[s];
      typeof r == "string" && (i += `
<${e}>${r}</${e}>`);
    }
    return t === "2.1" ? i : t === "3" ? i.length !== 0 ? `<Labels>
${i}
</Labels>` : "<Labels/>" : i;
  }
  createCommentTags(t = this._managerVersion) {
    const e = [...this.comments.values()].map((i) => i.serialize()).join(`
`);
    return t === "2.1" ? e : t === "3" ? e.length !== 0 ? `<Comments>
${e}
</Comments>` : "<Comments/>" : e;
  }
  createViewpointTags(t = this._managerVersion) {
    let e = "Viewpoints";
    t === "2.1" && (e = "Viewpoints"), t === "3" && (e = "ViewPoint");
    const i = this._components.get(de), r = [...this.viewpoints].map((o) => i.list.get(o)).filter((o) => o).map((o) => `<${e} Guid="${o.guid}">
          <Viewpoint>${o.guid}.bcfv</Viewpoint>
          <Snapshot>${o.guid}.jpeg</Snapshot>
        </${e}>
      `).join(`
`);
    return t === "2.1" ? r : t === "3" ? r.length !== 0 ? `<Viewpoints>
${r}
</Viewpoints>` : "<Viewpoints />" : r;
  }
  createRelatedTopicTags(t = this._managerVersion) {
    const e = [...this.relatedTopics].map(
      (i) => `<RelatedTopic Guid="${i}"></RelatedTopic>
      `
    ).join(`
`);
    return t === "2.1" ? e : t === "3" ? e.length !== 0 ? `<RelatedTopics>
${e}
</RelatedTopics>` : "<RelatedTopics />" : e;
  }
  /**
   * Serializes the BCF Topic instance into an XML string representation based on the official schema.
   *
   * @remarks
   * This method constructs an XML string based on the properties of the BCF Topic instance.
   * It includes the topic's guid, type, status, creation date, creation author, priority, index,
   * modified date, modified author, due date, assigned to, description, stage, labels, related topics,
   * comments, and viewpoints.
   *
   * @returns A string representing the XML serialization of the BCF Topic.
   *
   * @example
   * ```typescript
   * const topic = bcfTopics.create(); // Created with an instance of BCFTopics
   * const xml = topic.serialize();
   * console.log(xml);
   * ```
   */
  serialize() {
    const t = this._managerVersion;
    let e = null;
    this.serverAssignedId && (e = `ServerAssignedId="${this.serverAssignedId}"`);
    let i = null;
    this.priority && (i = `<Priority>${this.priority}</Priority>`);
    let s = null;
    this.index && t === "2.1" && (s = `<Index>${this.index}</Index>`);
    let r = null;
    this.modifiedDate && (r = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`);
    let o = null;
    this.modifiedAuthor && (o = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`);
    let n = null;
    this.dueDate && (n = `<DueDate>${this.dueDate.toISOString()}</DueDate>`);
    let l = null;
    this.assignedTo && (l = `<AssignedTo>${this.assignedTo}</AssignedTo>`);
    let c = null;
    this.description && (c = `<Description>${this.description}</Description>`);
    let d = null;
    this.stage && (d = `<Stage>${this.stage}</Stage>`);
    const f = this.createCommentTags(t), p = this.createViewpointTags(t), u = this.createLabelTags(t), g = this.createRelatedTopicTags(t);
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Markup>
        <Topic Guid="${this.guid}" TopicType="${this.type}" TopicStatus="${this.status}" ${e ?? ""}>
          <Title>${this.title}</Title>
          <CreationDate>${this.creationDate.toISOString()}</CreationDate>
          <CreationAuthor>${this.creationAuthor}</CreationAuthor>
          ${i ?? ""}
          ${s ?? ""}
          ${r ?? ""}
          ${o ?? ""}
          ${n ?? ""}
          ${l ?? ""}
          ${c ?? ""}
          ${d ?? ""}
          ${u}
          ${g}
          ${t === "3" ? f : ""}
          ${t === "3" ? p : ""}
        </Topic>
        ${t === "2.1" ? f : ""}
        ${t === "2.1" ? p : ""}
      </Markup>
    `;
  }
};
P(tn, "default", {
  title: "BCF Topic",
  type: "Issue",
  status: "Active"
});
var mr = tn;
var al = (a, t) => {
  if (t.trim() === "")
    return;
  const e = zt.xmlParser.parse(t).Extensions;
  if (!e)
    return;
  const { Priorities: i, TopicStatuses: s, TopicTypes: r, Users: o } = e;
  if (i && i.Priority) {
    const n = Array.isArray(i.Priority) ? i.Priority : [i.Priority];
    for (const l of n)
      a.config.priorities.add(l);
  }
  if (s && s.TopicStatus) {
    const n = Array.isArray(s.TopicStatus) ? s.TopicStatus : [s.TopicStatus];
    for (const l of n)
      a.config.statuses.add(l);
  }
  if (r && r.TopicType) {
    const n = Array.isArray(r.TopicType) ? r.TopicType : [r.TopicType];
    for (const l of n)
      a.config.types.add(l);
  }
  if (o && o.User) {
    const n = Array.isArray(o.User) ? o.User : [o.User];
    for (const l of n)
      a.config.users.add(l);
  }
};
var ll = class extends Ss {
  constructor() {
    super(...arguments), P(this, "_config", {
      version: {
        type: "Select",
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        multiple: false,
        value: ""
      },
      author: {
        type: "Text",
        value: ""
      },
      types: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      statuses: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      priorities: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      labels: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      stages: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      users: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      includeSelectionTag: {
        type: "Boolean",
        value: false
      },
      updateExtensionsOnImport: {
        type: "Boolean",
        value: false
      },
      strict: {
        type: "Boolean",
        value: false
      },
      includeAllExtensionsOnExport: {
        type: "Boolean",
        value: false
      },
      fallbackVersionOnImport: {
        type: "Select",
        multiple: false,
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        value: ""
      },
      ignoreIncompleteTopicsOnImport: {
        type: "Boolean",
        value: false
      }
    });
  }
  get version() {
    return this._config.version.value;
  }
  set version(t) {
    this._config.version.value = t;
  }
  get author() {
    return this._config.author.value;
  }
  set author(t) {
    this._config.author.value = t;
  }
  get types() {
    return this._config.types.value;
  }
  set types(t) {
    this._config.types.value = t;
  }
  get statuses() {
    return this._config.statuses.value;
  }
  set statuses(t) {
    this._config.statuses.value = t;
  }
  get priorities() {
    return this._config.priorities.value;
  }
  set priorities(t) {
    this._config.priorities.value = t;
  }
  get labels() {
    return this._config.labels.value;
  }
  set labels(t) {
    this._config.labels.value = t;
  }
  get stages() {
    return this._config.stages.value;
  }
  set stages(t) {
    this._config.stages.value = t;
  }
  get users() {
    return this._config.users.value;
  }
  set users(t) {
    this._config.users.value = t;
  }
  get includeSelectionTag() {
    return this._config.includeSelectionTag.value;
  }
  set includeSelectionTag(t) {
    this._config.includeSelectionTag.value = t;
  }
  get updateExtensionsOnImport() {
    return this._config.updateExtensionsOnImport.value;
  }
  set updateExtensionsOnImport(t) {
    this._config.updateExtensionsOnImport.value = t;
  }
  get strict() {
    return this._config.strict.value;
  }
  set strict(t) {
    this._config.strict.value = t;
  }
  get includeAllExtensionsOnExport() {
    return this._config.includeAllExtensionsOnExport.value;
  }
  set includeAllExtensionsOnExport(t) {
    this._config.includeAllExtensionsOnExport.value = t;
  }
  get fallbackVersionOnImport() {
    return this._config.fallbackVersionOnImport.value;
  }
  set fallbackVersionOnImport(t) {
    this._config.fallbackVersionOnImport.value = t;
  }
  get ignoreIncompleteTopicsOnImport() {
    return this._config.ignoreIncompleteTopicsOnImport.value;
  }
  set ignoreIncompleteTopicsOnImport(t) {
    this._config.ignoreIncompleteTopicsOnImport.value = t;
  }
};
var zs = class ri extends Zt {
  constructor() {
    super(...arguments), P(this, "enabled", false), P(this, "_defaultConfig", {
      author: "jhon.doe@example.com",
      version: "2.1",
      types: /* @__PURE__ */ new Set([
        "Clash",
        "Failure",
        "Fault",
        "Inquiry",
        "Issue",
        "Remark",
        "Request"
      ]),
      statuses: /* @__PURE__ */ new Set(["Active", "In Progress", "Done", "In Review", "Closed"]),
      priorities: /* @__PURE__ */ new Set(["On hold", "Minor", "Normal", "Major", "Critical"]),
      labels: /* @__PURE__ */ new Set(),
      stages: /* @__PURE__ */ new Set(),
      users: /* @__PURE__ */ new Set(),
      includeSelectionTag: false,
      updateExtensionsOnImport: true,
      strict: false,
      includeAllExtensionsOnExport: true,
      fallbackVersionOnImport: "2.1",
      ignoreIncompleteTopicsOnImport: false
    }), P(this, "config", new ll(
      this,
      this.components,
      "BCF Topics",
      ri.uuid
    )), P(this, "list", new Re()), P(this, "onSetup", new it()), P(this, "isSetup", false), P(this, "onBCFImported", new it()), P(this, "onDisposed", new it());
  }
  setup(t) {
    if (this.isSetup)
      return;
    const e = { ...this._defaultConfig, ...t };
    this.config.version = e.version, this.config.author = e.author, this.config.types = e.types, this.config.statuses = e.statuses, this.config.priorities = e.priorities, this.config.labels = e.labels, this.config.stages = e.stages, this.config.users = e.users, this.config.includeSelectionTag = e.includeSelectionTag, this.config.updateExtensionsOnImport = e.updateExtensionsOnImport, this.config.strict = e.strict, this.config.includeAllExtensionsOnExport = e.includeAllExtensionsOnExport, this.config.fallbackVersionOnImport = e.fallbackVersionOnImport || "", this.config.ignoreIncompleteTopicsOnImport = e.ignoreIncompleteTopicsOnImport, this.isSetup = true, this.enabled = true, this.onSetup.trigger();
  }
  /**
   * Creates a new BCFTopic instance and adds it to the list.
   *
   * @param data - Optional partial BCFTopic object to initialize the new topic with.
   * If not provided, default values will be used.
   * @returns The newly created BCFTopic instance.
   */
  create(t) {
    const e = new mr(this.components);
    return t ? (e.guid = t.guid ?? e.guid, e.set(t)) : this.list.set(e.guid, e), e;
  }
  /**
   * Disposes of the BCFTopics component and triggers the onDisposed event.
   *
   * @remarks
   * This method clears the list of topics and triggers the onDisposed event.
   * It also resets the onDisposed event listener.
   */
  dispose() {
    this.list.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
  /**
   * Retrieves the unique set of topic types used across all topics.
   *
   * @returns A Set containing the unique topic types.
   */
  get usedTypes() {
    const t = [...this.list].map(([e, i]) => i.type);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic statuses used across all topics.
   *
   * @returns A Set containing the unique topic statuses.
   */
  get usedStatuses() {
    const t = [...this.list].map(([e, i]) => i.status);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic priorities used across all topics.
   *
   * @returns A Set containing the unique topic priorities.
   * Note: This method filters out any null or undefined priorities.
   */
  get usedPriorities() {
    const t = [...this.list].map(([e, i]) => i.priority).filter((e) => e);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of topic stages used across all topics.
   *
   * @returns A Set containing the unique topic stages.
   * Note: This method filters out any null or undefined stages.
   */
  get usedStages() {
    const t = [...this.list].map(([e, i]) => i.stage).filter((e) => e);
    return new Set(t);
  }
  /**
   * Retrieves the unique set of users associated with topics.
   *
   * @returns A Set containing the unique users.
   * Note: This method collects users from the creation author, assigned to, modified author, and comment authors.
   */
  get usedUsers() {
    const t = [];
    for (const [e, i] of this.list) {
      t.push(i.creationAuthor), i.assignedTo && t.push(i.assignedTo), i.modifiedAuthor && t.push(i.modifiedAuthor);
      for (const [s, r] of i.comments)
        t.push(r.author), r.modifiedAuthor && t.push(r.modifiedAuthor);
    }
    return new Set(t);
  }
  /**
   * Retrieves the unique set of labels used across all topics.
   *
   * @returns A Set containing the unique labels.
   */
  get usedLabels() {
    const t = [];
    for (const [e, i] of this.list)
      t.push(...i.labels);
    return new Set(t);
  }
  /**
   * Updates the set of extensions (types, statuses, priorities, labels, stages, users) based on the current topics.
   * This method iterates through each topic in the list and adds its properties to the corresponding sets in the config.
   */
  updateExtensions() {
    for (const [t, e] of this.list) {
      for (const i of e.labels)
        this.config.labels.add(i);
      this.config.types.add(e.type), e.priority && this.config.priorities.add(e.priority), e.stage && this.config.stages.add(e.stage), this.config.statuses.add(e.status), this.config.users.add(e.creationAuthor), e.assignedTo && this.config.users.add(e.assignedTo), e.modifiedAuthor && this.config.users.add(e.modifiedAuthor);
      for (const [i, s] of e.comments)
        this.config.users.add(s.author), s.modifiedAuthor && this.config.users.add(s.modifiedAuthor);
    }
  }
  /**
   * Updates the references to viewpoints in the topics.
   * This function iterates through each topic and checks if the viewpoints exist in the viewpoints list.
   * If a viewpoint does not exist, it is removed from the topic's viewpoints.
   */
  updateViewpointReferences() {
    const t = this.components.get(de);
    for (const [e, i] of this.list)
      for (const s of i.viewpoints)
        t.list.has(s) || i.viewpoints.delete(s);
  }
  /**
   * Exports the given topics to a BCF (Building Collaboration Format) zip file.
   *
   * @param topics - The topics to export. Defaults to all topics in the list.
   * @returns A promise that resolves to a Blob containing the exported BCF zip file.
   */
  async export(t = this.list.values()) {
    const e = new hr();
    e.file(
      "bcf.version",
      `<?xml version="1.0" encoding="UTF-8"?>
    <Version VersionId="${this.config.version}" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/buildingSMART/BCF-XML/release_3_0/Schemas/version.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    </Version>`
    ), e.file("bcf.extensions", this.serializeExtensions());
    const s = await (await fetch(
      "https://thatopen.github.io/engine_components/resources/favicon.ico"
    )).arrayBuffer(), r = this.components.get(de);
    for (const n of t) {
      const l = e.folder(n.guid);
      l.file("markup.bcf", n.serialize());
      for (const c of n.viewpoints) {
        const d = r.list.get(c);
        d && (l.file(`${c}.jpeg`, s, {
          binary: true
        }), l.file(`${c}.bcfv`, await d.serialize()));
      }
    }
    return await e.generateAsync({ type: "blob" });
  }
  serializeExtensions() {
    const t = [...this.config.types].map((n) => `<TopicType>${n}</TopicType>`).join(`
`), e = [...this.config.statuses].map((n) => `<TopicStatus>${n}</TopicStatus>`).join(`
`), i = [...this.config.priorities].map((n) => `<Priority>${n}</Priority>`).join(`
`), s = [...this.config.labels].map((n) => `<TopicLabel>${n}</TopicLabel>`).join(`
`), r = [...this.config.stages].map((n) => `<Stage>${n}</Stage>`).join(`
`), o = [...this.config.users].map((n) => `<User>${n}</User>`).join(`
`);
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Extensions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="your-schema-location.xsd">
        ${t.length !== 0 ? `<TopicTypes>
${t}
</TopicTypes>` : ""}
        ${e.length !== 0 ? `<TopicStatuses>
${e}
</TopicStatuses>` : ""}
        ${i.length !== 0 ? `<Priorities>
${i}
</Priorities>` : ""}
        ${s.length !== 0 ? `<TopicLabels>
${s}
</TopicLabels>` : ""}
        ${r.length !== 0 ? `<Stages>
${r}
</Stages>` : ""}
        ${o.length !== 0 ? `<Users>
${o}
</Users>` : ""}
      </Extensions>
    `;
  }
  processMarkupComment(t) {
    const {
      Guid: e,
      Date: i,
      Author: s,
      Comment: r,
      Viewpoint: o
    } = t;
    if (!(e && i && s && (bs || o)))
      return null;
    const n = this.components.get(de), l = new bs(this.components, r ?? "");
    return l.guid = e, l.date = new Date(i), l.author = s, l.viewpoint = o != null && o.Guid ? n.list.get(o.Guid) : void 0, l.modifiedAuthor = t.ModifiedAuthor, l.modifiedDate = t.ModifiedDate ? new Date(t.ModifiedDate) : void 0, l;
  }
  getMarkupComments(t, e) {
    var i;
    let s;
    if (e === "2.1" && (s = t.Comment), e === "3" && (s = (i = t.Topic.Comments) == null ? void 0 : i.Comment), !s)
      return [];
    s = Array.isArray(s) ? s : [s];
    const r = s.map((n) => this.processMarkupComment(n)).filter((n) => n);
    return Array.isArray(r) ? r : [r];
  }
  getMarkupLabels(t, e) {
    var i;
    let s;
    return e === "2.1" && (s = t.Topic.Labels), e === "3" && (s = (i = t.Topic.Labels) == null ? void 0 : i.Label), s ? Array.isArray(s) ? s : [s] : [];
  }
  getMarkupViewpoints(t, e) {
    var i;
    let s;
    return e === "2.1" && (s = t.Viewpoints), e === "3" && (s = (i = t.Topic.Viewpoints) == null ? void 0 : i.ViewPoint), s ? (s = Array.isArray(s) ? s : [s], s) : [];
  }
  getMarkupRelatedTopics(t, e) {
    var i;
    let s;
    return e === "2.1" && (s = t.Topic.RelatedTopic), e === "3" && (s = (i = t.Topic.RelatedTopics) == null ? void 0 : i.RelatedTopic), s ? (Array.isArray(s) ? s : [s]).map((o) => o.Guid) : [];
  }
  /**
   * Loads BCF (Building Collaboration Format) data into the engine.
   *
   * @param world - The default world where the viewpoints are going to be created.
   * @param data - The BCF data to load.
   *
   * @returns A promise that resolves to an object containing the created viewpoints and topics.
   *
   * @throws An error if the BCF version is not supported.
   */
  async load(t, e) {
    var i;
    const {
      fallbackVersionOnImport: s,
      ignoreIncompleteTopicsOnImport: r,
      updateExtensionsOnImport: o
    } = this.config, n = new hr();
    await n.loadAsync(t);
    const l = Object.values(n.files);
    let c = s;
    const d = l.find((v) => v.name.endsWith(".version"));
    if (d) {
      const v = await d.async("string"), x = ri.xmlParser.parse(v).Version.VersionId;
      c = String(x);
    }
    if (!(c && (c === "2.1" || c === "3")))
      throw new Error(`BCFTopics: ${c} is not supported.`);
    const f = l.find(
      (v) => v.name.endsWith(".extensions")
    );
    if (o && f) {
      const v = await f.async("string");
      al(this, v);
    }
    const p = [], u = this.components.get(de), g = l.filter((v) => v.name.endsWith(".bcfv"));
    for (const v of g) {
      const x = await v.async("string"), _ = ri.xmlParser.parse(x).VisualizationInfo;
      if (!_) {
        console.warn("Missing VisualizationInfo in Viewpoint");
        continue;
      }
      const T = {}, {
        Guid: E,
        // ClippingPlanes,
        Components: A,
        OrthogonalCamera: z,
        PerspectiveCamera: D
      } = _;
      if (E && (T.guid = E), A) {
        const { Selection: U, Visibility: C } = A;
        if (U && U.Component) {
          const w = Array.isArray(U.Component) ? U.Component : [U.Component];
          T.selectionComponents = w.map((M) => M.IfcGuid).filter((M) => M);
        }
        if (C && "DefaultVisibility" in C && (T.defaultVisibility = C.DefaultVisibility), C && C.Exceptions && "Component" in C.Exceptions) {
          const { Component: w } = C.Exceptions, M = Array.isArray(w) ? w : [w];
          T.exceptionComponents = M.map((J) => J.IfcGuid).filter((J) => J);
        }
        let k;
        c === "2.1" && (k = A.ViewSetupHints), c === "3" && (k = (i = A.Visibility) == null ? void 0 : i.ViewSetupHints), k && ("OpeningsVisible" in k && (T.openingsVisible = k.OpeningsVisible), "SpacesVisible" in k && (T.spacesVisible = k.SpacesVisible), "SpaceBoundariesVisible" in k && (T.spaceBoundariesVisible = k.SpaceBoundariesVisible));
      }
      if (z || D) {
        const U = _.PerspectiveCamera ?? _.OrthogonalCamera, { CameraViewPoint: C, CameraDirection: k } = U, w = new Vector3(
          Number(C.X),
          Number(C.Z),
          Number(-C.Y)
        ), M = new Vector3(
          Number(k.X),
          Number(k.Z),
          Number(-k.Y)
        ), J = {
          position: { x: w.x, y: w.y, z: w.z },
          direction: { x: M.x, y: M.y, z: M.z },
          aspectRatio: "AspectRatio" in U ? U.AspectRatio : 1
          // Temporal simplification
        };
        "ViewToWorldScale" in U && (T.camera = {
          ...J,
          viewToWorldScale: U.ViewToWorldScale
        }), "FieldOfView" in U && (T.camera = {
          ...J,
          fov: U.FieldOfView
        });
      }
      const I = new en(this.components, e, {
        data: T,
        setCamera: false
      });
      if (A) {
        const { Coloring: U } = A;
        if (U && U.Color) {
          const C = Array.isArray(U.Color) ? U.Color : [U.Color];
          for (const k of C) {
            const { Color: w, Component: M } = k, Z = (Array.isArray(M) ? M : [M]).map((nt) => nt.IfcGuid);
            I.componentColors.set(w, Z);
          }
        }
      }
      p.push(I);
    }
    const m = {}, b = [], h = l.filter((v) => v.name.endsWith(".bcf"));
    for (const v of h) {
      const x = await v.async("string"), _ = ri.xmlParser.parse(x).Markup, T = _.Topic, {
        Guid: E,
        TopicType: A,
        TopicStatus: z,
        Title: D,
        CreationDate: I,
        CreationAuthor: U
      } = T;
      if (r && !(E && A && z && D && I && U))
        continue;
      const C = new mr(this.components);
      C.guid = E ?? C.guid;
      const k = this.getMarkupRelatedTopics(_, c);
      m[C.guid] = new Set(k), C.type = A ?? C.type, C.status = z ?? C.status, C.title = D ?? C.title, C.creationDate = I ? new Date(I) : C.creationDate, C.creationAuthor = U ?? C.creationAuthor, C.serverAssignedId = T.ServerAssignedId, C.priority = T.Priority, C.index = T.Index, C.modifiedDate = T.ModifiedDate ? new Date(T.ModifiedDate) : void 0, C.modifiedAuthor = T.ModifiedAuthor, C.dueDate = T.DueDate ? new Date(T.DueDate) : void 0, C.assignedTo = T.AssignedTo, C.description = T.Description, C.stage = T.Stage;
      const w = this.getMarkupLabels(_, c);
      for (const Z of w)
        C.labels.add(Z);
      const M = this.getMarkupComments(_, c);
      for (const Z of M)
        C.comments.set(Z.guid, Z);
      const J = this.getMarkupViewpoints(_, c);
      for (const Z of J) {
        if (!(Z && Z.Guid))
          continue;
        const nt = u.list.get(Z.Guid);
        nt && C.viewpoints.add(nt.guid);
      }
      this.list.set(C.guid, C), b.push(C);
    }
    for (const v in m) {
      const x = this.list.get(v);
      if (!x)
        continue;
      const _ = m[v];
      for (const T of _)
        x.relatedTopics.add(T);
    }
    return this.onBCFImported.trigger(b), { viewpoints: p, topics: b };
  }
};
P(zs, "uuid", "de977976-e4f6-4e4f-a01a-204727839802");
P(zs, "xmlParser", new ol.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
var zt = zs;
var en = class {
  constructor(t, e, i) {
    P(this, "title"), P(this, "guid", Le.create()), P(this, "camera", {
      aspectRatio: 1,
      fov: 60,
      direction: { x: 0, y: 0, z: 0 },
      position: { x: 0, y: 0, z: 0 }
    }), P(this, "exceptionComponents", new Bi()), P(this, "selectionComponents", new Bi()), P(this, "componentColors", new Re()), P(this, "spacesVisible", false), P(this, "spaceBoundariesVisible", false), P(this, "openingsVisible", false), P(this, "defaultVisibility", true), P(this, "_components"), P(this, "world");
    const s = { setCamera: true, ...i }, { data: r, setCamera: o } = s;
    this._components = t, this.world = e, r && (this.guid = r.guid ?? this.guid, this.set(r)), o && this.updateCamera();
  }
  async getSelectionMap() {
    console.log(this.selectionComponents);
    const t = this._components.get(It), e = {};
    for (const i of this.selectionComponents)
      for (const [s, r] of t.list) {
        const o = r.getItem(i), n = await (o == null ? void 0 : o.getLocalId());
        if (n) {
          s in e || (e[s] = /* @__PURE__ */ new Set()), e[s].add(n);
          break;
        }
      }
    return e;
  }
  async getExceptionMap() {
    const t = this._components.get(It), e = {};
    for (const i of this.exceptionComponents)
      for (const [s, r] of t.list) {
        const o = r.getItem(i), n = await (o == null ? void 0 : o.getLocalId());
        if (n) {
          s in e || (e[s] = /* @__PURE__ */ new Set()), e[s].add(n);
          break;
        }
      }
    return e;
  }
  /**
   * Retrieves the projection type of the viewpoint's camera.
   *
   * @returns A string representing the projection type of the viewpoint's camera.
   *          It can be either 'Perspective' or 'Orthographic'.
   */
  get projection() {
    return "fov" in this.camera ? "Perspective" : "Orthographic";
  }
  /**
   * Retrieves the position vector of the viewpoint's camera.
   *
   * @remarks
   * The position vector represents the camera's position in the world coordinate system.
   * The function applies the base coordinate system transformation to the position vector.
   *
   * @returns A THREE.Vector3 representing the position of the viewpoint's camera.
   */
  get position() {
    const { position: t } = this.camera, { x: e, y: i, z: s } = t;
    return new Vector3(e, i, s);
  }
  /**
   * Retrieves the direction vector of the viewpoint's camera.
   *
   * @remarks
   * The direction vector represents the direction in which the camera is pointing.
   * It is calculated by extracting the x, y, and z components from the camera's direction property.
   *
   * @returns A THREE.Vector3 representing the direction of the viewpoint's camera.
   */
  get direction() {
    const { direction: t } = this.camera, { x: e, y: i, z: s } = t;
    return new Vector3(e, i, s);
  }
  get _managerVersion() {
    return this._components.get(zt).config.version;
  }
  /**
   * Retrieves the list of BCF topics associated with the current viewpoint.
   *
   * @remarks
   * This function retrieves the BCFTopics manager from the components,
   * then filters the list of topics to find those associated with the current viewpoint.
   *
   * @returns An array of BCF topics associated with the current viewpoint.
   */
  get topics() {
    return [...this._components.get(zt).list.values()].filter(
      (s) => s.viewpoints.has(this.guid)
    );
  }
  /**
   * Adds components to the viewpoint based on the provided selection as a modelIdMap.
   *
   * @param modelIdMap - A map containing modelIds as keys and arrays of localIds as values.
   */
  async addComponentsFromMap(t) {
    const e = this._components.get(It);
    for (const [s, r] of Object.entries(t)) {
      const o = e.list.get(s);
      if (o)
        for (const n of r) {
          const l = o.getItem(n);
          if (!l)
            continue;
          const c = await l.getGuid();
          c && this.selectionComponents.add(c);
        }
    }
    this._components.get(de).list.set(this.guid, this);
  }
  /**
   * Replace the properties of the viewpoint with the provided data.
   *
   * @remarks The guid will be ommited as it shouldn't change after it has been initially set.
   * @remarks The existing selection and exception components will be fully replaced in case new ones are provided.
   *
   * @param data - An object containing the properties to be set.
   *               The properties not included in the object will remain unchanged.
   *
   * @returns The viewpoint instance with the updated properties.
   */
  set(t) {
    const e = t, i = this;
    for (const r in t) {
      if (r === "guid")
        continue;
      const o = e[r];
      if (r === "selectionComponents") {
        this.selectionComponents.clear(), this.selectionComponents.add(...o);
        continue;
      }
      if (r === "exceptionComponents") {
        this.exceptionComponents.clear(), this.exceptionComponents.add(...o);
        continue;
      }
      r in this && (i[r] = o);
    }
    return this._components.get(de).list.set(this.guid, this), this;
  }
  /**
   * Sets the viewpoint of the camera in the world.
   *
   * @remarks
   * This function calculates the target position based on the viewpoint information.
   * It sets the visibility of the viewpoint components and then applies the viewpoint using the camera's controls.
   *
   * @param transition - Indicates whether the camera movement should have a transition effect.
   *                      Default value is `true`.
   *
   * @throws An error if the world's camera does not have camera controls.
   *
   * @returns A Promise that resolves when the camera has been set.
   */
  async go(t, e = true) {
    const { camera: i } = t ?? this.world;
    if (!i.hasCameraControls())
      throw new Error(
        "Viewpoint: the world's camera need controls to set the viewpoint."
      );
    i instanceof ea && i.projection.set(this.projection);
    const s = new Vector3(
      this.camera.position.x,
      this.camera.position.y,
      this.camera.position.z
    ), r = new Vector3(
      this.camera.direction.x,
      this.camera.direction.y,
      this.camera.direction.z
    );
    if (s.equals(new Vector3()) && r.equals(new Vector3()))
      return;
    const o = this.position, n = this.direction, l = {
      x: o.x + n.x * 80,
      y: o.y + n.y * 80,
      z: o.z + n.z * 80
    }, c = await this.getSelectionMap();
    Object.keys(c).length, await i.controls.setLookAt(
      o.x,
      o.y,
      o.z,
      l.x,
      l.y,
      l.z,
      e
    );
  }
  /**
   * Updates the camera settings of the viewpoint based on the current world's camera and renderer.
   *
   * @remarks
   * This function retrieves the camera's position, direction, and aspect ratio from the world's camera and renderer.
   * It then calculates the camera's perspective or orthographic settings based on the camera type.
   * Finally, it updates the viewpoint's camera settings and updates the viewpoint to the Viewpoints manager.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  updateCamera(t) {
    const { camera: e, renderer: i } = t ?? this.world;
    if (!i)
      throw new Error("Viewpoint: the world needs to have a renderer!");
    if (!e.hasCameraControls())
      throw new Error("Viewpoint: world's camera need camera controls!");
    const s = new Vector3();
    e.controls.getPosition(s);
    const r = e.three, o = new Vector3(0, 0, -1).applyEuler(
      r.rotation
    ), { width: n, height: l } = i.getSize();
    let c = n / l;
    Number.isNaN(c) && (c = 1);
    const d = this._components.get(It);
    s.applyMatrix4(d.baseCoordinationMatrix.clone().invert());
    const f = {
      aspectRatio: c,
      position: { x: s.x, y: s.y, z: s.z },
      direction: { x: o.x, y: o.y, z: o.z }
    };
    r instanceof PerspectiveCamera ? this.camera = {
      ...f,
      fov: r.fov
    } : r instanceof OrthographicCamera && (this.camera = {
      ...f,
      viewToWorldScale: r.top - r.bottom
    }), this._components.get(de).list.set(this.guid, this);
  }
  // applyVisibility() {
  //   const hider = this._components.get(Hider);
  //   hider.set(this.defaultVisibility);
  //   hider.set(!this.defaultVisibility, this.exception);
  //   hider.set(true, this.selection); // Always make sure the selection is visible
  // }
  /**
   * Applies color to the components in the viewpoint based on their GUIDs.
   *
   * This function iterates through the `componentColors` map, retrieves the fragment IDs
   * corresponding to each color, and then uses the `Classifier` to apply the color to those fragments.
   *
   * @remarks
   * The color is applied using the `Classifier.setColor` method, which sets the color of the specified fragments.
   * The color is provided as a hexadecimal string, prefixed with a '#'.
   */
  applyColors() {
  }
  /**
   * Resets the colors of all components in the viewpoint to their original color.
   */
  resetColors() {
  }
  async createComponentTags(t) {
    var e, i;
    const s = this._components.get(It), r = this._components.get(zt);
    let o = "";
    if (r.config.includeSelectionTag) {
      const n = t === "selection" ? await this.getSelectionMap() : await this.getExceptionMap();
      for (const l in n) {
        const c = s.list.get(l);
        if (!c)
          continue;
        const d = n[l];
        for (const f of d) {
          const p = await c.getProperties(f);
          if (!p)
            continue;
          const u = (e = p.GlobalId) == null ? void 0 : e.value;
          if (!u)
            continue;
          const g = (i = p.Tag) == null ? void 0 : i.value;
          let m = null;
          g && (m = `AuthoringToolId="${g}"`), o += `
<Component IfcGuid="${u}" ${m ?? ""} />`;
        }
      }
    } else
      o = [...this.selectionComponents].map((n) => `<Component IfcGuid="${n}" />`).join(`
`);
    return o;
  }
  createColorTags() {
    let t = "";
    for (const [e, i] of this.componentColors.entries()) {
      const s = `#${e.getHexString()}`, r = i.map((o) => `
<Component IfcGuid="${o}" />`).join(`
`);
      t += `<Color Color="${s}">
${r}
</Color>`;
    }
    return t.length !== 0 ? `<Coloring>
${t}
</Coloring>` : "<Coloring />";
  }
  /**
   * Serializes the viewpoint into a buildingSMART compliant XML string for export.
   *
   * @param version - The version of the BCF Manager to use for serialization.
   *                   If not provided, the current version of the manager will be used.
   *
   * @returns A Promise that resolves to an XML string representing the viewpoint.
   *          The XML string follows the BCF VisualizationInfo schema.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  async serialize(t = this._managerVersion) {
    const e = this._components.get(It), i = this.position;
    i.applyMatrix4(e.baseCoordinationMatrix.clone().invert());
    const s = this.direction;
    s.normalize();
    const r = new Matrix4().makeRotationX(Math.PI / 2), o = s.clone().applyMatrix4(r);
    o.normalize();
    const n = `<CameraViewPoint>
      <X>${i.x}</X>
      <Y>${-i.z}</Y>
      <Z>${i.y}</Z>
    </CameraViewPoint>`, l = `<CameraDirection>
      <X>${s.x}</X>
      <Y>${-s.z}</Y>
      <Z>${s.y}</Z>
    </CameraDirection>`, c = `<CameraUpVector>
      <X>${o.x}</X>
      <Y>${-o.z}</Y>
      <Z>${o.y}</Z>
    </CameraUpVector>`, d = `<AspectRatio>${this.camera.aspectRatio}</AspectRatio>`;
    let f = "";
    "viewToWorld" in this.camera ? f = `<OrthogonalCamera>
        ${n}
        ${l}
        ${c}
        ${d}
        <ViewToWorldScale>${this.camera.viewToWorld}</ViewToWorldScale>
      </OrthogonalCamera>` : "fov" in this.camera && (f = `<PerspectiveCamera>
        ${n}
        ${l}
        ${c}
        ${d}
        <FieldOfView>${this.camera.fov}</FieldOfView>
      </PerspectiveCamera>`);
    const p = `<ViewSetupHints SpacesVisible="${this.spacesVisible ?? false}" SpaceBoundariesVisible="${this.spaceBoundariesVisible ?? false}" OpeningsVisible="${this.openingsVisible ?? false}" />`, u = (await this.createComponentTags("selection")).trim(), g = (await this.createComponentTags("exception")).trim(), m = this.createColorTags();
    return `<?xml version="1.0" encoding="UTF-8"?>
    <VisualizationInfo Guid="${this.guid}">
      <Components>
        ${t === "2.1" ? p : ""}
        ${u.length !== 0 ? `<Selection>${u}</Selection>` : ""}
        <Visibility DefaultVisibility="${this.defaultVisibility}">
          ${t === "3" ? p : ""}
          ${g.length !== 0 ? `<Exceptions>${g}</Exceptions>` : ""}
        </Visibility>
        ${m}
      </Components>
      ${f}
    </VisualizationInfo>`;
  }
};
var cl = class extends Ss {
  constructor() {
    super(...arguments), P(this, "_config", {
      overwriteColors: {
        value: false,
        type: "Boolean"
      }
    });
  }
  get overwriteColors() {
    return this._config.overwriteColors.value;
  }
  set overwriteColors(t) {
    this._config.overwriteColors.value = t;
  }
};
var sn = class xs extends Zt {
  constructor(t) {
    super(t), P(this, "enabled", true), P(this, "list", new Re()), P(this, "isSetup", false), P(this, "onSetup", new it()), P(this, "config", new cl(
      this,
      this.components,
      "Viewpoints",
      xs.uuid
    )), P(this, "onDisposed", new it()), t.add(xs.uuid, this);
  }
  /**
   * Creates a new Viewpoint instance and adds it to the list.
   *
   * @param world - The world in which the Viewpoint will be created.
   * @param data - Optional partial data for the Viewpoint. If not provided, default data will be used.
   *
   * @returns The newly created Viewpoint instance.
   */
  create(t, e) {
    const i = new en(this.components, t, { data: e });
    return e || this.list.set(i.guid, i), i;
  }
  setup() {
  }
  /**
   * Disposes of the Viewpoints component and its associated resources.
   *
   * This method is responsible for cleaning up any resources held by the Viewpoints component,
   * such as disposing of the DataMap of Viewpoint instances and triggering and resetting the
   * onDisposed event.
   */
  dispose() {
    this.list.dispose(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
P(sn, "uuid", "ee867824-a796-408d-8aa0-4e5962a83c66");
var de = sn;
var Ri = class Ri2 extends Zt {
  constructor(e) {
    super(e);
    G(this, "enabled", true);
    G(this, "inputs", ["OBC", "BUI"]);
    G(this, "_requestEventID", "thatOpenCompanyComponentRequested");
    G(this, "_createEventID", "thatOpenCompanyComponentCreated");
    e.add(Ri2.uuid, this);
  }
  async import(e) {
    return new Promise((i) => {
      const s = document.createElement("script"), r = `
        function main() {
          const { ${this.inputs} } = window.ThatOpenCompany;
        
          ${e}
        
          const onComponentRequested = () => {
            window.removeEventListener("${this._requestEventID}", onComponentRequested);
            const event = new CustomEvent("${this._createEventID}", { detail: main });
            window.dispatchEvent(event);
          };
          
          window.addEventListener("${this._requestEventID}", onComponentRequested);
        }
        
        main();
      `, o = (n) => {
        window.removeEventListener(this._createEventID, o);
        const l = n.detail, c = this.components.get(l);
        s.remove(), i(c);
      };
      s.addEventListener("load", () => {
        window.addEventListener(this._createEventID, o), window.dispatchEvent(new Event(this._requestEventID));
      }), s.src = URL.createObjectURL(new File([r], "temp.js")), document.head.appendChild(s);
    });
  }
};
G(Ri, "uuid", "74c0c370-1af8-4ca9-900a-4a4196c0f2f5");
var gr = Ri;
var hl = class extends Object3D {
  constructor(t = document.createElement("div")) {
    super(), this.isCSS2DObject = true, this.element = t, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", false), this.center = new Vector2(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(e) {
        e.element instanceof e.element.ownerDocument.defaultView.Element && e.element.parentNode !== null && e.element.remove();
      });
    });
  }
  copy(t, e) {
    return super.copy(t, e), this.element = t.element.cloneNode(true), this.center = t.center, this;
  }
};
var Be = new Vector3();
var vr = new Matrix4();
var yr = new Matrix4();
var wr = new Vector3();
var br = new Vector3();
var ul = class {
  constructor(t = {}) {
    const e = this;
    let i, s, r, o;
    const n = {
      objects: /* @__PURE__ */ new WeakMap()
    }, l = t.element !== void 0 ? t.element : document.createElement("div");
    l.style.overflow = "hidden", this.domElement = l, this.getSize = function() {
      return {
        width: i,
        height: s
      };
    }, this.render = function(g, m) {
      g.matrixWorldAutoUpdate === true && g.updateMatrixWorld(), m.parent === null && m.matrixWorldAutoUpdate === true && m.updateMatrixWorld(), vr.copy(m.matrixWorldInverse), yr.multiplyMatrices(m.projectionMatrix, vr), d(g, g, m), u(g);
    }, this.setSize = function(g, m) {
      i = g, s = m, r = i / 2, o = s / 2, l.style.width = g + "px", l.style.height = m + "px";
    };
    function c(g) {
      g.isCSS2DObject && (g.element.style.display = "none");
      for (let m = 0, b = g.children.length; m < b; m++)
        c(g.children[m]);
    }
    function d(g, m, b) {
      if (g.visible === false) {
        c(g);
        return;
      }
      if (g.isCSS2DObject) {
        Be.setFromMatrixPosition(g.matrixWorld), Be.applyMatrix4(yr);
        const h = Be.z >= -1 && Be.z <= 1 && g.layers.test(b.layers) === true, v = g.element;
        v.style.display = h === true ? "" : "none", h === true && (g.onBeforeRender(e, m, b), v.style.transform = "translate(" + -100 * g.center.x + "%," + -100 * g.center.y + "%)translate(" + (Be.x * r + r) + "px," + (-Be.y * o + o) + "px)", v.parentNode !== l && l.appendChild(v), g.onAfterRender(e, m, b));
        const x = {
          distanceToCameraSquared: f(b, g)
        };
        n.objects.set(g, x);
      }
      for (let h = 0, v = g.children.length; h < v; h++)
        d(g.children[h], m, b);
    }
    function f(g, m) {
      return wr.setFromMatrixPosition(g.matrixWorld), br.setFromMatrixPosition(m.matrixWorld), wr.distanceToSquared(br);
    }
    function p(g) {
      const m = [];
      return g.traverseVisible(function(b) {
        b.isCSS2DObject && m.push(b);
      }), m;
    }
    function u(g) {
      const m = p(g).sort(function(h, v) {
        if (h.renderOrder !== v.renderOrder)
          return v.renderOrder - h.renderOrder;
        const x = n.objects.get(h).distanceToCameraSquared, _ = n.objects.get(v).distanceToCameraSquared;
        return x - _;
      }), b = m.length;
      for (let h = 0, v = m.length; h < v; h++)
        m[h].element.style.zIndex = b - h;
    }
  }
};
var xr = class {
  // Define marker as setup configuration?
  constructor(t, e, i) {
    G(this, "three");
    G(this, "world");
    G(this, "onDisposed", new it());
    this.world = t;
    let s;
    e ? s = e : (s = document.createElement("div"), s.style.width = "15px", s.style.height = "15px", s.style.border = "5px solid red"), this.three = new hl(s), (i || t.scene.three).add(this.three), this.visible = true;
  }
  /** {@link OBC.Hideable.visible} */
  set visible(t) {
    this.three.visible = t;
  }
  /** {@link OBC.Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /**
   * Toggles the visibility of the marker.
   *
   * This method changes the `visible` property of the marker to its opposite value.
   * If the marker is currently visible, it will be hidden, and vice versa.
   *
   * @returns {void}
   */
  toggleVisibility() {
    this.visible = !this.visible;
  }
  /** {@link OBC.Disposable.dispose} */
  dispose() {
    this.three.removeFromParent(), this.three.element.remove(), this.onDisposed.trigger(), this.onDisposed.reset();
  }
};
var fl = class extends Bn {
  constructor(e, i, s) {
    super(e, i, s);
    G(this, "three2D", new ul());
    this.onAfterUpdate.add(() => {
      if (this.onBeforeUpdate.trigger(this), !this.enabled || !this.currentWorld)
        return;
      const r = this.currentWorld.scene.three, o = this.currentWorld.camera.three;
      r instanceof Scene && this.three2D.render(r, o);
    }), this.onDisposed.add(() => {
      this.three2D.domElement.remove();
    }), this.onResize.add(({ x: r, y: o }) => {
      this.three2D.setSize(r, o);
    }), this.setupHtmlRenderer(), this.resize();
  }
  setupHtmlRenderer() {
    this.three2D.domElement.style.position = "absolute", this.three2D.domElement.style.top = "0px", this.three2D.domElement.style.pointerEvents = "none", this.container && this.container.appendChild(this.three2D.domElement);
  }
};
var Li = class Li2 extends Zt {
  constructor(e) {
    super(e);
    G(this, "onDisposed", new it());
    G(this, "enabled", true);
    G(this, "threshold", 50);
    G(this, "autoCluster", true);
    G(this, "list", /* @__PURE__ */ new Map());
    G(this, "clusterLabels", /* @__PURE__ */ new Set());
    G(this, "currentKeys", /* @__PURE__ */ new Set());
    G(this, "_color", "white");
    G(this, "_markerKey", 0);
    G(this, "_clusterKey", 0);
    G(this, "_worldEvents", /* @__PURE__ */ new Map());
    G(this, "_setupWorlds", /* @__PURE__ */ new Set());
    e.add(Li2.uuid, this);
  }
  /**
   * Getter for the color property.
   * Returns the current color of the markers.
   *
   * @returns {string} The current color of the markers.
   */
  get color() {
    return this._color;
  }
  /**
   * Setter for the color property.
   * Updates the color of all the markers to the new value.
   *
   * @param {string} value - The new color value for the markers.
   */
  set color(e) {
    this._color = e;
    for (const [i, s] of this.list)
      for (const [r, o] of s)
        o.label.three.element.style.color = e;
  }
  /**
   * Creates a new marker at the specified point in the world.
   *
   * @param world - The world where the marker will be created.
   * @param text - The text content of the marker.
   * @param point - The 3D position where the marker will be placed.
   * @param isStatic - Indicates whether the marker should be static and not clustered.
   * @returns The unique key of the created marker.
   */
  create(e, i, s, r = false) {
    this.setupEvents(e, true);
    const o = this._markerKey.toString(), n = this.getWorldMarkerList(e);
    if (n.has(o))
      return;
    const l = document.createElement("span");
    l.innerHTML = i, l.style.color = this._color;
    const c = new xr(e, l);
    return c.three.position.copy(s), n.set(o, {
      key: o,
      label: c,
      merged: false,
      static: r
    }), this._markerKey++, o;
  }
  /**
   * Deletes a marker with the specified ID from all worlds.
   *
   * @param id - The unique identifier of the marker to be deleted.
   *
   * @remarks
   * This method iterates through all the worlds and their respective markers.
   * If a marker with the specified ID is found, it disposes of the marker's label
   * and removes the marker from the world's marker list.
   *
   */
  delete(e) {
    for (const [i, s] of this.list) {
      const r = s.get(e);
      r && r.label.dispose(), s.delete(e);
    }
  }
  /**
   * Retrieves the list of markers associated with a specific world.
   * If the list does not exist for the given world, it creates a new one.
   *
   * @param world - The world for which the marker list is to be retrieved.
   * @returns A Map containing the markers associated with the given world.
   *
   * @remarks
   * This method is used to manage markers per world. It ensures that each world has its own set of markers.
   * If a marker list for the given world does not exist, it creates a new one and associates it with the world.
   */
  getWorldMarkerList(e) {
    return this.list.has(e.uuid) || this.list.set(e.uuid, /* @__PURE__ */ new Map()), this.list.get(e.uuid);
  }
  /** {@link OBC.Disposable.dispose} */
  dispose(e) {
    for (const [i, s] of this.list) {
      const r = [...s.keys()];
      for (const o of r) {
        const n = s.get(o);
        e && n.type !== e || (n.label.dispose(), s.delete(o));
      }
    }
    if (!e) {
      this.list.clear(), this._markerKey = 0;
      for (const i of this.clusterLabels)
        i.label.dispose();
      this.clusterLabels.clear(), this._clusterKey = 0, this.currentKeys.clear();
    }
    this.onDisposed.trigger();
  }
  /**
   * Sets up event listeners for clustering markers in the given world.
   *
   * @param world - The world where the event listeners will be set up.
   * @param enabled - Indicates whether the event listeners should be enabled or disabled.
   *
   * @remarks
   * This method checks if the event listeners are already set up for the given world.
   * If the event listeners are already set up and the `enabled` parameter is true, the method returns without doing anything.
   * If the world does not have camera controls, the method returns without doing anything.
   *
   * The method then retrieves the event listener for the given world using the `getWorldEvent` method.
   * It removes the existing event listeners for the "sleep" and "rest" events from the world's camera controls.
   *
   * If the `enabled` parameter is true, the method adds the event listener for the "sleep" and "rest" events to the world's camera controls.
   */
  setupEvents(e, i) {
    if (i && this._setupWorlds.has(e.uuid) || !e.camera.hasCameraControls())
      return;
    const s = this.getWorldEvent(e);
    e.camera.controls.removeEventListener("sleep", s), e.camera.controls.removeEventListener("rest", s), i && (e.camera.controls.addEventListener("sleep", s), e.camera.controls.addEventListener("rest", s));
  }
  /**
   * Performs clustering of markers in the given world.
   *
   * @param world - The world where clustering will be performed.
   *
   */
  cluster(e) {
    if (!this.autoCluster)
      return;
    this.resetMarkers();
    const i = this.list.get(e.uuid);
    if (i) {
      for (const [s, r] of i)
        if (!r.merged && !r.static) {
          this.currentKeys.clear();
          for (const [o, n] of i)
            n.static || r.key !== n.key && !n.merged && this.distance(r.label, n.label) < this.threshold && (this.currentKeys.add(n.key), n.merged = true);
          if (this.currentKeys.size > 0) {
            this.currentKeys.add(r.key), r.merged = true;
            const o = Array.from(this.currentKeys), n = this.getAveragePositionFromLabels(o), l = new xr(
              r.label.world,
              this.createClusterElement(this._clusterKey.toString())
            ), { element: c } = l.three;
            c.textContent = o.length.toString(), l.three.position.copy(n), this.clusterLabels.add({
              key: this._clusterKey.toString(),
              markerKeys: o,
              label: l
            }), this._clusterKey++;
          }
        }
      this.removeMergeMarkers(e);
    }
  }
  getWorldEvent(e) {
    if (!this._worldEvents.has(e.uuid)) {
      const i = () => {
        this.cluster(e);
      };
      this._worldEvents.set(e.uuid, i);
    }
    return this._worldEvents.get(e.uuid);
  }
  resetMarkers() {
    for (const [e, i] of this.list)
      for (const [s, r] of i)
        r.merged = false;
    for (const e of this.clusterLabels)
      e.label.dispose();
    this.clusterLabels.clear(), this._clusterKey = 0;
  }
  removeMergeMarkers(e) {
    const i = this.list.get(e.uuid);
    if (i) {
      for (const [s, r] of i)
        r.merged ? r.label.dispose() : r.label.world.scene.three.add(r.label.three);
      for (const s of this.clusterLabels)
        if (s.markerKeys.length === 1) {
          for (const [r, o] of this.list) {
            const n = o.get(s.markerKeys[0]);
            if (!n)
              continue;
            n.label.world.scene.three.add(n.label.three), n.merged = false;
          }
          s.label.dispose(), this.clusterLabels.delete(s);
        }
    }
  }
  getAveragePositionFromLabels(e) {
    const i = e.map((s) => {
      for (const [r, o] of this.list) {
        const n = o.get(s);
        if (n)
          return n.label.three.position;
      }
      return new Vector3();
    });
    return i.reduce((s, r) => s.add(r), new Vector3()).divideScalar(i.length);
  }
  createClusterElement(e) {
    const i = document.createElement("div");
    return i.textContent = e, i.style.color = "#000000", i.style.background = "#FFFFFF", i.style.fontSize = "1.2rem", i.style.fontWeight = "500", i.style.pointerEvents = "auto", i.style.borderRadius = "50%", i.style.padding = "5px 11px", i.style.textAlign = "center", i.style.cursor = "pointer", i.addEventListener("pointerdown", () => {
      this.navigateToCluster(e);
    }), i.addEventListener("pointerover", () => {
      i.style.background = "#BCF124";
    }), i.addEventListener("pointerout", () => {
      i.style.background = "#FFFFFF";
    }), i;
  }
  getScreenPosition(e) {
    const i = new Vector3();
    if (!e.world.renderer)
      throw new Error("Renderer not found!");
    const s = e.three.position.clone();
    s.project(e.world.camera.three);
    const r = e.world.renderer.getSize();
    return i.x = s.x * r.x / 2 + r.x / 2, i.y = -(s.y * r.y / 2) + r.y / 2, i;
  }
  distance(e, i) {
    const s = this.getScreenPosition(e), r = this.getScreenPosition(i), o = s.x - r.x, n = s.y - r.y, l = Math.sqrt(o * o + n * n) * 0.5;
    return l === 0 ? this.threshold + 1 : l;
  }
  navigateToCluster(e) {
    const i = [], s = Array.from(this.clusterLabels).find(
      (f) => f.key === e
    );
    if (!s)
      return;
    const r = s.label.world.camera;
    if (!r.hasCameraControls()) {
      console.warn("Zoom to clusters only supported with Camera Controls!");
      return;
    }
    for (const f of s.markerKeys)
      for (const [p, u] of this.list) {
        const g = u.get(f);
        if (g) {
          const { x: m, y: b, z: h } = g.label.three.position;
          i.push(m, b, h);
        }
      }
    s.label.dispose(), this.clusterLabels.delete(s);
    const o = new BufferGeometry(), n = new Float32Array(i), l = new BufferAttribute(n, 3);
    o.setAttribute("position", l);
    const c = new Mesh(o);
    c.geometry.computeBoundingSphere(), c.geometry.boundingSphere && r.controls.fitToSphere(c, true), o.dispose(), c.clear(), i.length = 0;
  }
};
G(Li, "uuid", "4079eb91-79b0-4ede-bcf2-15b837129236");
var _r = Li;
var dl = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
var Ue = class {
  constructor() {
    this.isPass = true, this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
};
var pl = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var ml = class extends BufferGeometry {
  constructor() {
    super(), this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  }
};
var gl = new ml();
var rn = class {
  constructor(t) {
    this._mesh = new Mesh(gl, t);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(t) {
    t.render(this._mesh, pl);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
};
var nn = class extends Ue {
  constructor(t, e) {
    super(), this.textureID = e !== void 0 ? e : "tDiffuse", t instanceof ShaderMaterial ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = UniformsUtils.clone(t.uniforms), this.material = new ShaderMaterial({
      name: t.name !== void 0 ? t.name : "unspecified",
      defines: Object.assign({}, t.defines),
      uniforms: this.uniforms,
      vertexShader: t.vertexShader,
      fragmentShader: t.fragmentShader
    })), this.fsQuad = new rn(this.material);
  }
  render(t, e, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
};
var Tr = class extends Ue {
  constructor(t, e) {
    super(), this.scene = t, this.camera = e, this.clear = true, this.needsSwap = false, this.inverse = false;
  }
  render(t, e, i) {
    const s = t.getContext(), r = t.state;
    r.buffers.color.setMask(false), r.buffers.depth.setMask(false), r.buffers.color.setLocked(true), r.buffers.depth.setLocked(true);
    let o, n;
    this.inverse ? (o = 0, n = 1) : (o = 1, n = 0), r.buffers.stencil.setTest(true), r.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), r.buffers.stencil.setFunc(s.ALWAYS, o, 4294967295), r.buffers.stencil.setClear(n), r.buffers.stencil.setLocked(true), t.setRenderTarget(i), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), r.buffers.color.setLocked(false), r.buffers.depth.setLocked(false), r.buffers.color.setMask(true), r.buffers.depth.setMask(true), r.buffers.stencil.setLocked(false), r.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), r.buffers.stencil.setLocked(true);
  }
};
var vl = class extends Ue {
  constructor() {
    super(), this.needsSwap = false;
  }
  render(t) {
    t.state.buffers.stencil.setLocked(false), t.state.buffers.stencil.setTest(false);
  }
};
var yl = class {
  constructor(t, e) {
    if (this.renderer = t, this._pixelRatio = t.getPixelRatio(), e === void 0) {
      const i = t.getSize(new Vector2());
      this._width = i.width, this._height = i.height, e = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType }), e.texture.name = "EffectComposer.rt1";
    } else
      this._width = e.width, this._height = e.height;
    this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.copyPass = new nn(dl), this.copyPass.material.blending = NoBlending, this.clock = new Clock();
  }
  swapBuffers() {
    const t = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = t;
  }
  addPass(t) {
    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(t, e) {
    this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(t) {
    const e = this.passes.indexOf(t);
    e !== -1 && this.passes.splice(e, 1);
  }
  isLastEnabledPass(t) {
    for (let e = t + 1; e < this.passes.length; e++)
      if (this.passes[e].enabled)
        return false;
    return true;
  }
  render(t) {
    t === void 0 && (t = this.clock.getDelta());
    const e = this.renderer.getRenderTarget();
    let i = false;
    for (let s = 0, r = this.passes.length; s < r; s++) {
      const o = this.passes[s];
      if (o.enabled !== false) {
        if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(s), o.render(this.renderer, this.writeBuffer, this.readBuffer, t, i), o.needsSwap) {
          if (i) {
            const n = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(n.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), l.setFunc(n.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        Tr !== void 0 && (o instanceof Tr ? i = true : o instanceof vl && (i = false));
      }
    }
    this.renderer.setRenderTarget(e);
  }
  reset(t) {
    if (t === void 0) {
      const e = this.renderer.getSize(new Vector2());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, t = this.renderTarget1.clone(), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(t, e) {
    this._width = t, this._height = e;
    const i = this._width * this._pixelRatio, s = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, s), this.renderTarget2.setSize(i, s);
    for (let r = 0; r < this.passes.length; r++)
      this.passes[r].setSize(i, s);
  }
  setPixelRatio(t) {
    this._pixelRatio = t, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
};
var wl = class extends Ue {
  constructor(t, e, i = null, s = null, r = null) {
    super(), this.scene = t, this.camera = e, this.overrideMaterial = i, this.clearColor = s, this.clearAlpha = r, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new Color();
  }
  render(t, e, i) {
    const s = t.autoClear;
    t.autoClear = false;
    let r, o;
    this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (t.getClearColor(this._oldClearColor), t.setClearColor(this.clearColor, t.getClearAlpha())), this.clearAlpha !== null && (r = t.getClearAlpha(), t.setClearAlpha(this.clearAlpha)), this.clearDepth == true && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : i), this.clear === true && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor !== null && t.setClearColor(this._oldClearColor), this.clearAlpha !== null && t.setClearAlpha(r), this.overrideMaterial !== null && (this.scene.overrideMaterial = o), t.autoClear = s;
  }
};
var li = new BufferGeometry();
li.setAttribute("position", new BufferAttribute(new Float32Array([
  -1,
  -1,
  3,
  -1,
  -1,
  3
]), 2));
li.setAttribute("uv", new BufferAttribute(new Float32Array([
  0,
  0,
  2,
  0,
  0,
  2
]), 2));
li.boundingSphere = new Sphere();
li.computeBoundingSphere = function() {
};
var bl = new OrthographicCamera();
var Ie = class {
  constructor(t) {
    this._mesh = new Mesh(li, t), this._mesh.frustumCulled = false;
  }
  render(t) {
    t.render(this._mesh, bl);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
  dispose() {
    this._mesh.material.dispose(), this._mesh.geometry.dispose();
  }
};
var xl = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    sceneNormal: {
      value: null
    },
    projMat: {
      value: new Matrix4()
    },
    viewMat: {
      value: new Matrix4()
    },
    projViewMat: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    cameraPos: {
      value: new Vector3()
    },
    resolution: {
      value: new Vector2()
    },
    biasAdjustment: {
      value: new Vector2()
    },
    time: {
      value: 0
    },
    samples: {
      value: []
    },
    bluenoise: {
      value: null
    },
    distanceFalloff: {
      value: 1
    },
    radius: {
      value: 5
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    logDepth: {
      value: false
    },
    ortho: {
      value: false
    },
    screenSpaceRadius: {
      value: false
    },
    frame: {
      value: 0
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = vec4(position, 1);
}`
  ),
  fragmentShader: (
    /* glsl */
    `
    #define SAMPLES 16
    #define FSAMPLES 16.0
uniform sampler2D sceneDiffuse;
uniform highp sampler2D sceneNormal;
uniform highp sampler2D sceneDepth;
uniform mat4 projectionMatrixInv;
uniform mat4 viewMatrixInv;
uniform mat4 projMat;
uniform mat4 viewMat;
uniform mat4 projViewMat;
uniform vec3 cameraPos;
uniform vec2 resolution;
uniform vec2 biasAdjustment;
uniform float time;
uniform vec3[SAMPLES] samples;
uniform float radius;
uniform float distanceFalloff;
uniform float near;
uniform float far;
uniform float frame;
uniform bool logDepth;
uniform bool ortho;
uniform bool screenSpaceRadius;
uniform sampler2D bluenoise;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      /*return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);*/
       #ifdef ORTHO

       return linearize_depth_ortho(d, nearZ, farZ);

        #else
        return linearize_depth(linDepth, nearZ, farZ);
        #endif
    }

    vec3 getWorldPosLog(vec3 posS) {
      vec2 uv = posS.xy;
      float z = posS.z;
      float nearZ =near;
      float farZ = far;
      float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
      vec4 wpos = projectionMatrixInv * clipVec;
      return wpos.xyz / wpos.w;
    }
    vec3 getWorldPos(float depth, vec2 coord) {
      #ifdef LOGDEPTH
        #ifndef ORTHO
          return getWorldPosLog(vec3(coord, depth));
        #endif
      #endif
      float z = depth * 2.0 - 1.0;
      vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
      vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
      // Perspective division
     vec4 worldSpacePosition = viewSpacePosition;
     worldSpacePosition.xyz /= worldSpacePosition.w;
      return worldSpacePosition.xyz;
  }

  vec3 computeNormal(vec3 worldPos, vec2 vUv) {
    ivec2 p = ivec2(vUv * resolution);
    float c0 = texelFetch(sceneDepth, p, 0).x;
    float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
    float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
    float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
    float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
    float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
    float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
    float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
    float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;

    float dl = abs((2.0 * l1 - l2) - c0);
    float dr = abs((2.0 * r1 - r2) - c0);
    float db = abs((2.0 * b1 - b2) - c0);
    float dt = abs((2.0 * t1 - t2) - c0);

    vec3 ce = getWorldPos(c0, vUv).xyz;

    vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                          : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
    vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                          : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;

    return normalize(cross(dpdx, dpdy));
}

mat3 makeRotationZ(float theta) {
	float c = cos(theta);
	float s = sin(theta);
	return mat3(c, - s, 0,
			s,  c, 0,
			0,  0, 1);
  }

void main() {
      vec4 diffuse = texture2D(sceneDiffuse, vUv);
      float depth = texture2D(sceneDepth, vUv).x;
      if (depth == 1.0) {
        gl_FragColor = vec4(vec3(1.0), 1.0);
        return;
      }
      vec3 worldPos = getWorldPos(depth, vUv);
      #ifdef HALFRES
        vec3 normal = texture2D(sceneNormal, vUv).rgb;
      #else
        vec3 normal = computeNormal(worldPos, vUv);
      #endif
      vec4 noise = texture2D(bluenoise, gl_FragCoord.xy / 128.0);
      vec2 harmoniousNumbers = vec2(
        1.618033988749895,
        1.324717957244746
      );
      noise.rg += harmoniousNumbers * frame;
      noise.rg = fract(noise.rg);
        vec3 helperVec = vec3(0.0, 1.0, 0.0);
        if (dot(helperVec, normal) > 0.99) {
          helperVec = vec3(1.0, 0.0, 0.0);
        }
        vec3 tangent = normalize(cross(helperVec, normal));
        vec3 bitangent = cross(normal, tangent);
        mediump mat3 tbn = mat3(tangent, bitangent, normal) *  makeRotationZ( noise.r * 3.1415962 * 2.0) ;

      mediump float occluded = 0.0;
      mediump float totalWeight = 0.0;
      float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : radiusToUse * distanceFalloff * 0.2;
      float bias = (min(
        0.1,
        distanceFalloffToUse * 0.1
      ) / near) * fwidth(distance(worldPos, cameraPos)) / radiusToUse;
      bias = biasAdjustment.x + biasAdjustment.y * bias;
      mediump float offsetMove = noise.g;
      mediump float offsetMoveInv = 1.0 / FSAMPLES;
      float farTimesNear = far * near;
      float farMinusNear = far - near;
      
      for(int i = 0; i < SAMPLES; i++) {
        mediump vec3 sampleDirection = tbn * samples[i];

        float moveAmt = fract(offsetMove);
        offsetMove += offsetMoveInv;
        vec3 samplePos = worldPos + radiusToUse * moveAmt * sampleDirection;
        vec4 offset = projMat * vec4(samplePos, 1.0);
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5;
        
        if (all(greaterThan(offset.xyz * (1.0 - offset.xyz), vec3(0.0)))) {
          float sampleDepth = textureLod(sceneDepth, offset.xy, 0.0).x;

          /*#ifdef LOGDEPTH
          float distSample = linearize_depth_log(sampleDepth, near, far);
      #else
          #ifdef ORTHO
              float distSample = near + farMinusNear * sampleDepth;
          #else
              float distSample = (farTimesNear) / (far - sampleDepth * farMinusNear);
          #endif
      #endif*/
      #ifdef ORTHO
          float distSample = near + sampleDepth * farMinusNear;
      #else
          #ifdef LOGDEPTH
              float distSample = linearize_depth_log(sampleDepth, near, far);
          #else
              float distSample = (farTimesNear) / (far - sampleDepth * farMinusNear);
          #endif
      #endif
      
      #ifdef ORTHO
          float distWorld = near + offset.z * farMinusNear;
      #else
          float distWorld = (farTimesNear) / (far - offset.z * farMinusNear);
      #endif
          
          mediump float rangeCheck = smoothstep(0.0, 1.0, distanceFalloffToUse / (abs(distSample - distWorld)));
          vec2 diff = gl_FragCoord.xy - floor(offset.xy * resolution);
          occluded += rangeCheck * float(distSample != distWorld) * float(sampleDepth != depth) * step(distSample + bias, distWorld) * step(
            1.0,
            dot(diff, diff)
          );
          
          totalWeight ++;
        }
      }
      float occ = clamp(1.0 - occluded / (totalWeight == 0.0 ? 1.0 : totalWeight), 0.0, 1.0);
      gl_FragColor = vec4(occ, 0.5 + 0.5 * normal);
}`
  )
};
var _l = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    transparencyDWFalse: {
      value: null
    },
    transparencyDWTrue: {
      value: null
    },
    transparencyDWTrueDepth: {
      value: null
    },
    transparencyAware: {
      value: false
    },
    projMat: {
      value: new Matrix4()
    },
    viewMat: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    cameraPos: {
      value: new Vector3()
    },
    resolution: {
      value: new Vector2()
    },
    color: {
      value: new Vector3(0, 0, 0)
    },
    blueNoise: {
      value: null
    },
    downsampledDepth: {
      value: null
    },
    time: {
      value: 0
    },
    intensity: {
      value: 10
    },
    renderMode: {
      value: 0
    },
    gammaCorrection: {
      value: false
    },
    logDepth: {
      value: false
    },
    ortho: {
      value: false
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    screenSpaceRadius: {
      value: false
    },
    radius: {
      value: 0
    },
    distanceFalloff: {
      value: 1
    },
    fog: {
      value: false
    },
    fogExp: {
      value: false
    },
    fogDensity: {
      value: 0
    },
    fogNear: {
      value: 1 / 0
    },
    fogFar: {
      value: 1 / 0
    },
    colorMultiply: {
      value: true
    },
    aoTones: {
      value: 0
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform highp sampler2D downsampledDepth;
    uniform highp sampler2D transparencyDWFalse;
    uniform highp sampler2D transparencyDWTrue;
    uniform highp sampler2D transparencyDWTrueDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform vec2 resolution;
    uniform vec3 color;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform float intensity;
    uniform float renderMode;
    uniform float near;
    uniform float far;
    uniform float aoTones;
    uniform bool gammaCorrection;
    uniform bool logDepth;
    uniform bool ortho;
    uniform bool screenSpaceRadius;
    uniform bool fog;
    uniform bool fogExp;
    uniform bool colorMultiply;
    uniform bool transparencyAware;
    uniform float fogDensity;
    uniform float fogNear;
    uniform float fogFar;
    uniform float radius;
    uniform float distanceFalloff;
    uniform vec3 cameraPos;
    varying vec2 vUv;
    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        return (zFar * zNear) / (zFar - d * (zFar - zNear));
    }
    highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
      return nearZ + (farZ - nearZ) * d;
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
      float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
      float a = farZ / (farZ - nearZ);
      float b = farZ * nearZ / (nearZ - farZ);
      float linDepth = a + b / depth;
      return ortho ? linearize_depth_ortho(
        linDepth,
        nearZ,
        farZ
      ) :linearize_depth(linDepth, nearZ, farZ);
    }
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
       // if (logDepth) {
        #ifdef LOGDEPTH
          #ifndef ORTHO
            return getWorldPosLog(vec3(coord, depth));
          #endif
        #endif
      //  }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }

    #include <common>
    #include <dithering_pars_fragment>
    void main() {
        //vec4 texel = texture2D(tDiffuse, vUv);//vec3(0.0);
        vec4 sceneTexel = texture2D(sceneDiffuse, vUv);
        float depth = texture2D(
            sceneDepth,
            vUv
        ).x;
        #ifdef HALFRES 
        vec4 texel;
        if (depth == 1.0) {
            texel = vec4(0.0, 0.0, 0.0, 1.0);
        } else {
        vec3 worldPos = getWorldPos(depth, vUv);
        vec3 normal = computeNormal(getWorldPos(depth, vUv), vUv);
       // vec4 texel = texture2D(tDiffuse, vUv);
       // Find closest depth;
       float totalWeight = 0.0;
       float radiusToUse = screenSpaceRadius ? distance(
        worldPos,
        getWorldPos(depth, vUv +
          vec2(radius, 0.0) / resolution)
      ) : radius;
      float distanceFalloffToUse =screenSpaceRadius ?
          radiusToUse * distanceFalloff
      : distanceFalloff;
        for(float x = -1.0; x <= 1.0; x++) {
            for(float y = -1.0; y <= 1.0; y++) {
                vec2 offset = vec2(x, y);
                ivec2 p = ivec2(
                    (vUv * resolution * 0.5) + offset
                );
                vec2 pUv = vec2(p) / (resolution * 0.5);
                float sampleDepth = texelFetch(downsampledDepth,p, 0).x;
                vec4 sampleInfo = texelFetch(tDiffuse, p, 0);
                vec3 normalSample = sampleInfo.gba * 2.0 - 1.0;
                vec3 worldPosSample = getWorldPos(sampleDepth, pUv);
                float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
                float rangeCheck = exp(-1.0 * tangentPlaneDist * (1.0 / distanceFalloffToUse)) * max(dot(normal, normalSample), 0.0);
                float weight = rangeCheck;
                totalWeight += weight;
                texel += sampleInfo * weight;
            }
        }
        if (totalWeight == 0.0) {
            texel = texture2D(tDiffuse, vUv);
        } else {
            texel /= totalWeight;
        }
    }
        #else
        vec4 texel = texture2D(tDiffuse, vUv);
        #endif

        #ifdef LOGDEPTH
        texel.r = clamp(texel.r, 0.0, 1.0);
        if (texel.r == 0.0) {
          texel.r = 1.0;
        }
        #endif
     
        float finalAo = pow(texel.r, intensity);
        if (aoTones > 0.0) {
            finalAo = ceil(finalAo * aoTones) / aoTones;
        }
        float fogFactor;
        float fogDepth = distance(
            cameraPos,
            getWorldPos(depth, vUv)
        );
        if (fog) {
            if (fogExp) {
                fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
            } else {
                fogFactor = smoothstep( fogNear, fogFar, fogDepth );
            }
        }
        if (transparencyAware) {
            float transparencyDWOff = texture2D(transparencyDWFalse, vUv).a;
            float transparencyDWOn = texture2D(transparencyDWTrue, vUv).a;
            float adjustmentFactorOff = transparencyDWOff;
            float adjustmentFactorOn = (1.0 - transparencyDWOn) * (
                texture2D(transparencyDWTrueDepth, vUv).r == texture2D(sceneDepth, vUv).r ? 1.0 : 0.0
            );
            float adjustmentFactor = max(adjustmentFactorOff, adjustmentFactorOn);
            finalAo = mix(finalAo, 1.0, adjustmentFactor);
        }
        finalAo = mix(finalAo, 1.0, fogFactor);
        vec3 aoApplied = color * mix(vec3(1.0), sceneTexel.rgb, float(colorMultiply));
        if (renderMode == 0.0) {
            gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 1.0) {
            gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
        } else if (renderMode == 2.0) {
            gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
        } else if (renderMode == 3.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(sceneTexel.rgb, aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        } else if (renderMode == 4.0) {
            if (vUv.x < 0.5) {
                gl_FragColor = vec4( sceneTexel.rgb, sceneTexel.a);
            } else if (abs(vUv.x - 0.5) < 1.0 / resolution.x) {
                gl_FragColor = vec4(1.0);
            } else {
                gl_FragColor = vec4( mix(vec3(1.0), aoApplied, 1.0 - finalAo), sceneTexel.a);
            }
        }
        #include <dithering_fragment>
        if (gammaCorrection) {
            gl_FragColor = sRGBTransferOETF(gl_FragColor);
        }
    }
    `
  )
};
var Tl = {
  uniforms: {
    sceneDiffuse: {
      value: null
    },
    sceneDepth: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    projMat: {
      value: new Matrix4()
    },
    viewMat: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    cameraPos: {
      value: new Vector3()
    },
    resolution: {
      value: new Vector2()
    },
    time: {
      value: 0
    },
    r: {
      value: 5
    },
    blueNoise: {
      value: null
    },
    radius: {
      value: 12
    },
    worldRadius: {
      value: 5
    },
    index: {
      value: 0
    },
    poissonDisk: {
      value: []
    },
    distanceFalloff: {
      value: 1
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    logDepth: {
      value: false
    },
    screenSpaceRadius: {
      value: false
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = vec4(position, 1.0);
		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform sampler2D sceneDiffuse;
    uniform highp sampler2D sceneDepth;
    uniform sampler2D tDiffuse;
    uniform sampler2D blueNoise;
    uniform mat4 projectionMatrixInv;
    uniform mat4 viewMatrixInv;
    uniform vec2 resolution;
    uniform float r;
    uniform float radius;
     uniform float worldRadius;
    uniform float index;
     uniform float near;
     uniform float far;
     uniform float distanceFalloff;
     uniform bool logDepth;
     uniform bool screenSpaceRadius;
    varying vec2 vUv;

    highp float linearize_depth(highp float d, highp float zNear,highp float zFar)
    {
        highp float z_n = 2.0 * d - 1.0;
        return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
    }
    highp float linearize_depth_log(highp float d, highp float nearZ,highp float farZ) {
     float depth = pow(2.0, d * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     return linearize_depth(linDepth, nearZ, farZ);
   }
   highp float linearize_depth_ortho(highp float d, highp float nearZ, highp float farZ) {
     return nearZ + (farZ - nearZ) * d;
   }
   vec3 getWorldPosLog(vec3 posS) {
     vec2 uv = posS.xy;
     float z = posS.z;
     float nearZ =near;
     float farZ = far;
     float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
     float a = farZ / (farZ - nearZ);
     float b = farZ * nearZ / (nearZ - farZ);
     float linDepth = a + b / depth;
     vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
     vec4 wpos = projectionMatrixInv * clipVec;
     return wpos.xyz / wpos.w;
   }
    vec3 getWorldPos(float depth, vec2 coord) {
     #ifdef LOGDEPTH
      #ifndef ORTHO
          return getWorldPosLog(vec3(coord, depth));
      #endif
     #endif
        
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
    #include <common>
    #define NUM_SAMPLES 16
    uniform vec2 poissonDisk[NUM_SAMPLES];
    void main() {
        const float pi = 3.14159;
        vec2 texelSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);
        vec2 uv = vUv;
        vec4 data = texture2D(tDiffuse, vUv);
        float occlusion = data.r;
        float baseOcc = data.r;
        vec3 normal = data.gba * 2.0 - 1.0;
        float count = 1.0;
        float d = texture2D(sceneDepth, vUv).x;
        if (d == 1.0) {
          gl_FragColor = data;
          return;
        }
        vec3 worldPos = getWorldPos(d, vUv);
        float size = radius;
        float angle;
        if (index == 0.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).w * PI2;
        } else if (index == 1.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).z * PI2;
        } else if (index == 2.0) {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).y * PI2;
        } else {
             angle = texture2D(blueNoise, gl_FragCoord.xy / 128.0).x * PI2;
        }

        mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
        float radiusToUse = screenSpaceRadius ? distance(
          worldPos,
          getWorldPos(d, vUv +
            vec2(worldRadius, 0.0) / resolution)
        ) : worldRadius;
        float distanceFalloffToUse =screenSpaceRadius ?
        radiusToUse * distanceFalloff
    : radiusToUse * distanceFalloff * 0.2;

        float invDistance = (1.0 / distanceFalloffToUse);
        for(int i = 0; i < NUM_SAMPLES; i++) {
            vec2 offset = (rotationMatrix * poissonDisk[i]) * texelSize * size;
            vec4 dataSample = texture2D(tDiffuse, uv + offset);
            float occSample = dataSample.r;
            vec3 normalSample = dataSample.gba * 2.0 - 1.0;
            float dSample = texture2D(sceneDepth, uv + offset).x;
            vec3 worldPosSample = getWorldPos(dSample, uv + offset);
            float tangentPlaneDist = abs(dot(worldPosSample - worldPos, normal));
            float rangeCheck = float(dSample != 1.0) * exp(-1.0 * tangentPlaneDist * invDistance ) * max(dot(normal, normalSample), 0.0);
            occlusion += occSample * rangeCheck;
            count += rangeCheck;
        }
        if (count > 0.0) {
          occlusion /= count;
        }
        #ifdef LOGDEPTH
          occlusion = clamp(occlusion, 0.0, 1.0);
          if (occlusion == 0.0) {
            occlusion = 1.0;
          }
        #endif
        gl_FragColor = vec4(occlusion, 0.5 + 0.5 * normal);
    }
    `
  )
};
var Cl = {
  uniforms: {
    sceneDepth: {
      value: null
    },
    resolution: {
      value: new Vector2()
    },
    near: {
      value: 0.1
    },
    far: {
      value: 1e3
    },
    viewMatrixInv: {
      value: new Matrix4()
    },
    projectionMatrixInv: {
      value: new Matrix4()
    },
    logDepth: {
      value: false
    },
    ortho: {
      value: false
    }
  },
  depthWrite: false,
  depthTest: false,
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = vec4(position, 1);
    }`
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform highp sampler2D sceneDepth;
    uniform vec2 resolution;
    uniform float near;
    uniform float far;
    uniform bool logDepth;
    uniform bool ortho;
    uniform mat4 viewMatrixInv;
    uniform mat4 projectionMatrixInv;
    varying vec2 vUv;
    layout(location = 1) out vec4 gNormal;
    vec3 getWorldPosLog(vec3 posS) {
        vec2 uv = posS.xy;
        float z = posS.z;
        float nearZ =near;
        float farZ = far;
        float depth = pow(2.0, z * log2(farZ + 1.0)) - 1.0;
        float a = farZ / (farZ - nearZ);
        float b = farZ * nearZ / (nearZ - farZ);
        float linDepth = a + b / depth;
        vec4 clipVec = vec4(uv, linDepth, 1.0) * 2.0 - 1.0;
        vec4 wpos = projectionMatrixInv * clipVec;
        return wpos.xyz / wpos.w;
      }
      vec3 getWorldPos(float depth, vec2 coord) {
        if (logDepth && !ortho) {
          return getWorldPosLog(vec3(coord, depth));
        }
        float z = depth * 2.0 - 1.0;
        vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);
        vec4 viewSpacePosition = projectionMatrixInv * clipSpacePosition;
        // Perspective division
       vec4 worldSpacePosition = viewSpacePosition;
       worldSpacePosition.xyz /= worldSpacePosition.w;
        return worldSpacePosition.xyz;
    }
  
    vec3 computeNormal(vec3 worldPos, vec2 vUv) {
      ivec2 p = ivec2(vUv * resolution);
      float c0 = texelFetch(sceneDepth, p, 0).x;
      float l2 = texelFetch(sceneDepth, p - ivec2(2, 0), 0).x;
      float l1 = texelFetch(sceneDepth, p - ivec2(1, 0), 0).x;
      float r1 = texelFetch(sceneDepth, p + ivec2(1, 0), 0).x;
      float r2 = texelFetch(sceneDepth, p + ivec2(2, 0), 0).x;
      float b2 = texelFetch(sceneDepth, p - ivec2(0, 2), 0).x;
      float b1 = texelFetch(sceneDepth, p - ivec2(0, 1), 0).x;
      float t1 = texelFetch(sceneDepth, p + ivec2(0, 1), 0).x;
      float t2 = texelFetch(sceneDepth, p + ivec2(0, 2), 0).x;
  
      float dl = abs((2.0 * l1 - l2) - c0);
      float dr = abs((2.0 * r1 - r2) - c0);
      float db = abs((2.0 * b1 - b2) - c0);
      float dt = abs((2.0 * t1 - t2) - c0);
  
      vec3 ce = getWorldPos(c0, vUv).xyz;
  
      vec3 dpdx = (dl < dr) ? ce - getWorldPos(l1, (vUv - vec2(1.0 / resolution.x, 0.0))).xyz
                            : -ce + getWorldPos(r1, (vUv + vec2(1.0 / resolution.x, 0.0))).xyz;
      vec3 dpdy = (db < dt) ? ce - getWorldPos(b1, (vUv - vec2(0.0, 1.0 / resolution.y))).xyz
                            : -ce + getWorldPos(t1, (vUv + vec2(0.0, 1.0 / resolution.y))).xyz;
  
      return normalize(cross(dpdx, dpdy));
  }
    void main() {
        vec2 uv = vUv - vec2(0.5) / resolution;
        vec2 pixelSize = vec2(1.0) / resolution;
        highp vec2[4] uvSamples;
        uvSamples[0] = uv;
        uvSamples[1] = uv + vec2(pixelSize.x, 0.0);
        uvSamples[2] = uv + vec2(0.0, pixelSize.y);
        uvSamples[3] = uv + pixelSize;
        float depth00 = texture2D(sceneDepth, uvSamples[0]).r;
        float depth10 = texture2D(sceneDepth, uvSamples[1]).r;
        float depth01 = texture2D(sceneDepth, uvSamples[2]).r;
        float depth11 = texture2D(sceneDepth, uvSamples[3]).r;
        float minDepth = min(min(depth00, depth10), min(depth01, depth11));
        float maxDepth = max(max(depth00, depth10), max(depth01, depth11));
        float targetDepth = minDepth;
        // Checkerboard pattern to avoid artifacts
        if (mod(gl_FragCoord.x + gl_FragCoord.y, 2.0) > 0.5) { 
            targetDepth = maxDepth;
        }
        int chosenIndex = 0;
        float[4] samples;
        samples[0] = depth00;
        samples[1] = depth10;
        samples[2] = depth01;
        samples[3] = depth11;
        for(int i = 0; i < 4; ++i) {
            if (samples[i] == targetDepth) {
                chosenIndex = i;
                break;
            }
        }
        gl_FragColor = vec4(samples[chosenIndex], 0.0, 0.0, 1.0);
        gNormal = vec4(computeNormal(
            getWorldPos(samples[chosenIndex], uvSamples[chosenIndex]), uvSamples[chosenIndex]
        ), 0.0);
    }`
  )
};
var on = "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";
var Sl = parseInt(REVISION.replace(/\D+/g, ""));
var El = Sl >= 162 ? class extends WebGLRenderTarget {
  constructor(a = 1, t = 1, e = 1, i = {}) {
    super(a, t, {
      ...i,
      count: e
    }), this.isWebGLMultipleRenderTargets = true;
  }
  get texture() {
    return this.textures;
  }
} : class extends WebGLRenderTarget {
  constructor(a = 1, t = 1, e = 1, i = {}) {
    super(a, t, i), this.isWebGLMultipleRenderTargets = true;
    const s = this.texture;
    this.texture = [];
    for (let r = 0; r < e; r++)
      this.texture[r] = s.clone(), this.texture[r].isRenderTargetTexture = true;
  }
  setSize(a, t, e = 1) {
    if (this.width !== a || this.height !== t || this.depth !== e) {
      this.width = a, this.height = t, this.depth = e;
      for (let i = 0, s = this.texture.length; i < s; i++)
        this.texture[i].image.width = a, this.texture[i].image.height = t, this.texture[i].image.depth = e;
      this.dispose();
    }
    this.viewport.set(0, 0, a, t), this.scissor.set(0, 0, a, t);
  }
  copy(a) {
    this.dispose(), this.width = a.width, this.height = a.height, this.depth = a.depth, this.scissor.copy(a.scissor), this.scissorTest = a.scissorTest, this.viewport.copy(a.viewport), this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, a.depthTexture !== null && (this.depthTexture = a.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, e = a.texture.length; t < e; t++)
      this.texture[t] = a.texture[t].clone(), this.texture[t].isRenderTargetTexture = true;
    return this;
  }
};
Uint8Array.from(atob(on), (a) => a.charCodeAt(0));
var Al = Uint8Array.from(atob(on), (a) => a.charCodeAt(0));
function an(a, t, e) {
  if (t.getQueryParameter(a, t.QUERY_RESULT_AVAILABLE)) {
    const r = t.getQueryParameter(a, t.QUERY_RESULT) / 1e6;
    e.lastTime = e.lastTime === 0 ? r : e.timeRollingAverage * e.lastTime + (1 - e.timeRollingAverage) * r;
  } else
    setTimeout(() => {
      an(a, t, e);
    }, 1);
}
var Ol = class extends Ue {
  /**
   * 
   * @param {THREE.Scene} scene
   * @param {THREE.Camera} camera 
   * @param {number} width 
   * @param {number} height
   *  
   * @property {THREE.Scene} scene
   * @property {THREE.Camera} camera
   * @property {number} width
   * @property {number} height
   */
  constructor(t, e, i = 512, s = 512) {
    super(), this.width = i, this.height = s, this.clear = true, this.camera = e, this.scene = t, this.configuration = new Proxy({
      aoSamples: 16,
      aoRadius: 5,
      aoTones: 0,
      denoiseSamples: 8,
      denoiseRadius: 12,
      distanceFalloff: 1,
      intensity: 5,
      denoiseIterations: 2,
      renderMode: 0,
      biasOffset: 0,
      biasMultiplier: 0,
      color: new Color(0, 0, 0),
      gammaCorrection: true,
      logarithmicDepthBuffer: false,
      screenSpaceRadius: false,
      halfRes: false,
      depthAwareUpsampling: true,
      autoRenderBeauty: true,
      colorMultiply: true,
      transparencyAware: false,
      stencil: false,
      accumulate: false
    }, {
      set: (r, o, n) => {
        const l = r[o];
        return r[o] = n, n.equals ? n.equals(l) || this.firstFrame() : l !== n && this.firstFrame(), o === "aoSamples" && l !== n && this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), o === "denoiseSamples" && l !== n && this.configureDenoisePass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), o === "halfRes" && l !== n && (this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureHalfResTargets(), this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.setSize(this.width, this.height)), o === "depthAwareUpsampling" && l !== n && this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), o === "transparencyAware" && l !== n && (this.autoDetectTransparency = false, this.configureTransparencyTarget()), o === "stencil" && l !== n && (this.beautyRenderTarget.dispose(), this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
          minFilter: LinearFilter,
          magFilter: NearestFilter,
          type: HalfFloatType,
          format: RGBAFormat,
          stencilBuffer: n
        }), this.beautyRenderTarget.depthTexture = new DepthTexture(this.width, this.height, n ? UnsignedInt248Type : UnsignedIntType), this.beautyRenderTarget.depthTexture.format = n ? DepthStencilFormat : DepthFormat), true;
      }
    }), this.samples = [], this.samplesDenoise = [], this.autoDetectTransparency = true, this.frame = 0, this.lastViewMatrix = new Matrix4(), this.lastProjectionMatrix = new Matrix4(), this.beautyRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: NearestFilter,
      type: HalfFloatType,
      format: RGBAFormat,
      stencilBuffer: false
    }), this.beautyRenderTarget.depthTexture = new DepthTexture(this.width, this.height, UnsignedIntType), this.beautyRenderTarget.depthTexture.format = DepthFormat, this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureSampleDependentPasses(), this.configureHalfResTargets(), this.detectTransparency(), this.configureTransparencyTarget(), this.writeTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false,
      format: RGBAFormat
    }), this.readTargetInternal = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false,
      format: RGBAFormat
    }), this.accumulationRenderTarget = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      depthBuffer: false,
      format: RGBAFormat,
      type: HalfFloatType,
      stencilBuffer: false,
      depthBuffer: false,
      alpha: true
    }), this.bluenoise = new DataTexture(Al, 128, 128), this.accumulationQuad = new Ie(new ShaderMaterial({
      uniforms: {
        frame: {
          value: 0
        },
        tDiffuse: {
          value: null
        }
      },
      transparent: true,
      opacity: 1,
      vertexShader: `
             varying vec2 vUv;
             void main() {
                 vUv = uv;
                 gl_Position = vec4(position, 1);
             }`,
      fragmentShader: `
             uniform sampler2D tDiffuse;
             uniform float frame;
                varying vec2 vUv;
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    gl_FragColor = vec4(color.rgb, 1.0 / (frame + 1.0));
                }
                `
    })), this.bluenoise.colorSpace = NoColorSpace, this.bluenoise.wrapS = RepeatWrapping, this.bluenoise.wrapT = RepeatWrapping, this.bluenoise.minFilter = NearestFilter, this.bluenoise.magFilter = NearestFilter, this.bluenoise.needsUpdate = true, this.lastTime = 0, this.timeRollingAverage = 0.99, this._r = new Vector2(), this._c = new Color();
  }
  configureHalfResTargets() {
    this.firstFrame(), this.configuration.halfRes ? (this.depthDownsampleTarget = new El(this.width / 2, this.height / 2, 2), REVISION <= 161 && (this.depthDownsampleTarget.textures = this.depthDownsampleTarget.texture), this.depthDownsampleTarget.textures[0].format = RedFormat, this.depthDownsampleTarget.textures[0].type = FloatType, this.depthDownsampleTarget.textures[0].minFilter = NearestFilter, this.depthDownsampleTarget.textures[0].magFilter = NearestFilter, this.depthDownsampleTarget.textures[0].depthBuffer = false, this.depthDownsampleTarget.textures[1].format = RGBAFormat, this.depthDownsampleTarget.textures[1].type = HalfFloatType, this.depthDownsampleTarget.textures[1].minFilter = NearestFilter, this.depthDownsampleTarget.textures[1].magFilter = NearestFilter, this.depthDownsampleTarget.textures[1].depthBuffer = false, this.depthDownsampleQuad = new Ie(new ShaderMaterial(Cl))) : (this.depthDownsampleTarget && (this.depthDownsampleTarget.dispose(), this.depthDownsampleTarget = null), this.depthDownsampleQuad && (this.depthDownsampleQuad.dispose(), this.depthDownsampleQuad = null));
  }
  detectTransparency() {
    if (this.autoDetectTransparency) {
      let t = false;
      this.scene.traverse((e) => {
        e.material && e.material.transparent && (t = true);
      }), this.configuration.transparencyAware = t;
    }
  }
  configureTransparencyTarget() {
    this.configuration.transparencyAware ? (this.transparencyRenderTargetDWFalse = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: NearestFilter,
      type: HalfFloatType,
      format: RGBAFormat
    }), this.transparencyRenderTargetDWTrue = new WebGLRenderTarget(this.width, this.height, {
      minFilter: LinearFilter,
      magFilter: NearestFilter,
      type: HalfFloatType,
      format: RGBAFormat
    }), this.transparencyRenderTargetDWTrue.depthTexture = new DepthTexture(this.width, this.height, UnsignedIntType), this.depthCopyPass = new Ie(new ShaderMaterial({
      uniforms: {
        depthTexture: {
          value: this.beautyRenderTarget.depthTexture
        }
      },
      vertexShader: (
        /* glsl */
        `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1);
            }`
      ),
      fragmentShader: (
        /* glsl */
        `
            uniform sampler2D depthTexture;
            varying vec2 vUv;
            void main() {
               gl_FragDepth = texture2D(depthTexture, vUv).r + 0.00001;
               gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            }
            `
      )
    }))) : (this.transparencyRenderTargetDWFalse && (this.transparencyRenderTargetDWFalse.dispose(), this.transparencyRenderTargetDWFalse = null), this.transparencyRenderTargetDWTrue && (this.transparencyRenderTargetDWTrue.dispose(), this.transparencyRenderTargetDWTrue = null), this.depthCopyPass && (this.depthCopyPass.dispose(), this.depthCopyPass = null));
  }
  renderTransparency(t) {
    const e = this.scene.background, i = t.getClearColor(new Color()), s = t.getClearAlpha(), r = /* @__PURE__ */ new Map(), o = t.autoClearDepth;
    this.scene.traverse((n) => {
      r.set(n, n.visible);
    }), this.scene.background = null, t.autoClearDepth = false, t.setClearColor(new Color(0, 0, 0), 0), this.depthCopyPass.material.uniforms.depthTexture.value = this.beautyRenderTarget.depthTexture, t.setRenderTarget(this.transparencyRenderTargetDWFalse), this.scene.traverse((n) => {
      n.material && (n.visible = r.get(n) && (n.material.transparent && !n.material.depthWrite && !n.userData.treatAsOpaque || !!n.userData.cannotReceiveAO));
    }), t.clear(true, true, true), this.depthCopyPass.render(t), t.render(this.scene, this.camera), t.setRenderTarget(this.transparencyRenderTargetDWTrue), this.scene.traverse((n) => {
      n.material && (n.visible = r.get(n) && n.material.transparent && n.material.depthWrite && !n.userData.treatAsOpaque);
    }), t.clear(true, true, true), this.depthCopyPass.render(t), t.render(this.scene, this.camera), this.scene.traverse((n) => {
      n.visible = r.get(n);
    }), t.setClearColor(i, s), this.scene.background = e, t.autoClearDepth = o;
  }
  configureSampleDependentPasses() {
    this.firstFrame(), this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureDenoisePass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera);
  }
  configureAOPass(t = false, e = false) {
    this.firstFrame(), this.samples = this.generateHemisphereSamples(this.configuration.aoSamples);
    const i = {
      ...xl
    };
    i.fragmentShader = i.fragmentShader.replace("16", this.configuration.aoSamples).replace("16.0", this.configuration.aoSamples + ".0"), t && (i.fragmentShader = `#define LOGDEPTH
` + i.fragmentShader), e && (i.fragmentShader = `#define ORTHO
` + i.fragmentShader), this.configuration.halfRes && (i.fragmentShader = `#define HALFRES
` + i.fragmentShader), this.effectShaderQuad ? (this.effectShaderQuad.material.dispose(), this.effectShaderQuad.material = new ShaderMaterial(i)) : this.effectShaderQuad = new Ie(new ShaderMaterial(i));
  }
  configureDenoisePass(t = false, e = false) {
    this.firstFrame(), this.samplesDenoise = this.generateDenoiseSamples(this.configuration.denoiseSamples, 11);
    const i = {
      ...Tl
    };
    i.fragmentShader = i.fragmentShader.replace("16", this.configuration.denoiseSamples), t && (i.fragmentShader = `#define LOGDEPTH
` + i.fragmentShader), e && (i.fragmentShader = `#define ORTHO
` + i.fragmentShader), this.poissonBlurQuad ? (this.poissonBlurQuad.material.dispose(), this.poissonBlurQuad.material = new ShaderMaterial(i)) : this.poissonBlurQuad = new Ie(new ShaderMaterial(i));
  }
  configureEffectCompositer(t = false, e = false) {
    this.firstFrame();
    const i = {
      ..._l
    };
    t && (i.fragmentShader = `#define LOGDEPTH
` + i.fragmentShader), e && (i.fragmentShader = `#define ORTHO
` + i.fragmentShader), this.configuration.halfRes && this.configuration.depthAwareUpsampling && (i.fragmentShader = `#define HALFRES
` + i.fragmentShader), this.effectCompositerQuad ? (this.effectCompositerQuad.material.dispose(), this.effectCompositerQuad.material = new ShaderMaterial(i)) : this.effectCompositerQuad = new Ie(new ShaderMaterial(i));
  }
  /**
       * 
       * @param {Number} n 
       * @returns {THREE.Vector3[]}
       */
  generateHemisphereSamples(t) {
    const e = [];
    for (let i = 0; i < t; i++) {
      const s = 2.399963 * i;
      let r = Math.sqrt(i + 0.5) / Math.sqrt(t);
      const o = r * Math.cos(s), n = r * Math.sin(s), l = Math.sqrt(1 - (o * o + n * n));
      e.push(new Vector3(o, n, l));
    }
    return e;
  }
  /**
       * 
       * @param {number} numSamples 
       * @param {number} numRings 
       * @returns {THREE.Vector2[]}
       */
  generateDenoiseSamples(t, e) {
    const i = 2 * Math.PI * e / t, s = 1 / t, r = s, o = [];
    let n = s, l = 0;
    for (let c = 0; c < t; c++)
      o.push(new Vector2(Math.cos(l), Math.sin(l)).multiplyScalar(Math.pow(n, 0.75))), n += r, l += i;
    return o;
  }
  setSize(t, e) {
    this.firstFrame(), this.width = t, this.height = e;
    const i = this.configuration.halfRes ? 0.5 : 1;
    this.beautyRenderTarget.setSize(t, e), this.writeTargetInternal.setSize(t * i, e * i), this.readTargetInternal.setSize(t * i, e * i), this.accumulationRenderTarget.setSize(t * i, e * i), this.configuration.halfRes && this.depthDownsampleTarget.setSize(t * i, e * i), this.configuration.transparencyAware && (this.transparencyRenderTargetDWFalse.setSize(t, e), this.transparencyRenderTargetDWTrue.setSize(t, e));
  }
  firstFrame() {
    this.needsFrame = true;
  }
  render(t, e, i, s, r) {
    t.capabilities.logarithmicDepthBuffer !== this.configuration.logarithmicDepthBuffer && (this.configuration.logarithmicDepthBuffer = t.capabilities.logarithmicDepthBuffer, this.configureAOPass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureDenoisePass(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera), this.configureEffectCompositer(this.configuration.logarithmicDepthBuffer, this.camera.isOrthographicCamera)), this.detectTransparency(), this.camera.updateMatrixWorld(), this.lastViewMatrix.equals(this.camera.matrixWorldInverse) && this.lastProjectionMatrix.equals(this.camera.projectionMatrix) && this.configuration.accumulate && !this.needsFrame ? this.frame++ : (this.configuration.accumulate && (t.setRenderTarget(this.accumulationRenderTarget), t.clear(true, true, true)), this.frame = 0, this.needsFrame = false), this.lastViewMatrix.copy(this.camera.matrixWorldInverse), this.lastProjectionMatrix.copy(this.camera.projectionMatrix);
    let o, n, l;
    this.debugMode && (o = t.getContext(), n = o.getExtension("EXT_disjoint_timer_query_webgl2"), n === null && (console.error("EXT_disjoint_timer_query_webgl2 not available, disabling debug mode."), this.debugMode = false)), this.configuration.autoRenderBeauty && (t.setRenderTarget(this.beautyRenderTarget), t.render(this.scene, this.camera), this.configuration.transparencyAware && this.renderTransparency(t)), this.debugMode && (l = o.createQuery(), o.beginQuery(n.TIME_ELAPSED_EXT, l));
    const c = t.xr.enabled;
    t.xr.enabled = false, this._r.set(this.width, this.height);
    let d = this.configuration.aoRadius;
    if (this.configuration.halfRes && this.configuration.screenSpaceRadius && (d *= 0.5), this.frame < 1024 / this.configuration.aoSamples) {
      this.configuration.halfRes && (t.setRenderTarget(this.depthDownsampleTarget), this.depthDownsampleQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture, this.depthDownsampleQuad.material.uniforms.resolution.value = this._r, this.depthDownsampleQuad.material.uniforms.near.value = this.camera.near, this.depthDownsampleQuad.material.uniforms.far.value = this.camera.far, this.depthDownsampleQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.depthDownsampleQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.depthDownsampleQuad.material.uniforms.logDepth.value = this.configuration.logarithmicDepthBuffer, this.depthDownsampleQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.depthDownsampleQuad.render(t)), this.effectShaderQuad.material.uniforms.sceneDiffuse.value = this.beautyRenderTarget.texture, this.effectShaderQuad.material.uniforms.sceneDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.beautyRenderTarget.depthTexture, this.effectShaderQuad.material.uniforms.sceneNormal.value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[1] : null, this.effectShaderQuad.material.uniforms.projMat.value = this.camera.projectionMatrix, this.effectShaderQuad.material.uniforms.viewMat.value = this.camera.matrixWorldInverse, this.effectShaderQuad.material.uniforms.projViewMat.value = this.camera.projectionMatrix.clone().multiply(this.camera.matrixWorldInverse.clone()), this.effectShaderQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.effectShaderQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.effectShaderQuad.material.uniforms.cameraPos.value = this.camera.getWorldPosition(new Vector3()), this.effectShaderQuad.material.uniforms.biasAdjustment.value = new Vector2(this.configuration.biasOffset, this.configuration.biasMultiplier), this.effectShaderQuad.material.uniforms.resolution.value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r, this.effectShaderQuad.material.uniforms.time.value = performance.now() / 1e3, this.effectShaderQuad.material.uniforms.samples.value = this.samples, this.effectShaderQuad.material.uniforms.bluenoise.value = this.bluenoise, this.effectShaderQuad.material.uniforms.radius.value = d, this.effectShaderQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.effectShaderQuad.material.uniforms.near.value = this.camera.near, this.effectShaderQuad.material.uniforms.far.value = this.camera.far, this.effectShaderQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.effectShaderQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.effectShaderQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, this.effectShaderQuad.material.uniforms.frame.value = this.frame, t.setRenderTarget(this.writeTargetInternal), this.effectShaderQuad.render(t);
      for (let p = 0; p < this.configuration.denoiseIterations; p++)
        [this.writeTargetInternal, this.readTargetInternal] = [
          this.readTargetInternal,
          this.writeTargetInternal
        ], this.poissonBlurQuad.material.uniforms.tDiffuse.value = this.readTargetInternal.texture, this.poissonBlurQuad.material.uniforms.sceneDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.beautyRenderTarget.depthTexture, this.poissonBlurQuad.material.uniforms.projMat.value = this.camera.projectionMatrix, this.poissonBlurQuad.material.uniforms.viewMat.value = this.camera.matrixWorldInverse, this.poissonBlurQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.poissonBlurQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.poissonBlurQuad.material.uniforms.cameraPos.value = this.camera.getWorldPosition(new Vector3()), this.poissonBlurQuad.material.uniforms.resolution.value = this.configuration.halfRes ? this._r.clone().multiplyScalar(0.5).floor() : this._r, this.poissonBlurQuad.material.uniforms.time.value = performance.now() / 1e3, this.poissonBlurQuad.material.uniforms.blueNoise.value = this.bluenoise, this.poissonBlurQuad.material.uniforms.radius.value = this.configuration.denoiseRadius * (this.configuration.halfRes ? 0.5 : 1), this.poissonBlurQuad.material.uniforms.worldRadius.value = d, this.poissonBlurQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.poissonBlurQuad.material.uniforms.index.value = p, this.poissonBlurQuad.material.uniforms.poissonDisk.value = this.samplesDenoise, this.poissonBlurQuad.material.uniforms.near.value = this.camera.near, this.poissonBlurQuad.material.uniforms.far.value = this.camera.far, this.poissonBlurQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.poissonBlurQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, t.setRenderTarget(this.writeTargetInternal), this.poissonBlurQuad.render(t);
      t.setRenderTarget(this.accumulationRenderTarget);
      const f = t.autoClear;
      t.autoClear = false, this.accumulationQuad.material.uniforms.tDiffuse.value = this.writeTargetInternal.texture, this.accumulationQuad.material.uniforms.frame.value = this.frame, this.accumulationQuad.render(t), t.autoClear = f;
    }
    this.configuration.transparencyAware && (this.effectCompositerQuad.material.uniforms.transparencyDWFalse.value = this.transparencyRenderTargetDWFalse.texture, this.effectCompositerQuad.material.uniforms.transparencyDWTrue.value = this.transparencyRenderTargetDWTrue.texture, this.effectCompositerQuad.material.uniforms.transparencyDWTrueDepth.value = this.transparencyRenderTargetDWTrue.depthTexture, this.effectCompositerQuad.material.uniforms.transparencyAware.value = true), this.effectCompositerQuad.material.uniforms.sceneDiffuse.value = this.beautyRenderTarget.texture, this.effectCompositerQuad.material.uniforms.sceneDepth.value = this.beautyRenderTarget.depthTexture, this.effectCompositerQuad.material.uniforms.aoTones.value = this.configuration.aoTones, this.effectCompositerQuad.material.uniforms.near.value = this.camera.near, this.effectCompositerQuad.material.uniforms.far.value = this.camera.far, this.effectCompositerQuad.material.uniforms.projectionMatrixInv.value = this.camera.projectionMatrixInverse, this.effectCompositerQuad.material.uniforms.viewMatrixInv.value = this.camera.matrixWorld, this.effectCompositerQuad.material.uniforms.logDepth.value = t.capabilities.logarithmicDepthBuffer, this.effectCompositerQuad.material.uniforms.ortho.value = this.camera.isOrthographicCamera, this.effectCompositerQuad.material.uniforms.downsampledDepth.value = this.configuration.halfRes ? this.depthDownsampleTarget.textures[0] : this.beautyRenderTarget.depthTexture, this.effectCompositerQuad.material.uniforms.resolution.value = this._r, this.effectCompositerQuad.material.uniforms.blueNoise.value = this.bluenoise, this.effectCompositerQuad.material.uniforms.intensity.value = this.configuration.intensity, this.effectCompositerQuad.material.uniforms.renderMode.value = this.configuration.renderMode, this.effectCompositerQuad.material.uniforms.screenSpaceRadius.value = this.configuration.screenSpaceRadius, this.effectCompositerQuad.material.uniforms.radius.value = d, this.effectCompositerQuad.material.uniforms.distanceFalloff.value = this.configuration.distanceFalloff, this.effectCompositerQuad.material.uniforms.gammaCorrection.value = this.configuration.gammaCorrection, this.effectCompositerQuad.material.uniforms.tDiffuse.value = this.accumulationRenderTarget.texture, this.effectCompositerQuad.material.uniforms.color.value = this._c.copy(this.configuration.color).convertSRGBToLinear(), this.effectCompositerQuad.material.uniforms.colorMultiply.value = this.configuration.colorMultiply, this.effectCompositerQuad.material.uniforms.cameraPos.value = this.camera.getWorldPosition(new Vector3()), this.effectCompositerQuad.material.uniforms.fog.value = !!this.scene.fog, this.scene.fog && (this.scene.fog.isFog ? (this.effectCompositerQuad.material.uniforms.fogExp.value = false, this.effectCompositerQuad.material.uniforms.fogNear.value = this.scene.fog.near, this.effectCompositerQuad.material.uniforms.fogFar.value = this.scene.fog.far) : this.scene.fog.isFogExp2 ? (this.effectCompositerQuad.material.uniforms.fogExp.value = true, this.effectCompositerQuad.material.uniforms.fogDensity.value = this.scene.fog.density) : console.error(`Unsupported fog type ${this.scene.fog.constructor.name} in SSAOPass.`)), t.setRenderTarget(this.renderToScreen ? null : e), this.effectCompositerQuad.render(t), this.debugMode && (o.endQuery(n.TIME_ELAPSED_EXT), an(l, o, this)), t.xr.enabled = c;
  }
  /**
       * Enables the debug mode of the AO, meaning the lastTime value will be updated.
       */
  enableDebugMode() {
    this.debugMode = true;
  }
  /**
       * Disables the debug mode of the AO, meaning the lastTime value will not be updated.
       */
  disableDebugMode() {
    this.debugMode = false;
  }
  /**
       * Sets the display mode of the AO
       * @param {"Combined" | "AO" | "No AO" | "Split" | "Split AO"} mode - The display mode. 
       */
  setDisplayMode(t) {
    this.configuration.renderMode = [
      "Combined",
      "AO",
      "No AO",
      "Split",
      "Split AO"
    ].indexOf(t);
  }
  /**
       * 
       * @param {"Performance" | "Low" | "Medium" | "High" | "Ultra"} mode 
       */
  setQualityMode(t) {
    t === "Performance" ? (this.configuration.aoSamples = 8, this.configuration.denoiseSamples = 4, this.configuration.denoiseRadius = 12) : t === "Low" ? (this.configuration.aoSamples = 16, this.configuration.denoiseSamples = 4, this.configuration.denoiseRadius = 12) : t === "Medium" ? (this.configuration.aoSamples = 16, this.configuration.denoiseSamples = 8, this.configuration.denoiseRadius = 12) : t === "High" ? (this.configuration.aoSamples = 64, this.configuration.denoiseSamples = 8, this.configuration.denoiseRadius = 6) : t === "Ultra" && (this.configuration.aoSamples = 64, this.configuration.denoiseSamples = 16, this.configuration.denoiseRadius = 6);
  }
};
var Dl = {
  name: "GammaCorrectionShader",
  uniforms: {
    tDiffuse: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = sRGBTransferOETF( tex );

		}`
  )
};
function Pl() {
  return new ShaderMaterial({
    side: 2,
    clipping: true,
    uniforms: {},
    vertexShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
    
       vec4 absPosition = vec4(position, 1.0);
       vec3 trueNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          trueNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       trueNormal = (normalize(modelMatrix * vec4(trueNormal, 0.))).xyz;
       
       vec3 planePosition = absPosition.xyz / 40.;
       float d = abs(dot(trueNormal, planePosition));
       vColor = vec4(abs(trueNormal), d);
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec4 vColor;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      gl_FragColor = vColor;
    }
    `
  });
}
function zl() {
  return new ShaderMaterial({
    side: 2,
    clipping: true,
    uniforms: {},
    vertexShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_vertex>
  
    void main() {
       #include <begin_vertex>
       
       vec4 absPosition = vec4(position, 1.0);
       vNormal = normal;
       
       #ifdef USE_INSTANCING
          absPosition = instanceMatrix * absPosition;
          vNormal = (instanceMatrix * vec4(normal, 0.)).xyz;
       #endif
       
       absPosition = modelMatrix * absPosition;
       vNormal = (normalize(modelMatrix * vec4(vNormal, 0.))).xyz;
       
       gl_Position = projectionMatrix * viewMatrix * absPosition;
       
       vCameraPosition = cameraPosition;
       vPosition = absPosition.xyz;
       
       #include <project_vertex>
       #include <clipping_planes_vertex>
    }
    `,
    fragmentShader: `
    varying vec3 vCameraPosition;
    varying vec3 vPosition;
    varying vec3 vNormal;
    
    #include <clipping_planes_pars_fragment>
  
    void main() {
      #include <clipping_planes_fragment>
      vec3 cameraPixelVec = normalize(vCameraPosition - vPosition);
      float difference = abs(dot(vNormal, cameraPixelVec));
      
      // This achieves a double gloss effect: when the surface is perpendicular and when it's parallel
      difference = abs((difference * 2.) - 1.);
      
      gl_FragColor = vec4(difference, difference, difference, 1.);
    }
    `
  });
}
var kl = class extends Ue {
  constructor(e, i, s, r, o) {
    super();
    G(this, "components");
    G(this, "resolution");
    G(this, "renderScene");
    G(this, "renderCamera");
    G(this, "fsQuad");
    G(this, "normalOverrideMaterial");
    G(this, "glossOverrideMaterial");
    G(this, "outlineMaterial", new MeshBasicMaterial({
      color: 13168215,
      transparent: true,
      opacity: 0.7
    }));
    G(this, "planeBuffer");
    G(this, "glossBuffer");
    G(this, "outlineBuffer");
    G(this, "excludedMeshes", []);
    G(this, "outlinedStyles", /* @__PURE__ */ new Set());
    G(this, "outlineScene", new Scene());
    G(this, "_outlineEnabled", false);
    G(this, "_lineColor", 10066329);
    G(this, "_opacity", 0.4);
    G(this, "_tolerance", 3);
    G(this, "_glossEnabled", true);
    G(this, "_glossExponent", 1.9);
    G(this, "_minGloss", -0.1);
    G(this, "_maxGloss", 0.1);
    G(this, "_fragments");
    if (!s.renderer)
      throw new Error("The given world must have a renderer!");
    this._fragments = i.get(It), this.components = i, this.renderScene = r, this.renderCamera = o, this.resolution = new Vector2(e.x, e.y), this.fsQuad = new rn(), this.fsQuad.material = this.createOutlinePostProcessMaterial(), this.planeBuffer = this.newRenderTarget(), this.glossBuffer = this.newRenderTarget(), this.outlineBuffer = this.newRenderTarget();
    const n = Pl();
    n.clippingPlanes = s.renderer.clippingPlanes, this.normalOverrideMaterial = n;
    const l = zl();
    l.clippingPlanes = s.renderer.clippingPlanes, this.glossOverrideMaterial = l, this.outlineScene.overrideMaterial = this.outlineMaterial;
  }
  get lineColor() {
    return this._lineColor;
  }
  set lineColor(e) {
    this._lineColor = e, this.fsQuad.material.uniforms.lineColor.value.set(e);
  }
  get tolerance() {
    return this._tolerance;
  }
  set tolerance(e) {
    this._tolerance = e;
    const i = this.fsQuad.material;
    i.uniforms.tolerance.value = e;
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e) {
    this._opacity = e;
    const i = this.fsQuad.material;
    i.uniforms.opacity.value = e;
  }
  get glossEnabled() {
    return this._glossEnabled;
  }
  set glossEnabled(e) {
    if (e === this._glossEnabled)
      return;
    this._glossEnabled = e;
    const i = this.fsQuad.material;
    i.uniforms.glossEnabled.value = e ? 1 : 0;
  }
  get glossExponent() {
    return this._glossExponent;
  }
  set glossExponent(e) {
    this._glossExponent = e;
    const i = this.fsQuad.material;
    i.uniforms.glossExponent.value = e;
  }
  get minGloss() {
    return this._minGloss;
  }
  set minGloss(e) {
    this._minGloss = e;
    const i = this.fsQuad.material;
    i.uniforms.minGloss.value = e;
  }
  get maxGloss() {
    return new MeshBasicMaterial().color.convertLinearToSRGB(), this._maxGloss;
  }
  set maxGloss(e) {
    this._maxGloss = e;
    const i = this.fsQuad.material;
    i.uniforms.maxGloss.value = e;
  }
  get outlineEnabled() {
    return this._outlineEnabled;
  }
  set outlineEnabled(e) {
    if (e === this._outlineEnabled)
      return;
    this._outlineEnabled = e;
    const i = this.fsQuad.material;
    i.uniforms.outlineEnabled.value = e ? 1 : 0;
  }
  async dispose() {
    this.planeBuffer.dispose(), this.glossBuffer.dispose(), this.outlineBuffer.dispose(), this.normalOverrideMaterial.dispose(), this.glossOverrideMaterial.dispose(), this.fsQuad.material.dispose(), this.fsQuad.dispose(), this.excludedMeshes = [], this.outlineScene.children = [];
  }
  setSize(e, i) {
    this.planeBuffer.setSize(e, i), this.glossBuffer.setSize(e, i), this.outlineBuffer.setSize(e, i), this.resolution.set(e, i);
    const s = this.fsQuad.material;
    s.uniforms.screenSize.value.set(
      this.resolution.x,
      this.resolution.y,
      1 / this.resolution.x,
      1 / this.resolution.y
    ), s.uniformsNeedUpdate = true;
  }
  render(e, i, s) {
    const r = i.depthBuffer;
    i.depthBuffer = false, this._fragments.initialized && this._fragments.core.models.traverseMaterials((c) => {
      c.isLODMaterial && (c.visible = false);
    });
    const o = this.renderScene.overrideMaterial, n = this.renderScene.background;
    this.renderScene.background = null;
    for (const c of this.excludedMeshes)
      c.visible = false;
    if (e.setRenderTarget(this.planeBuffer), this.renderScene.overrideMaterial = this.normalOverrideMaterial, e.render(this.renderScene, this.renderCamera), this._glossEnabled && (e.setRenderTarget(this.glossBuffer), this.renderScene.overrideMaterial = this.glossOverrideMaterial, e.render(this.renderScene, this.renderCamera)), this.renderScene.overrideMaterial = o, e.setRenderTarget(this.outlineBuffer), this._outlineEnabled && this._fragments.initialized) {
      const c = [];
      this._fragments.core.models.traverseMaterials((d) => {
        const { customId: f } = d.userData;
        (f === void 0 || !this.outlinedStyles.has(f)) && (d.visible = false, c.push(d));
      });
      for (const [, d] of this._fragments.core.models.list)
        this.outlineScene.add(d.object);
      e.render(this.outlineScene, this.renderCamera);
      for (const [, d] of this._fragments.core.models.list)
        this.renderScene.add(d.object);
      for (const d of c)
        d.visible = true;
    } else
      e.clear();
    for (const c of this.excludedMeshes)
      c.visible = true;
    this.renderScene.background = n;
    const l = this.fsQuad.material;
    l.uniforms.planeBuffer.value = this.planeBuffer.texture, l.uniforms.glossBuffer.value = this.glossBuffer.texture, l.uniforms.outlineBuffer.value = this.outlineBuffer.texture, l.uniforms.sceneColorBuffer.value = s.texture, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.fsQuad.render(e)), this._fragments.initialized && this._fragments.core.models.traverseMaterials((c) => {
      c.isLODMaterial && (c.visible = true);
    }), i.depthBuffer = r;
  }
  get vertexShader() {
    return `
	  varying vec2 vUv;
	  void main() {
	  	vUv = uv;
	  	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	  }
	`;
  }
  get fragmentShader() {
    return `
	  uniform sampler2D sceneColorBuffer;
	  uniform sampler2D planeBuffer;
	  uniform sampler2D glossBuffer;
	  uniform sampler2D outlineBuffer;
	  uniform vec4 screenSize;
	  uniform vec3 lineColor;
	  
	  uniform float outlineEnabled;
	  
      uniform int width;
	  uniform float opacity;
      uniform float tolerance;
      uniform float glossExponent;
      uniform float minGloss;
      uniform float maxGloss;
      uniform float glossEnabled;

	  varying vec2 vUv;

	  vec4 getValue(sampler2D buffer, int x, int y) {
	  	return texture2D(buffer, vUv + screenSize.zw * vec2(x, y));
	  }

      float normalDiff(vec3 normal1, vec3 normal2) {
        return ((dot(normal1, normal2) - 1.) * -1.) / 2.;
      }

      // Returns 0 if it's background, 1 if it's not
      float getIsBackground(vec3 normal) {
        float background = 1.0;
        background *= step(normal.x, 0.);
        background *= step(normal.y, 0.);
        background *= step(normal.z, 0.);
        background = (background - 1.) * -1.;
        return background;
      }

	  void main() {
	  
	    vec4 sceneColor = getValue(sceneColorBuffer, 0, 0);
	    vec3 normSceneColor = normalize(sceneColor.rgb);
  
        vec4 plane = getValue(planeBuffer, 0, 0);
	    vec3 normal = plane.xyz;
        float distance = plane.w;
  
        vec3 normalTop = getValue(planeBuffer, 0, width).rgb;
        vec3 normalBottom = getValue(planeBuffer, 0, -width).rgb;
        vec3 normalRight = getValue(planeBuffer, width, 0).rgb;
        vec3 normalLeft = getValue(planeBuffer, -width, 0).rgb;
        vec3 normalTopRight = getValue(planeBuffer, width, width).rgb;
        vec3 normalTopLeft = getValue(planeBuffer, -width, width).rgb;
        vec3 normalBottomRight = getValue(planeBuffer, width, -width).rgb;
        vec3 normalBottomLeft = getValue(planeBuffer, -width, -width).rgb;
  
        float distanceTop = getValue(planeBuffer, 0, width).a;
        float distanceBottom = getValue(planeBuffer, 0, -width).a;
        float distanceRight = getValue(planeBuffer, width, 0).a;
        float distanceLeft = getValue(planeBuffer, -width, 0).a;
        float distanceTopRight = getValue(planeBuffer, width, width).a;
        float distanceTopLeft = getValue(planeBuffer, -width, width).a;
        float distanceBottomRight = getValue(planeBuffer, width, -width).a;
        float distanceBottomLeft = getValue(planeBuffer, -width, -width).a;
        
        vec3 sceneColorTop = normalize(getValue(sceneColorBuffer, 1, 0).rgb);
        vec3 sceneColorBottom = normalize(getValue(sceneColorBuffer, -1, 0).rgb);
        vec3 sceneColorLeft = normalize(getValue(sceneColorBuffer, 0, -1).rgb);
        vec3 sceneColorRight = normalize(getValue(sceneColorBuffer, 0, 1).rgb);
        vec3 sceneColorTopRight = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomRight = normalize(getValue(sceneColorBuffer, -1, 1).rgb);
        vec3 sceneColorTopLeft = normalize(getValue(sceneColorBuffer, 1, 1).rgb);
        vec3 sceneColorBottomLeft = normalize(getValue(sceneColorBuffer, -1, 1).rgb);

        // Checks if the planes of this texel and the neighbour texels are different

        float planeDiff = 0.0;

        planeDiff += step(0.001, normalDiff(normal, normalTop));
        planeDiff += step(0.001, normalDiff(normal, normalBottom));
        planeDiff += step(0.001, normalDiff(normal, normalLeft));
        planeDiff += step(0.001, normalDiff(normal, normalRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopRight));
        planeDiff += step(0.001, normalDiff(normal, normalTopLeft));
        planeDiff += step(0.001, normalDiff(normal, normalBottomRight));
        planeDiff += step(0.001, normalDiff(normal, normalBottomLeft));
        
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTop));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottom));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorRight));
       	planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorTopLeft));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomRight));
        planeDiff += step(0.001, normalDiff(normSceneColor, sceneColorBottomLeft));

        planeDiff += step(0.001, abs(distance - distanceTop));
        planeDiff += step(0.001, abs(distance - distanceBottom));
        planeDiff += step(0.001, abs(distance - distanceLeft));
        planeDiff += step(0.001, abs(distance - distanceRight));
        planeDiff += step(0.001, abs(distance - distanceTopRight));
        planeDiff += step(0.001, abs(distance - distanceTopLeft));
        planeDiff += step(0.001, abs(distance - distanceBottomRight));
        planeDiff += step(0.001, abs(distance - distanceBottomLeft));

        // Add extra background outline

        int width2 = width + 1;
        vec3 normalTop2 = getValue(planeBuffer, 0, width2).rgb;
        vec3 normalBottom2 = getValue(planeBuffer, 0, -width2).rgb;
        vec3 normalRight2 = getValue(planeBuffer, width2, 0).rgb;
        vec3 normalLeft2 = getValue(planeBuffer, -width2, 0).rgb;
        vec3 normalTopRight2 = getValue(planeBuffer, width2, width2).rgb;
        vec3 normalTopLeft2 = getValue(planeBuffer, -width2, width2).rgb;
        vec3 normalBottomRight2 = getValue(planeBuffer, width2, -width2).rgb;
        vec3 normalBottomLeft2 = getValue(planeBuffer, -width2, -width2).rgb;

        planeDiff += -(getIsBackground(normalTop2) - 1.);
        planeDiff += -(getIsBackground(normalBottom2) - 1.);
        planeDiff += -(getIsBackground(normalRight2) - 1.);
        planeDiff += -(getIsBackground(normalLeft2) - 1.);
        planeDiff += -(getIsBackground(normalTopRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomRight2) - 1.);
        planeDiff += -(getIsBackground(normalBottomLeft2) - 1.);

        // Tolerance sets the minimum amount of differences to consider
        // this texel an edge

        float line = step(tolerance, planeDiff);

        // Exclude background and apply opacity

        float background = getIsBackground(normal);
        line *= background;
        line *= opacity;
        
        // Add gloss
        
        vec3 gloss = getValue(glossBuffer, 0, 0).xyz;
        float diffGloss = abs(maxGloss - minGloss);
        vec3 glossExpVector = vec3(glossExponent,glossExponent,glossExponent);
        gloss = min(pow(gloss, glossExpVector), vec3(1.,1.,1.));
        gloss *= diffGloss;
        gloss += minGloss;
        vec4 glossedColor = sceneColor + vec4(gloss, 1.) * glossEnabled;
        
        vec4 corrected = mix(sceneColor, glossedColor, background);
        
        // Draw lines
        
        corrected = mix(corrected, vec4(lineColor, 1.), line);
        
        // Add outline
        
        vec4 outlinePreview =getValue(outlineBuffer, 0, 0);
        float outlineColorCorrection = 1. / max(0.2, outlinePreview.a);
        vec3 outlineColor = outlinePreview.rgb * outlineColorCorrection;
        
        // thickness between 10 and 2, opacity between 1 and 0.2
	    int outlineThickness = int(outlinePreview.a * 10.);
	    
	    float outlineDiff = 0.;
        
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -1, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, 1).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, 0).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, 0, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, -outlineThickness, -outlineThickness).a);
        outlineDiff += step(0.1, getValue(outlineBuffer, outlineThickness, -outlineThickness).a);
        
        float outLine = step(4., outlineDiff) * step(outlineDiff, 12.) * outlineEnabled;
        corrected = mix(corrected, vec4(outlineColor, 1.), outLine);
        
        gl_FragColor = corrected;
	}
			`;
  }
  createOutlinePostProcessMaterial() {
    return new ShaderMaterial({
      uniforms: {
        opacity: { value: this._opacity },
        debugVisualize: { value: 0 },
        sceneColorBuffer: { value: null },
        tolerance: { value: this._tolerance },
        planeBuffer: { value: null },
        glossBuffer: { value: null },
        outlineBuffer: { value: null },
        glossEnabled: { value: 1 },
        minGloss: { value: this._minGloss },
        maxGloss: { value: this._maxGloss },
        outlineEnabled: { value: 0 },
        glossExponent: { value: this._glossExponent },
        width: { value: 1 },
        lineColor: { value: new Color(this._lineColor) },
        screenSize: {
          value: new Vector4(
            this.resolution.x,
            this.resolution.y,
            1 / this.resolution.x,
            1 / this.resolution.y
          )
        }
      },
      vertexShader: this.vertexShader,
      fragmentShader: this.fragmentShader
    });
  }
  newRenderTarget() {
    const e = new WebGLRenderTarget(
      this.resolution.x,
      this.resolution.y
    );
    return e.texture.colorSpace = "srgb-linear", e.texture.format = RGBAFormat, e.texture.type = HalfFloatType, e.texture.minFilter = NearestFilter, e.texture.magFilter = NearestFilter, e.texture.generateMipmaps = false, e.stencilBuffer = false, e;
  }
};
var Bl = class {
  constructor(t, e, i) {
    G(this, "composer");
    G(this, "overrideClippingPlanes", false);
    G(this, "_components");
    G(this, "_world");
    G(this, "_renderTarget");
    G(this, "_enabled", false);
    G(this, "_initialized", false);
    G(this, "_n8ao");
    G(this, "_customEffects");
    G(this, "_basePass");
    G(this, "_gammaPass");
    G(this, "_depthTexture");
    G(this, "_renderer");
    G(this, "_settings", {
      gamma: true,
      custom: true,
      ao: false
    });
    if (!i.renderer)
      throw new Error("The given world must have a renderer!");
    this._components = t, this._renderer = e, this._world = i, this._renderTarget = new WebGLRenderTarget(
      window.innerWidth,
      window.innerHeight
    ), this._renderTarget.texture.colorSpace = "srgb-linear", this.composer = new yl(e, this._renderTarget), this.composer.setSize(window.innerWidth, window.innerHeight);
  }
  /**
   * Getter for the base pass. Throws an error if the custom effects are not initialized.
   */
  get basePass() {
    if (!this._basePass)
      throw new Error("Custom effects not initialized!");
    return this._basePass;
  }
  /**
   * Getter for the gamma pass. Throws an error if the custom effects are not initialized.
   */
  get gammaPass() {
    if (!this._gammaPass)
      throw new Error("Custom effects not initialized!");
    return this._gammaPass;
  }
  /**
   * Getter for the custom effects pass. Throws an error if the custom effects are not initialized.
   */
  get customEffects() {
    if (!this._customEffects)
      throw new Error("Custom effects not initialized!");
    return this._customEffects;
  }
  /**
   * Getter for the N8AO pass. Throws an error if the custom effects are not initialized.
   */
  get n8ao() {
    if (!this._n8ao)
      throw new Error("Custom effects not initialized!");
    return this._n8ao;
  }
  /**
   * Getter for the enabled state of the post-processing effects.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the post-processing effects.
   * If the custom effects are not initialized, it calls the initialize method.
   * @param {boolean} active - The new enabled state.
   */
  set enabled(t) {
    this._initialized || this.initialize(), this._enabled = t;
  }
  /**
   * Getter for the current post-processing settings.
   */
  get settings() {
    return { ...this._settings };
  }
  /**
   * Disposes of the resources held by the post-processing manager.
   * This method should be called when the post-processing manager is no longer needed.
   * It releases the memory occupied by the render target, depth texture, custom effects pass, gamma pass, and N8AO pass.
   */
  dispose() {
    var t, e, i, s;
    this.composer.dispose(), this._renderTarget.dispose(), (t = this._depthTexture) == null || t.dispose(), (e = this._customEffects) == null || e.dispose(), (i = this._gammaPass) == null || i.dispose(), (s = this._n8ao) == null || s.dispose();
  }
  /**
   * Sets the post-processing settings and updates the passes accordingly.
   * This method checks if the settings have changed before updating the passes.
   *
   * @param settings - The new post-processing settings.
   * @returns {void}
   */
  setPasses(t) {
    let e = false;
    for (const i in t) {
      const s = i;
      if (this.settings[s] !== t[s]) {
        e = true;
        break;
      }
    }
    if (e) {
      for (const i in t) {
        const s = i;
        this._settings[s] !== void 0 && (this._settings[s] = t[s]);
      }
      this.updatePasses();
    }
  }
  /**
   * Sets the size of the render target and all related passes.
   * This method should be called when the window size changes to ensure that the post-processing effects are rendered correctly.
   *
   * @param width - The new width of the render target.
   * @param height - The new height of the render target.
   * @returns {void}
   */
  setSize(t, e) {
    if (!(t === 0 || e === 0) && this._initialized) {
      const i = this._settings.custom;
      i && this.setPasses({ custom: false }), this.composer.setSize(t, e), this.basePass.setSize(t, e), this.n8ao.setSize(t, e), this.customEffects.setSize(t, e), this.gammaPass.setSize(t, e), i && this.setPasses({ custom: true });
    }
  }
  /**
   * Updates the post-processing effects.
   * This method checks if the post-processing effects are enabled before rendering.
   * If the effects are enabled, it calls the `composer.render()` method to apply the effects.
   */
  update() {
    this._enabled && this.composer.render();
  }
  /**
   * Updates the camera settings for the post-processing effects.
   * This method is called whenever the camera settings change.
   * It updates the camera settings for the N8AO pass, custom effects pass, and base pass.
   */
  updateCamera() {
    const t = this._world.camera.three;
    this._n8ao && (this._n8ao.camera = t), this._customEffects && (this._customEffects.renderCamera = t), this._basePass && (this._basePass.camera = t);
  }
  /**
   * Updates the projection of the camera for the post-processing effects.
   * This method iterates over all passes in the EffectComposer and updates the camera property of each pass.
   * After updating the camera, it calls the update method to apply the changes.
   *
   * @param camera - The new camera to use for the post-processing effects.
   * @returns {void}
   */
  updateProjection(t) {
    this.composer.passes.forEach((e) => {
      e.camera = t;
    }), this.update();
  }
  initialize() {
    if (!this._world.renderer)
      throw new Error("The given world must have a renderer!");
    const t = this._world.scene.three, e = this._world.camera.three, i = this._world.camera;
    i.projection && i.projection.onChanged.add(() => {
      this.updateCamera();
    });
    const s = this._world.renderer;
    this.overrideClippingPlanes || (this._renderer.clippingPlanes = s.clippingPlanes), this._renderer.outputColorSpace = "srgb", this._renderer.toneMapping = NoToneMapping, this.newBasePass(t, e), this.newSaoPass(t, e), this.newGammaPass(), this.newCustomPass(t, e), this._initialized = true, this.updatePasses();
  }
  updatePasses() {
    for (const t of this.composer.passes)
      this.composer.removePass(t);
    this._basePass && this.composer.addPass(this.basePass), this._settings.gamma && this.composer.addPass(this.gammaPass), this._settings.ao && this.composer.addPass(this.n8ao), this._settings.custom && this.composer.addPass(this.customEffects);
  }
  newCustomPass(t, e) {
    this._customEffects = new kl(
      new Vector2(window.innerWidth, window.innerHeight),
      this._components,
      this._world,
      t,
      e
    );
  }
  newGammaPass() {
    this._gammaPass = new nn(Dl);
  }
  newSaoPass(t, e) {
    if (!this._world.renderer)
      throw new Error("The given world must have a renderer!");
    const { width: i, height: s } = this._world.renderer.getSize();
    this._n8ao = new Ol(t, e, i, s);
    const { configuration: r } = this._n8ao;
    r.aoSamples = 16, r.denoiseSamples = 1, r.denoiseRadius = 13, r.aoRadius = 1, r.distanceFalloff = 4, r.aoRadius = 1, r.intensity = 4, r.halfRes = true, r.color = new Color().setHex(13421772, "srgb-linear");
  }
  newBasePass(t, e) {
    this._basePass = new wl(t, e);
  }
};
var Vl = class extends fl {
  constructor(e, i, s) {
    super(e, i, s);
    G(this, "_postproduction");
    this.onResize.add((r) => this.resizePostproduction(r)), this.onWorldChanged.add(() => {
      this.currentWorld && (this._postproduction && this._postproduction.dispose(), this._postproduction = new Bl(
        e,
        this.three,
        this.currentWorld
      ), this.setPostproductionSize());
    });
  }
  /**
   * Getter for the postproduction instance.
   * Throws an error if the postproduction instance is not yet initialized.
   *
   * @returns The initialized Postproduction instance.
   */
  get postproduction() {
    if (!this._postproduction)
      throw new Error("Renderer not initialized yet with a world!");
    return this._postproduction;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger();
    const e = this.currentWorld.scene.three, i = this.currentWorld.camera.three;
    this.postproduction.enabled ? this.postproduction.composer.render() : this.three.render(e, i), e instanceof Scene && this.three2D.render(e, i), this.onAfterUpdate.trigger();
  }
  /** {@link OBC.Disposable.dispose}. */
  dispose() {
    super.dispose(), this.postproduction.dispose();
  }
  resizePostproduction(e) {
    this.postproduction && this.setPostproductionSize(e);
  }
  setPostproductionSize(e) {
    if (!this.container)
      return;
    const i = e ? e.x : this.container.clientWidth, s = e ? e.y : this.container.clientHeight;
    this.postproduction.setSize(i, s);
  }
};
var oi = class oi2 extends Zt {
  constructor(e) {
    super(e);
    G(this, "onDisposed", new it());
    G(this, "onBeforeUpdate", new it());
    G(this, "onAfterUpdate", new it());
    G(this, "onSetup", new it());
    G(this, "isSetup", false);
    G(this, "enabled", true);
    G(this, "events", {});
    G(this, "multiple", "ctrlKey");
    G(this, "zoomFactor", 1.5);
    G(this, "zoomToSelection", false);
    G(this, "backupColor", null);
    G(this, "selection", {});
    G(this, "config", {
      selectName: "select",
      hoverName: "hover",
      selectionColor: new Color("#BCF124"),
      hoverColor: new Color("#6528D7"),
      autoHighlightOnClick: true,
      world: null,
      selectEnabled: true,
      hoverEnabled: true
    });
    G(this, "styles", /* @__PURE__ */ new Map());
    G(this, "autoToggle", /* @__PURE__ */ new Set());
    G(this, "mouseDownPosition", { x: 0, y: 0 });
    G(this, "mouseMoveThreshold", 5);
    G(this, "selectable", null);
    G(this, "eventManager", new zn());
    G(this, "_mouseState", {
      down: false,
      moved: false
    });
    G(this, "_stylesBeforeSelect", {});
    G(this, "saveHighlightersBeforeSelect", (e2) => {
      for (const i in this.selection) {
        if (i === this.config.selectName)
          continue;
        const s = this.selection[i];
        for (const r in e2)
          if (s[r])
            for (const o of e2[r])
              s[r].has(o) && (this._stylesBeforeSelect[i] || (this._stylesBeforeSelect[i] = {}), this._stylesBeforeSelect[i][r] || (this._stylesBeforeSelect[i][r] = /* @__PURE__ */ new Set()), this._stylesBeforeSelect[i][r].add(o));
      }
    });
    G(this, "restoreHighlightersAfterDeselect", () => {
      for (const e2 in this._stylesBeforeSelect) {
        const i = this._stylesBeforeSelect[e2], s = {};
        this.selection[e2] || (this.selection[e2] = {});
        for (const o in i) {
          this.selection[e2][o] || (this.selection[e2][o] = /* @__PURE__ */ new Set()), s[o] = Array.from(i[o]);
          const n = i[o];
          for (const l of n)
            this.selection[e2][o].add(l);
        }
        const r = this.styles.get(e2);
        this.updateItems(r, s);
      }
      this._stylesBeforeSelect = {};
    });
    G(this, "onMouseDown", (e2) => {
      this.enabled && (this.mouseDownPosition = { x: e2.clientX, y: e2.clientY }, this._mouseState.down = true);
    });
    G(this, "onMouseUp", async (e2) => {
      if (!this.enabled)
        return;
      const { world: i, autoHighlightOnClick: s, selectEnabled: r } = this.config;
      if (!i)
        throw new Error("No world found!");
      if (!i.renderer)
        throw new Error("This world doesn't have a renderer!");
      if (e2.target === i.renderer.three.domElement) {
        if (this._mouseState.down = false, this._mouseState.moved || e2.button !== 0) {
          this._mouseState.moved = false;
          return;
        }
        if (this._mouseState.moved = false, s && r) {
          const o = this.multiple === "none" ? true : !e2[this.multiple];
          await this.highlight(this.config.selectName, o, this.zoomToSelection);
        }
      }
    });
    G(this, "onMouseMove", async (e2) => {
      if (!this.enabled)
        return;
      const i = e2.clientX - this.mouseDownPosition.x, s = e2.clientY - this.mouseDownPosition.y, r = Math.sqrt(i * i + s * s);
      this._mouseState.moved || r > this.mouseMoveThreshold && (this._mouseState.moved = this._mouseState.down);
    });
    this.components.add(oi2.uuid, this), this.eventManager.list.add(this.onSetup), this.eventManager.list.add(this.onDisposed);
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.setupEvents(false), this.onBeforeUpdate.reset(), this.onAfterUpdate.reset(), this.selection = {};
    for (const e in this.events) {
      const { onClear: i, onHighlight: s } = this.events[e];
      this.eventManager.list.delete(i), this.eventManager.list.delete(s);
    }
    this.onDisposed.trigger(oi2.uuid), this.eventManager.reset();
  }
  /**
   * Adds a new selection with the given name and color.
   * Throws an error if a selection with the same name already exists.
   *
   * @param name - The name of the new selection.
   * @param color - The color to be used for highlighting the selection.
   *
   * @throws Will throw an error if a selection with the same name already exists.
   */
  add(e) {
    const { name: i } = e;
    if (this.selection[i] || this.styles.has(i))
      throw new Error("A highlight with that name already exists!");
    this.styles.set(i, e), this.selection[i] = {};
    const s = new it(), r = new it(), o = new it();
    this.events[i] = {
      onHighlight: s,
      onClear: o,
      onBeforeHighlight: r
    }, this.eventManager.add([o, s, r]);
  }
  /**
   * Removes the specified selection.
   *
   * @param name - The name of the new selection.
   */
  async remove(e) {
    if (await this.clear(e), delete this.selection[e], this.styles.delete(e), this.selection[e] || this.styles.has(e))
      throw new Error("A selection with that name already exists!");
    if (this.events[e]) {
      const { onHighlight: i, onClear: s, onBeforeHighlight: r } = this.events[e];
      this.eventManager.remove([s, i, r]), delete this.events[e];
    }
  }
  /**
   * Highlights a fragment based on a raycast from the mouse position.
   *
   * @param name - The name of the selection.
   * @param removePrevious - Whether to remove previous highlights.
   * @param zoomToSelection - Whether to zoom to the highlighted selection.
   * @param exclude - Fragments to exclude from the highlight.
   *
   * @returns The highlighted fragment and its ID, or null if no fragment was highlighted.
   *
   * @throws Will throw an error if the world or a required component is not found.
   * @throws Will throw an error if the selection does not exist.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  async highlight(e, i = true, s = this.zoomToSelection, r = null) {
    if (!this.enabled)
      return null;
    if (!this.config.world)
      throw new Error("No world found in config!");
    const o = this.config.world;
    if (!this.selection[e])
      throw new Error(`Selection ${e} does not exist.`);
    const c = await this.components.get(Xo).get(o).castRay();
    if (!c || !c.localId)
      return await this.clear(e), null;
    const {
      localId: d,
      model: { modelId: f }
    } = c, p = { [f]: [d] };
    return await this.highlightByID(
      e,
      p,
      i,
      s,
      r,
      true
    ), p;
  }
  // TODO: Make parameters an object?
  /**
   * Highlights a fragment based on a given fragment ID map.
   *
   * @param name - The name of the selection.
   * @param modelIdMap - The fragment ID map to highlight.
   * @param removePrevious - Whether to remove previous highlights.
   * @param zoomToSelection - Whether to zoom to the highlighted selection.
   * @param exclude - Fragments to exclude from the highlight.
   * @param fillMesh - The fill mesh to also highlight, if any.
   * @param isPicking - Whether this function is called when picking with the mouse.
   *
   * @returns Promise that resolves when the highlighting is complete.
   *
   * @throws Will throw an error if the selection does not exist.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  async highlightByID(e, i, s = true, r = this.zoomToSelection, o = null, n = false) {
    if (!this.enabled)
      return;
    this.events[e].onBeforeHighlight.trigger(this.selection[e]), s && await this.clear(e);
    const l = this.styles.get(e);
    if (l === void 0)
      throw new Error("Style for selection not found!");
    let c = {};
    if (this.selectable !== null || o !== null)
      for (const f in i) {
        const p = new Set(i[f]), u = this.selectable[e], g = u ? u[f] : void 0, m = g ? new Set(g) : void 0, b = o[f], h = b ? new Set(b) : void 0;
        if (h || m)
          for (const v of p)
            h && h.has(v) || m && !m.has(v) || (c[f] || (c[f] = []), c[f].push(v));
      }
    else
      c = i;
    if (n && this.autoToggle.has(e)) {
      const f = {};
      let p = false;
      for (const u in c) {
        const g = this.selection[e][u];
        if (!g)
          continue;
        const m = c[u];
        for (const b of m)
          g.has(b) ? (g.delete(b), f[u] || (f[u] = []), f[u].push(b), p = true) : g.add(b);
        c[u] = Array.from(g);
      }
      p && await this.clearItems(f);
    }
    const d = this.selection[e];
    for (const f in c) {
      d[f] || (d[f] = /* @__PURE__ */ new Set());
      const p = c[f];
      for (const u of p)
        d[f].add(u);
    }
    this.updateItems(l, c), this.events[e].onHighlight.trigger(this.selection[e]), r && await this.zoomSelection(c);
  }
  async updateItems(e, i) {
    const s = { ...e, customId: e.name }, r = this.components.get(It);
    r.core.highlight(s, i), r.core.update(true);
  }
  async clearItems(e) {
    this.components.get(It).core.resetHighlight(e);
  }
  /**
   * Clears the selection for the given name or all selections if no name is provided.
   *
   * @param name - The name of the selection to clear. If not provided, clears all selections.
   * @param filter - The only items to unselect. If not provided, all items will be unselected.
   *
   */
  async clear(e, i) {
    const s = this.components.get(It), r = e ? [e] : Object.keys(this.selection);
    if (i)
      s.core.resetHighlight(i);
    else {
      const o = [];
      for (const n of r) {
        const l = this.selection[n];
        l && (o.push(s.core.resetHighlight(l)), o.push(s.core.update(true)), this.selection[n] = {});
      }
      await Promise.all(o);
    }
    for (const o of r)
      this.events[o].onClear.trigger(null);
  }
  /**
   * Sets up the Highlighter with the provided configuration.
   *
   * @param config - Optional configuration for the Highlighter.
   * If not provided, the Highlighter will use the default configuration.
   *
   * @throws Will throw an error if the world or a required component is not found.
   * @throws Will throw an error if the selection already exists.
   * @throws Will throw an error if the fragment or its geometry is not found.
   * @throws Will throw an error if the item ID is not found.
   * @throws Will throw an error if the fragment does not belong to a FragmentsGroup.
   */
  setup(e) {
    this.config = { ...this.config, ...e };
    const i = {
      name: this.config.selectName,
      color: this.config.selectionColor,
      opacity: 1,
      transparent: false,
      side: 0
    };
    this.add(i), this.autoToggle.add(this.config.selectName), this.setupEvents(true), this.enabled = true, this.isSetup = true, this.onSetup.trigger(this);
  }
  async zoomSelection(e) {
    if (!this.config.world)
      throw new Error("No world found in config!");
    const i = this.config.world;
    let s = false;
    for (const v in e)
      if (e[v].length > 0) {
        s = true;
        break;
      }
    if (!s || !i.camera.hasCameraControls())
      return;
    const o = await this.components.get(It).core.getBBoxes(e), n = new Sphere(), l = new Box3();
    for (const v of o)
      l.union(v);
    l.getBoundingSphere(n);
    const c = 1 / 0, d = -1 / 0, { x: f, y: p, z: u } = n.center, g = n.radius === c || f === c || p === c || u === c, m = n.radius === d || f === d || p === d || u === d, b = n.radius === 0;
    if (g || m || b)
      return;
    n.radius *= this.zoomFactor, await i.camera.controls.fitToSphere(n, true);
  }
  setupEvents(e) {
    if (!this.config.world) {
      console.log("No world found while setting up events!");
      return;
    }
    if (this.config.world.isDisposing)
      return;
    if (!this.config.world.renderer)
      throw new Error("The given world doesn't have a renderer!");
    const i = this.config.world.renderer.three.domElement, s = this.events[this.config.selectName].onHighlight;
    s.remove(this.saveHighlightersBeforeSelect);
    const r = this.events[this.config.selectName].onClear;
    r.remove(this.restoreHighlightersAfterDeselect), i.removeEventListener("mousedown", this.onMouseDown), i.removeEventListener("mouseup", this.onMouseUp), i.removeEventListener("pointermove", this.onMouseMove), e && (s.add(this.saveHighlightersBeforeSelect), r.add(this.restoreHighlightersAfterDeselect), i.addEventListener("mousedown", this.onMouseDown), i.addEventListener("mouseup", this.onMouseUp), i.addEventListener("pointermove", this.onMouseMove));
  }
};
G(oi, "uuid", "cb8a76f2-654a-4b50-80c6-66fd83cafd77");
var Mi = oi;
var Il = class extends Zt {
  constructor() {
    super(...arguments);
    G(this, "_world");
    G(this, "outlinePositions", false);
    G(this, "points", new Points(
      new BufferGeometry(),
      new PointsMaterial({
        size: 10,
        sizeAttenuation: false,
        depthTest: false
      })
    ));
  }
  /**
   * The world where the outliner operates.
   */
  set world(e) {
    if (this._world = e, !e)
      return;
    this.getRenderer().postproduction.customEffects.excludedMeshes.push(this.points);
  }
  get world() {
    return this._world;
  }
  /** {@link OBC.Component.enabled} */
  get enabled() {
    return !this.world || this.world.isDisposing ? false : this.getRenderer().postproduction.customEffects.outlineEnabled;
  }
  /** {@link OBC.Component.enabled} */
  set enabled(e) {
    if (!this.world || this.world.isDisposing)
      return;
    const i = this.getRenderer();
    i.postproduction.customEffects.outlineEnabled = e, this.outlinePositions && (this.points.material.color = this.color, this.world.scene.three.add(this.points));
  }
  get color() {
    return this.getRenderer().postproduction.customEffects.outlineMaterial.color;
  }
  set color(e) {
    this.getRenderer().postproduction.customEffects.outlineMaterial.color.copy(e), this.points.material.color.copy(e);
  }
  get thickness() {
    return this.getRenderer().postproduction.customEffects.outlineMaterial.opacity;
  }
  set thickness(e) {
    const i = this.getRenderer().postproduction.customEffects;
    i.outlineMaterial.opacity = e;
  }
  add(e) {
    if (this.getRenderer().postproduction.customEffects.outlinedStyles.add(e), this.outlinePositions) {
      const s = this.components.get(Mi);
      this.outlinePositions && (s.events[e].onHighlight.add(async () => {
        await this.updatePoints();
      }), s.events[e].onClear.add(async () => {
        await this.updatePoints();
      }));
    }
  }
  delete(e) {
    this.getRenderer().postproduction.customEffects.outlinedStyles.delete(e);
  }
  async updatePoints() {
    const e = {}, i = this.components.get(Mi), r = this.getRenderer().postproduction.customEffects.outlinedStyles;
    let o = 0;
    for (const c of r) {
      const d = i.selection[c];
      for (const f in d) {
        e[f] || (e[f] = []);
        for (const p of d[f])
          e[f].push(p), o++;
      }
    }
    this.points.geometry.setAttribute(
      "position",
      new Float32BufferAttribute(new Float32Array(o * 3), 3)
    );
    const l = await this.components.get(It).core.getPositions(e);
    for (let c = 0; c < l.length; c++) {
      const { x: d, y: f, z: p } = l[c];
      this.points.geometry.attributes.position.array[c * 3] = d, this.points.geometry.attributes.position.array[c * 3 + 1] = f, this.points.geometry.attributes.position.array[c * 3 + 2] = p;
    }
    this.points.geometry.attributes.position.needsUpdate = true;
  }
  getRenderer() {
    if (!this.world)
      throw new Error("You must set a world to use the outliner!");
    const e = this.world.renderer;
    if (!e.postproduction)
      throw new Error(
        "The world given to the outliner must use the postproduction renderer."
      );
    return e;
  }
};
G(Il, "uuid", "2fd3bcc5-b3b6-4ded-9f64-f47a02854a10");
export {
  Mi as Highlighter,
  xr as Mark,
  _r as Marker,
  Il as Outliner,
  gr as PlatformComponents,
  Bl as Postproduction,
  Vl as PostproductionRenderer,
  fl as RendererWith2D
};
/*! Bundled license information:

@thatopen-platform/components-front-beta/dist/index.js:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/
//# sourceMappingURL=@thatopen-platform_components-front-beta.js.map
