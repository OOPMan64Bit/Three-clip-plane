import { ExecutionEntity, ExecutionSuscriptionReturnType } from '../types/execution';
import { ComponentItem, ComponentVersionProps, Item, ItemFolder, ItemWithVersions } from '../types/items';
import { CreateItemResponse, UpdateItemResponse } from '../types/response';
import { CreateHiddenItemResult, HiddenFileEntity } from '../types/files';

export type CreateItemProps = {
    file: File;
    name: string;
    versionTag: string;
    parentFolderId?: string;
};
export type UpdateItemProps = {
    name?: string;
    parentFolderId?: string;
    file?: File;
    versionTag?: string;
};
export type GetItemProps = {
    showVersions?: boolean;
};
export type CreateComponentProps = CreateItemProps & {
    componentProps: ComponentVersionProps;
};
export type UpdateComponentProps = UpdateItemProps & {
    componentProps: ComponentVersionProps;
};
export type DownloadItemFileParams = {
    versionTag?: string;
    withDraft?: boolean;
};
export type EngineServicesClientProps = {
    retries?: number;
};
export declare class EngineServicesClient {
    #private;
    private apiUrl;
    private accessToken;
    private wsUrl;
    private retries;
    constructor(accessToken: string, apiUrl: string, props?: EngineServicesClientProps);
    setRetries(retries: number): void;
    listFolders(params: {
        parentFolderId?: string;
        archived?: boolean;
    }): Promise<ItemFolder[]>;
    getFolder(folderId: string): Promise<ItemFolder>;
    createFolder(name: string): Promise<ItemFolder>;
    updateFolder(folderId: string, updateFolderParams: {
        name?: string;
    }): Promise<ItemFolder>;
    archiveFolder(folderId: string): Promise<ItemFolder>;
    recoverFolder(folderId: string): Promise<ItemFolder>;
    recoverFile(fileId: string): Promise<ItemFolder>;
    listFiles(filters?: {
        folderId?: string;
        archived?: boolean;
    }): Promise<ItemFolder[] | Item[]>;
    getFile(fileId: string, props?: GetItemProps): Promise<ItemWithVersions<ItemWithVersions<Item>>>;
    downloadFile(fileId: string, params?: DownloadItemFileParams): Promise<Response>;
    downloadComponent(componentId: string, params?: DownloadItemFileParams): Promise<Response>;
    downloadComponentBundle(componentId: string, params?: DownloadItemFileParams): Promise<Response>;
    downloadApp(appId: string, params?: DownloadItemFileParams): Promise<Response>;
    downloadFolder(folderId: string): Promise<Response>;
    createFile(fileData: CreateItemProps): Promise<CreateItemResponse<Item>>;
    updateFile(fileId: string, fileData: UpdateItemProps): Promise<UpdateItemResponse>;
    archiveFile(fileId: string): Promise<Item>;
    listComponents(folderId?: string): Promise<ComponentItem[]>;
    getComponent(componentId: string, props: GetItemProps): Promise<ItemWithVersions<ItemWithVersions<ComponentItem>>>;
    /**
     * Create a new component.
     * @function√ü
     */
    createComponent(componentData: CreateComponentProps): Promise<CreateItemResponse<ComponentItem>>;
    /**
     * Update a component.
     * @function
     */
    updateComponent(fileId: string, componentData: UpdateComponentProps): Promise<UpdateItemResponse>;
    archiveComponent(componentId: string): Promise<ComponentItem>;
    recoverComponent(componentId: string): Promise<ComponentItem>;
    executeComponent(componentId: string, executionParams: object, versionTag?: string): Promise<{
        executionId: string;
    }>;
    listExecutions(componentId: string): Promise<ExecutionEntity[]>;
    getExecution(executionId: string): Promise<ExecutionEntity>;
    abortExecution(executionId: string): Promise<ExecutionEntity>;
    /** @function
     * @name myFunction
     * @param {string} executionId - Identifier of the execution.
     * @param {string} onUpdateCallback - Callback function to be called when the execution is updated.
     * @returns {void} - Nothing is returned. Connection is closed on its own
     * */
    onExecutionProgress(executionId: string, onUpdateCallback: (data: ExecutionSuscriptionReturnType) => void): Promise<void>;
    /** @function
     * @name createHiddenFile
     * @returns {string} - Returns id of the created hidden file.
     * */
    createHiddenFile(file: File, parentFileId: string): Promise<CreateHiddenItemResult>;
    deleteHiddenFile(hiddenId: string): Promise<Item>;
    getHiddenFile(hiddenId: string): Promise<HiddenFileEntity>;
    downloadHiddenFile(hiddenId: string): Promise<Response>;
    getHiddenFilesByParent(parentFileId: string): Promise<HiddenFileEntity[]>;
    deleteHiddenFileByParent(parentFileId: string): Promise<Item[]>;
}
